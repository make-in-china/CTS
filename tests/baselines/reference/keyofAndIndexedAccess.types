=== tests/cases/conformance/types/keyof/keyofAndIndexedAccess.ts ===
class Shape {
>Shape : Shape

    name: string;
>name : 文字
>类型别名 :=> 文字

    width: number;
>width : 数字
>类型别名 :=> 数字

    height: number;
>height : 数字
>类型别名 :=> 数字

    visible: boolean;
>visible : 真假
>类型别名 :=> 真假
}

class TaggedShape extends Shape {
>TaggedShape : TaggedShape
>Shape : Shape

    tag: string;
>tag : 文字
>类型别名 :=> 文字
}

class Item {
>Item : Item

    name: string;
>name : 文字
>类型别名 :=> 文字

    price: number;
>price : 数字
>类型别名 :=> 数字
}

class Options {
>Options : Options

    visible: "yes" | "no";
>visible : "yes" | "no"
}

type Dictionary<T> = { [x: string]: T };
>Dictionary : Dictionary<T>
>T : T
>x : 文字
>类型别名 :=> 文字
>T : T

type NumericallyIndexed<T> = { [x: number]: T };
>NumericallyIndexed : NumericallyIndexed<T>
>T : T
>x : 数字
>类型别名 :=> 数字
>T : T

const enum E { A, B, C }
>E : E
>A : E.A
>B : E.B
>C : E.C

type K00 = keyof any;  // string
>K00 : 文字
>类型别名 :=> 文字

type K01 = keyof string;  // "toString" | "charAt" | ...
>K01 : "length" | "toString" | "concat" | "slice" | "indexOf" | "lastIndexOf" | "charAt" | "charCodeAt" | "localeCompare" | "match" | "replace" | "search" | "split" | "substring" | "toLowerCase" | "toLocaleLowerCase" | "toUpperCase" | "toLocaleUpperCase" | "trim" | "substr" | "valueOf"

type K02 = keyof number;  // "toString" | "toFixed" | "toExponential" | ...
>K02 : "toString" | "toLocaleString" | "valueOf" | "toFixed" | "toExponential" | "toPrecision"

type K03 = keyof boolean;  // "valueOf"
>K03 : "valueOf"

type K04 = keyof void;  // never
>K04 : 不及
>类型别名 :=> 不及

type K05 = keyof undefined;  // never
>K05 : 不及
>类型别名 :=> 不及

type K06 = keyof null;  // never
>K06 : 不及
>类型别名 :=> 不及
>null : 空值
>类型别名 :=> 空值

type K07 = keyof never;  // never
>K07 : 不及
>类型别名 :=> 不及

type K10 = keyof Shape;  // "name" | "width" | "height" | "visible"
>K10 : "name" | "width" | "height" | "visible"
>Shape : Shape

type K11 = keyof Shape[];  // "length" | "toString" | ...
>K11 : "length" | "toString" | "toLocaleString" | "push" | "pop" | "concat" | "join" | "reverse" | "shift" | "slice" | "sort" | "splice" | "unshift" | "indexOf" | "lastIndexOf" | "every" | "some" | "forEach" | "map" | "filter" | "reduce" | "reduceRight"
>Shape : Shape

type K12 = keyof Dictionary<Shape>;  // string
>K12 : 文字
>类型别名 :=> 文字
>Dictionary : Dictionary<T>
>Shape : Shape

type K13 = keyof {};  // never
>K13 : 不及
>类型别名 :=> 不及

type K14 = keyof Object;  // "constructor" | "toString" | ...
>K14 : "toString" | "toLocaleString" | "valueOf" | "constructor" | "hasOwnProperty" | "isPrototypeOf" | "propertyIsEnumerable"
>Object : Object

type K15 = keyof E;  // "toString" | "toFixed" | "toExponential" | ...
>K15 : "toString" | "toLocaleString" | "valueOf" | "toFixed" | "toExponential" | "toPrecision"
>E : E

type K16 = keyof [string, number];  // "0" | "1" | "length" | "toString" | ...
>K16 : "0" | "1" | "length" | "toString" | "toLocaleString" | "push" | "pop" | "concat" | "join" | "reverse" | "shift" | "slice" | "sort" | "splice" | "unshift" | "indexOf" | "lastIndexOf" | "every" | "some" | "forEach" | "map" | "filter" | "reduce" | "reduceRight"

type K17 = keyof (Shape | Item);  // "name"
>K17 : "name"
>Shape : Shape
>Item : Item

type K18 = keyof (Shape & Item);  // "name" | "width" | "height" | "visible" | "price"
>K18 : "name" | "width" | "height" | "visible" | "price"
>Shape : Shape
>Item : Item

type K19 = keyof NumericallyIndexed<Shape> // never
>K19 : 不及
>类型别名 :=> 不及
>NumericallyIndexed : NumericallyIndexed<T>
>Shape : Shape

type KeyOf<T> = keyof T;
>KeyOf : 键集 T
>T : T
>T : T

type K20 = KeyOf<Shape>;  // "name" | "width" | "height" | "visible"
>K20 : "name" | "width" | "height" | "visible"
>KeyOf : 键集 T
>Shape : Shape

type K21 = KeyOf<Dictionary<Shape>>;  // string
>K21 : 文字
>类型别名 :=> 文字
>KeyOf : 键集 T
>Dictionary : Dictionary<T>
>Shape : Shape

type NAME = "name";
>NAME : "name"

type WIDTH_OR_HEIGHT = "width" | "height";
>WIDTH_OR_HEIGHT : "width" | "height"

type Q10 = Shape["name"];  // string
>Q10 : 文字
>类型别名 :=> 文字
>Shape : Shape

type Q11 = Shape["width" | "height"];  // number
>Q11 : 数字
>类型别名 :=> 数字
>Shape : Shape

type Q12 = Shape["name" | "visible"];  // string | boolean
>Q12 : 文字 | 真假
>Shape : Shape

type Q20 = Shape[NAME];  // string
>Q20 : 文字
>类型别名 :=> 文字
>Shape : Shape
>NAME : "name"

type Q21 = Shape[WIDTH_OR_HEIGHT];  // number
>Q21 : 数字
>类型别名 :=> 数字
>Shape : Shape
>WIDTH_OR_HEIGHT : "width" | "height"

type Q30 = [string, number][0];  // string
>Q30 : 文字
>类型别名 :=> 文字

type Q31 = [string, number][1];  // number
>Q31 : 数字
>类型别名 :=> 数字

type Q32 = [string, number][2];  // string | number
>Q32 : 文字 | 数字

type Q33 = [string, number][E.A];  // string
>Q33 : 文字
>类型别名 :=> 文字
>E : 任意
>类型别名 :=> 任意
>A : E.A

type Q34 = [string, number][E.B];  // number
>Q34 : 数字
>类型别名 :=> 数字
>E : 任意
>类型别名 :=> 任意
>B : E.B

type Q35 = [string, number][E.C];  // string | number
>Q35 : 文字 | 数字
>E : 任意
>类型别名 :=> 任意
>C : E.C

type Q36 = [string, number]["0"];  // string
>Q36 : 文字
>类型别名 :=> 文字

type Q37 = [string, number]["1"];  // string
>Q37 : 数字
>类型别名 :=> 数字

type Q40 = (Shape | Options)["visible"];  // boolean | "yes" | "no"
>Q40 : 真假 | "yes" | "no"
>Shape : Shape
>Options : Options

type Q41 = (Shape & Options)["visible"];  // true & "yes" | true & "no" | false & "yes" | false & "no"
>Q41 : 不及
>类型别名 :=> 不及
>Shape : Shape
>Options : Options

type Q50 = Dictionary<Shape>["howdy"];  // Shape
>Q50 : Shape
>Dictionary : Dictionary<T>
>Shape : Shape

type Q51 = Dictionary<Shape>[123];  // Shape
>Q51 : Shape
>Dictionary : Dictionary<T>
>Shape : Shape

type Q52 = Dictionary<Shape>[E.B];  // Shape
>Q52 : Shape
>Dictionary : Dictionary<T>
>Shape : Shape
>E : 任意
>类型别名 :=> 任意
>B : E.B

declare let cond: boolean;
>cond : 真假
>类型别名 :=> 真假

function getProperty<T, K extends keyof T>(obj: T, key: K) {
>getProperty : <T, K 扩展 键集 T>(obj: T, key: K) => T[K]
>T : T
>K : K
>T : T
>obj : T
>T : T
>key : K
>K : K

    return obj[key];
>obj[key] : T[K]
>obj : T
>key : K
}

function setProperty<T, K extends keyof T>(obj: T, key: K, value: T[K]) {
>setProperty : <T, K 扩展 键集 T>(obj: T, key: K, value: T[K]) => 无值
>T : T
>K : K
>T : T
>obj : T
>T : T
>key : K
>K : K
>value : T[K]
>T : T
>K : K

    obj[key] = value;
>obj[key] = value : T[K]
>obj[key] : T[K]
>obj : T
>key : K
>value : T[K]
}

function f10(shape: Shape) {
>f10 : (shape: Shape) => 无值
>shape : Shape
>Shape : Shape

    let name = getProperty(shape, "name");  // string
>name : 文字
>类型别名 :=> 文字
>getProperty(shape, "name") : 文字
>类型别名 :=> 文字
>getProperty : <T, K 扩展 键集 T>(obj: T, key: K) => T[K]
>shape : Shape
>"name" : "name"

    let widthOrHeight = getProperty(shape, cond ? "width" : "height");  // number
>widthOrHeight : 数字
>类型别名 :=> 数字
>getProperty(shape, cond ? "width" : "height") : 数字
>类型别名 :=> 数字
>getProperty : <T, K 扩展 键集 T>(obj: T, key: K) => T[K]
>shape : Shape
>cond ? "width" : "height" : "width" | "height"
>cond : 真假
>类型别名 :=> 真假
>"width" : "width"
>"height" : "height"

    let nameOrVisible = getProperty(shape, cond ? "name" : "visible");  // string | boolean
>nameOrVisible : 文字 | 真假
>getProperty(shape, cond ? "name" : "visible") : 文字 | 真假
>getProperty : <T, K 扩展 键集 T>(obj: T, key: K) => T[K]
>shape : Shape
>cond ? "name" : "visible" : "name" | "visible"
>cond : 真假
>类型别名 :=> 真假
>"name" : "name"
>"visible" : "visible"

    setProperty(shape, "name", "rectangle");
>setProperty(shape, "name", "rectangle") : 无值
>类型别名 :=> 无值
>setProperty : <T, K 扩展 键集 T>(obj: T, key: K, value: T[K]) => 无值
>shape : Shape
>"name" : "name"
>"rectangle" : "rectangle"

    setProperty(shape, cond ? "width" : "height", 10);
>setProperty(shape, cond ? "width" : "height", 10) : 无值
>类型别名 :=> 无值
>setProperty : <T, K 扩展 键集 T>(obj: T, key: K, value: T[K]) => 无值
>shape : Shape
>cond ? "width" : "height" : "width" | "height"
>cond : 真假
>类型别名 :=> 真假
>"width" : "width"
>"height" : "height"
>10 : 10

    setProperty(shape, cond ? "name" : "visible", true);  // Technically not safe
>setProperty(shape, cond ? "name" : "visible", true) : 无值
>类型别名 :=> 无值
>setProperty : <T, K 扩展 键集 T>(obj: T, key: K, value: T[K]) => 无值
>shape : Shape
>cond ? "name" : "visible" : "name" | "visible"
>cond : 真假
>类型别名 :=> 真假
>"name" : "name"
>"visible" : "visible"
>true : 为真
>类型别名 :=> 为真
}

function f11(a: Shape[]) {
>f11 : (a: Shape[]) => 无值
>a : Shape[]
>Shape : Shape

    let len = getProperty(a, "length");  // number
>len : 数字
>类型别名 :=> 数字
>getProperty(a, "length") : 数字
>类型别名 :=> 数字
>getProperty : <T, K 扩展 键集 T>(obj: T, key: K) => T[K]
>a : Shape[]
>"length" : "length"

    setProperty(a, "length", len);
>setProperty(a, "length", len) : 无值
>类型别名 :=> 无值
>setProperty : <T, K 扩展 键集 T>(obj: T, key: K, value: T[K]) => 无值
>a : Shape[]
>"length" : "length"
>len : 数字
>类型别名 :=> 数字
}

function f12(t: [Shape, boolean]) {
>f12 : (t: [Shape, 真假]) => 无值
>t : [Shape, 真假]
>Shape : Shape

    let len = getProperty(t, "length");
>len : 数字
>类型别名 :=> 数字
>getProperty(t, "length") : 数字
>类型别名 :=> 数字
>getProperty : <T, K 扩展 键集 T>(obj: T, key: K) => T[K]
>t : [Shape, 真假]
>"length" : "length"

    let s2 = getProperty(t, "0");  // Shape
>s2 : Shape
>getProperty(t, "0") : Shape
>getProperty : <T, K 扩展 键集 T>(obj: T, key: K) => T[K]
>t : [Shape, 真假]
>"0" : "0"

    let b2 = getProperty(t, "1");  // boolean
>b2 : 真假
>类型别名 :=> 真假
>getProperty(t, "1") : 真假
>类型别名 :=> 真假
>getProperty : <T, K 扩展 键集 T>(obj: T, key: K) => T[K]
>t : [Shape, 真假]
>"1" : "1"
}

function f13(foo: any, bar: any) {
>f13 : (foo: 任意, bar: 任意) => 无值
>foo : 任意
>类型别名 :=> 任意
>bar : 任意
>类型别名 :=> 任意

    let x = getProperty(foo, "x");  // any
>x : 任意
>类型别名 :=> 任意
>getProperty(foo, "x") : 任意
>类型别名 :=> 任意
>getProperty : <T, K 扩展 键集 T>(obj: T, key: K) => T[K]
>foo : 任意
>类型别名 :=> 任意
>"x" : "x"

    let y = getProperty(foo, "100");  // any
>y : 任意
>类型别名 :=> 任意
>getProperty(foo, "100") : 任意
>类型别名 :=> 任意
>getProperty : <T, K 扩展 键集 T>(obj: T, key: K) => T[K]
>foo : 任意
>类型别名 :=> 任意
>"100" : "100"

    let z = getProperty(foo, bar);  // any
>z : 任意
>类型别名 :=> 任意
>getProperty(foo, bar) : 任意
>类型别名 :=> 任意
>getProperty : <T, K 扩展 键集 T>(obj: T, key: K) => T[K]
>foo : 任意
>类型别名 :=> 任意
>bar : 任意
>类型别名 :=> 任意
}

class Component<PropType> {
>Component : Component<PropType>
>PropType : PropType

    props: PropType;
>props : PropType
>PropType : PropType

    getProperty<K extends keyof PropType>(key: K) {
>getProperty : <K 扩展 键集 PropType>(key: K) => PropType[K]
>K : K
>PropType : PropType
>key : K
>K : K

        return this.props[key];
>this.props[key] : PropType[K]
>this.props : PropType
>this : 本体
>props : PropType
>key : K
    }
    setProperty<K extends keyof PropType>(key: K, value: PropType[K]) {
>setProperty : <K 扩展 键集 PropType>(key: K, value: PropType[K]) => 无值
>K : K
>PropType : PropType
>key : K
>K : K
>value : PropType[K]
>PropType : PropType
>K : K

        this.props[key] = value;
>this.props[key] = value : PropType[K]
>this.props[key] : PropType[K]
>this.props : PropType
>this : 本体
>props : PropType
>key : K
>value : PropType[K]
    }
}

function f20(component: Component<Shape>) {
>f20 : (component: Component<Shape>) => 无值
>component : Component<Shape>
>Component : Component<PropType>
>Shape : Shape

    let name = component.getProperty("name");  // string
>name : 文字
>类型别名 :=> 文字
>component.getProperty("name") : 文字
>类型别名 :=> 文字
>component.getProperty : <K 扩展 "name" | "width" | "height" | "visible">(key: K) => Shape[K]
>component : Component<Shape>
>getProperty : <K 扩展 "name" | "width" | "height" | "visible">(key: K) => Shape[K]
>"name" : "name"

    let widthOrHeight = component.getProperty(cond ? "width" : "height");  // number
>widthOrHeight : 数字
>类型别名 :=> 数字
>component.getProperty(cond ? "width" : "height") : 数字
>类型别名 :=> 数字
>component.getProperty : <K 扩展 "name" | "width" | "height" | "visible">(key: K) => Shape[K]
>component : Component<Shape>
>getProperty : <K 扩展 "name" | "width" | "height" | "visible">(key: K) => Shape[K]
>cond ? "width" : "height" : "width" | "height"
>cond : 真假
>类型别名 :=> 真假
>"width" : "width"
>"height" : "height"

    let nameOrVisible = component.getProperty(cond ? "name" : "visible");  // string | boolean
>nameOrVisible : 文字 | 真假
>component.getProperty(cond ? "name" : "visible") : 文字 | 真假
>component.getProperty : <K 扩展 "name" | "width" | "height" | "visible">(key: K) => Shape[K]
>component : Component<Shape>
>getProperty : <K 扩展 "name" | "width" | "height" | "visible">(key: K) => Shape[K]
>cond ? "name" : "visible" : "name" | "visible"
>cond : 真假
>类型别名 :=> 真假
>"name" : "name"
>"visible" : "visible"

    component.setProperty("name", "rectangle");
>component.setProperty("name", "rectangle") : 无值
>类型别名 :=> 无值
>component.setProperty : <K 扩展 "name" | "width" | "height" | "visible">(key: K, value: Shape[K]) => 无值
>component : Component<Shape>
>setProperty : <K 扩展 "name" | "width" | "height" | "visible">(key: K, value: Shape[K]) => 无值
>"name" : "name"
>"rectangle" : "rectangle"

    component.setProperty(cond ? "width" : "height", 10)
>component.setProperty(cond ? "width" : "height", 10) : 无值
>类型别名 :=> 无值
>component.setProperty : <K 扩展 "name" | "width" | "height" | "visible">(key: K, value: Shape[K]) => 无值
>component : Component<Shape>
>setProperty : <K 扩展 "name" | "width" | "height" | "visible">(key: K, value: Shape[K]) => 无值
>cond ? "width" : "height" : "width" | "height"
>cond : 真假
>类型别名 :=> 真假
>"width" : "width"
>"height" : "height"
>10 : 10

    component.setProperty(cond ? "name" : "visible", true);  // Technically not safe
>component.setProperty(cond ? "name" : "visible", true) : 无值
>类型别名 :=> 无值
>component.setProperty : <K 扩展 "name" | "width" | "height" | "visible">(key: K, value: Shape[K]) => 无值
>component : Component<Shape>
>setProperty : <K 扩展 "name" | "width" | "height" | "visible">(key: K, value: Shape[K]) => 无值
>cond ? "name" : "visible" : "name" | "visible"
>cond : 真假
>类型别名 :=> 真假
>"name" : "name"
>"visible" : "visible"
>true : 为真
>类型别名 :=> 为真
}

function pluck<T, K extends keyof T>(array: T[], key: K) {
>pluck : <T, K 扩展 键集 T>(array: T[], key: K) => T[K][]
>T : T
>K : K
>T : T
>array : T[]
>T : T
>key : K
>K : K

    return array.map(x => x[key]);
>array.map(x => x[key]) : T[K][]
>array.map : <U>(callbackfn: (value: T, index: 数字, array: T[]) => U, thisArg?: 任意) => U[]
>array : T[]
>map : <U>(callbackfn: (value: T, index: 数字, array: T[]) => U, thisArg?: 任意) => U[]
>x => x[key] : (x: T) => T[K]
>x : T
>x[key] : T[K]
>x : T
>key : K
}

function f30(shapes: Shape[]) {
>f30 : (shapes: Shape[]) => 无值
>shapes : Shape[]
>Shape : Shape

    let names = pluck(shapes, "name");    // string[]
>names : 文字[]
>pluck(shapes, "name") : 文字[]
>pluck : <T, K 扩展 键集 T>(array: T[], key: K) => T[K][]
>shapes : Shape[]
>"name" : "name"

    let widths = pluck(shapes, "width");  // number[]
>widths : 数字[]
>pluck(shapes, "width") : 数字[]
>pluck : <T, K 扩展 键集 T>(array: T[], key: K) => T[K][]
>shapes : Shape[]
>"width" : "width"

    let nameOrVisibles = pluck(shapes, cond ? "name" : "visible");  // (string | boolean)[]
>nameOrVisibles : (文字 | 真假)[]
>pluck(shapes, cond ? "name" : "visible") : (文字 | 真假)[]
>pluck : <T, K 扩展 键集 T>(array: T[], key: K) => T[K][]
>shapes : Shape[]
>cond ? "name" : "visible" : "name" | "visible"
>cond : 真假
>类型别名 :=> 真假
>"name" : "name"
>"visible" : "visible"
}

function f31<K extends keyof Shape>(key: K) {
>f31 : <K 扩展 "name" | "width" | "height" | "visible">(key: K) => Shape[K]
>K : K
>Shape : Shape
>key : K
>K : K

    const shape: Shape = { name: "foo", width: 5, height: 10, visible: true };
>shape : Shape
>Shape : Shape
>{ name: "foo", width: 5, height: 10, visible: true } : { name: 文字; width: 数字; height: 数字; visible: 为真; }
>name : 文字
>类型别名 :=> 文字
>"foo" : "foo"
>width : 数字
>类型别名 :=> 数字
>5 : 5
>height : 数字
>类型别名 :=> 数字
>10 : 10
>visible : 真假
>类型别名 :=> 真假
>true : 为真
>类型别名 :=> 为真

    return shape[key];  // Shape[K]
>shape[key] : Shape[K]
>shape : Shape
>key : K
}

function f32<K extends "width" | "height">(key: K) {
>f32 : <K 扩展 "width" | "height">(key: K) => Shape[K]
>K : K
>key : K
>K : K

    const shape: Shape = { name: "foo", width: 5, height: 10, visible: true };
>shape : Shape
>Shape : Shape
>{ name: "foo", width: 5, height: 10, visible: true } : { name: 文字; width: 数字; height: 数字; visible: 为真; }
>name : 文字
>类型别名 :=> 文字
>"foo" : "foo"
>width : 数字
>类型别名 :=> 数字
>5 : 5
>height : 数字
>类型别名 :=> 数字
>10 : 10
>visible : 真假
>类型别名 :=> 真假
>true : 为真
>类型别名 :=> 为真

    return shape[key];  // Shape[K]
>shape[key] : Shape[K]
>shape : Shape
>key : K
}

function f33<S extends Shape, K extends keyof S>(shape: S, key: K) {
>f33 : <S 扩展 Shape, K 扩展 键集 S>(shape: S, key: K) => S[K]
>S : S
>Shape : Shape
>K : K
>S : S
>shape : S
>S : S
>key : K
>K : K

    let name = getProperty(shape, "name");
>name : S["name"]
>getProperty(shape, "name") : S["name"]
>getProperty : <T, K 扩展 键集 T>(obj: T, key: K) => T[K]
>shape : S
>"name" : "name"

    let prop = getProperty(shape, key);
>prop : S[K]
>getProperty(shape, key) : S[K]
>getProperty : <T, K 扩展 键集 T>(obj: T, key: K) => T[K]
>shape : S
>key : K

    return prop;
>prop : S[K]
}

function f34(ts: TaggedShape) {
>f34 : (ts: TaggedShape) => 无值
>ts : TaggedShape
>TaggedShape : TaggedShape

    let tag1 = f33(ts, "tag");
>tag1 : 文字
>类型别名 :=> 文字
>f33(ts, "tag") : 文字
>类型别名 :=> 文字
>f33 : <S 扩展 Shape, K 扩展 键集 S>(shape: S, key: K) => S[K]
>ts : TaggedShape
>"tag" : "tag"

    let tag2 = getProperty(ts, "tag");
>tag2 : 文字
>类型别名 :=> 文字
>getProperty(ts, "tag") : 文字
>类型别名 :=> 文字
>getProperty : <T, K 扩展 键集 T>(obj: T, key: K) => T[K]
>ts : TaggedShape
>"tag" : "tag"
}

class C {
>C : C

    public x: string;
>x : 文字
>类型别名 :=> 文字

    protected y: string;
>y : 文字
>类型别名 :=> 文字

    private z: string;
>z : 文字
>类型别名 :=> 文字
}

// Indexed access expressions have always permitted access to private and protected members.
// For consistency we also permit such access in indexed access types.
function f40(c: C) {
>f40 : (c: C) => 无值
>c : C
>C : C

    type X = C["x"];
>X : 文字
>类型别名 :=> 文字
>C : C

    type Y = C["y"];
>Y : 文字
>类型别名 :=> 文字
>C : C

    type Z = C["z"];
>Z : 文字
>类型别名 :=> 文字
>C : C

    let x: X = c["x"];
>x : 文字
>类型别名 :=> 文字
>X : 文字
>类型别名 :=> 文字
>c["x"] : 文字
>类型别名 :=> 文字
>c : C
>"x" : "x"

    let y: Y = c["y"];
>y : 文字
>类型别名 :=> 文字
>Y : 文字
>类型别名 :=> 文字
>c["y"] : 文字
>类型别名 :=> 文字
>c : C
>"y" : "y"

    let z: Z = c["z"];
>z : 文字
>类型别名 :=> 文字
>Z : 文字
>类型别名 :=> 文字
>c["z"] : 文字
>类型别名 :=> 文字
>c : C
>"z" : "z"
}

function f50<T>(k: keyof T, s: string) {
>f50 : <T>(k: 键集 T, s: 文字) => 无值
>T : T
>k : 键集 T
>T : T
>s : 文字
>类型别名 :=> 文字

    const x1 = s as keyof T;
>x1 : 键集 T
>s as keyof T : 键集 T
>s : 文字
>类型别名 :=> 文字
>T : T

    const x2 = k as string;
>x2 : 文字
>类型别名 :=> 文字
>k as string : 文字
>类型别名 :=> 文字
>k : 键集 T
}

function f51<T, K extends keyof T>(k: K, s: string) {
>f51 : <T, K 扩展 键集 T>(k: K, s: 文字) => 无值
>T : T
>K : K
>T : T
>k : K
>K : K
>s : 文字
>类型别名 :=> 文字

    const x1 = s as keyof T;
>x1 : 键集 T
>s as keyof T : 键集 T
>s : 文字
>类型别名 :=> 文字
>T : T

    const x2 = k as string;
>x2 : 文字
>类型别名 :=> 文字
>k as string : 文字
>类型别名 :=> 文字
>k : K
}

function f52<T>(obj: { [x: string]: boolean }, k: keyof T, s: string, n: number) {
>f52 : <T>(obj: { [x: 文字]: 真假; }, k: 键集 T, s: 文字, n: 数字) => 无值
>T : T
>obj : { [x: 文字]: 真假; }
>x : 文字
>类型别名 :=> 文字
>k : 键集 T
>T : T
>s : 文字
>类型别名 :=> 文字
>n : 数字
>类型别名 :=> 数字

    const x1 = obj[s];
>x1 : 真假
>类型别名 :=> 真假
>obj[s] : 真假
>类型别名 :=> 真假
>obj : { [x: 文字]: 真假; }
>s : 文字
>类型别名 :=> 文字

    const x2 = obj[n];
>x2 : 真假
>类型别名 :=> 真假
>obj[n] : 真假
>类型别名 :=> 真假
>obj : { [x: 文字]: 真假; }
>n : 数字
>类型别名 :=> 数字

    const x3 = obj[k];
>x3 : { [x: 文字]: 真假; }[键集 T]
>obj[k] : { [x: 文字]: 真假; }[键集 T]
>obj : { [x: 文字]: 真假; }
>k : 键集 T
}

function f53<T, K extends keyof T>(obj: { [x: string]: boolean }, k: K, s: string, n: number) {
>f53 : <T, K 扩展 键集 T>(obj: { [x: 文字]: 真假; }, k: K, s: 文字, n: 数字) => 无值
>T : T
>K : K
>T : T
>obj : { [x: 文字]: 真假; }
>x : 文字
>类型别名 :=> 文字
>k : K
>K : K
>s : 文字
>类型别名 :=> 文字
>n : 数字
>类型别名 :=> 数字

    const x1 = obj[s];
>x1 : 真假
>类型别名 :=> 真假
>obj[s] : 真假
>类型别名 :=> 真假
>obj : { [x: 文字]: 真假; }
>s : 文字
>类型别名 :=> 文字

    const x2 = obj[n];
>x2 : 真假
>类型别名 :=> 真假
>obj[n] : 真假
>类型别名 :=> 真假
>obj : { [x: 文字]: 真假; }
>n : 数字
>类型别名 :=> 数字

    const x3 = obj[k];
>x3 : { [x: 文字]: 真假; }[K]
>obj[k] : { [x: 文字]: 真假; }[K]
>obj : { [x: 文字]: 真假; }
>k : K
}

function f54<T>(obj: T, key: keyof T) {
>f54 : <T>(obj: T, key: 键集 T) => 无值
>T : T
>obj : T
>T : T
>key : 键集 T
>T : T

    for (let s in obj[key]) {
>s : 键集 T[键集 T]
>obj[key] : T[键集 T]
>obj : T
>key : 键集 T
    }
    const b = "foo" in obj[key];
>b : 真假
>类型别名 :=> 真假
>"foo" in obj[key] : 真假
>类型别名 :=> 真假
>"foo" : "foo"
>obj[key] : T[键集 T]
>obj : T
>key : 键集 T
}

function f55<T, K extends keyof T>(obj: T, key: K) {
>f55 : <T, K 扩展 键集 T>(obj: T, key: K) => 无值
>T : T
>K : K
>T : T
>obj : T
>T : T
>key : K
>K : K

    for (let s in obj[key]) {
>s : 键集 T[K]
>obj[key] : T[K]
>obj : T
>key : K
    }
    const b = "foo" in obj[key];
>b : 真假
>类型别名 :=> 真假
>"foo" in obj[key] : 真假
>类型别名 :=> 真假
>"foo" : "foo"
>obj[key] : T[K]
>obj : T
>key : K
}

function f60<T>(source: T, target: T) {
>f60 : <T>(source: T, target: T) => 无值
>T : T
>source : T
>T : T
>target : T
>T : T

    for (let k in source) {
>k : 键集 T
>source : T

        target[k] = source[k];
>target[k] = source[k] : T[键集 T]
>target[k] : T[键集 T]
>target : T
>k : 键集 T
>source[k] : T[键集 T]
>source : T
>k : 键集 T
    }
}

function f70(func: <T, U>(k1: keyof (T | U), k2: keyof (T & U)) => void) {
>f70 : (func: <T, U>(k1: 键集 (T | U), k2: 键集 (T & U)) => 无值) => 无值
>func : <T, U>(k1: 键集 (T | U), k2: 键集 (T & U)) => 无值
>T : T
>U : U
>k1 : 键集 (T | U)
>T : T
>U : U
>k2 : 键集 (T & U)
>T : T
>U : U

    func<{ a: any, b: any }, { a: any, c: any }>('a', 'a');
>func<{ a: any, b: any }, { a: any, c: any }>('a', 'a') : 无值
>类型别名 :=> 无值
>func : <T, U>(k1: 键集 (T | U), k2: 键集 (T & U)) => 无值
>a : 任意
>类型别名 :=> 任意
>b : 任意
>类型别名 :=> 任意
>a : 任意
>类型别名 :=> 任意
>c : 任意
>类型别名 :=> 任意
>'a' : "a"
>'a' : "a"

    func<{ a: any, b: any }, { a: any, c: any }>('a', 'b');
>func<{ a: any, b: any }, { a: any, c: any }>('a', 'b') : 无值
>类型别名 :=> 无值
>func : <T, U>(k1: 键集 (T | U), k2: 键集 (T & U)) => 无值
>a : 任意
>类型别名 :=> 任意
>b : 任意
>类型别名 :=> 任意
>a : 任意
>类型别名 :=> 任意
>c : 任意
>类型别名 :=> 任意
>'a' : "a"
>'b' : "b"

    func<{ a: any, b: any }, { a: any, c: any }>('a', 'c');
>func<{ a: any, b: any }, { a: any, c: any }>('a', 'c') : 无值
>类型别名 :=> 无值
>func : <T, U>(k1: 键集 (T | U), k2: 键集 (T & U)) => 无值
>a : 任意
>类型别名 :=> 任意
>b : 任意
>类型别名 :=> 任意
>a : 任意
>类型别名 :=> 任意
>c : 任意
>类型别名 :=> 任意
>'a' : "a"
>'c' : "c"
}

function f71(func: <T, U>(x: T, y: U) => Partial<T & U>) {
>f71 : (func: <T, U>(x: T, y: U) => Partial<T & U>) => 无值
>func : <T, U>(x: T, y: U) => Partial<T & U>
>T : T
>U : U
>x : T
>T : T
>y : U
>U : U
>Partial : Partial<T>
>T : T
>U : U

    let x = func({ a: 1, b: "hello" }, { c: true });
>x : Partial<{ a: 数字; b: 文字; } & { c: 真假; }>
>func({ a: 1, b: "hello" }, { c: true }) : Partial<{ a: 数字; b: 文字; } & { c: 真假; }>
>func : <T, U>(x: T, y: U) => Partial<T & U>
>{ a: 1, b: "hello" } : { a: 数字; b: 文字; }
>a : 数字
>类型别名 :=> 数字
>1 : 1
>b : 文字
>类型别名 :=> 文字
>"hello" : "hello"
>{ c: true } : { c: 为真; }
>c : 真假
>类型别名 :=> 真假
>true : 为真
>类型别名 :=> 为真

    x.a;  // number | undefined
>x.a : 数字 | 未定
>x : Partial<{ a: 数字; b: 文字; } & { c: 真假; }>
>a : 数字 | 未定

    x.b;  // string | undefined
>x.b : 文字 | 未定
>x : Partial<{ a: 数字; b: 文字; } & { c: 真假; }>
>b : 文字 | 未定

    x.c;  // boolean | undefined
>x.c : 真假 | 未定
>x : Partial<{ a: 数字; b: 文字; } & { c: 真假; }>
>c : 真假 | 未定
}

function f72(func: <T, U, K extends keyof T | keyof U>(x: T, y: U, k: K) => (T & U)[K]) {
>f72 : (func: <T, U, K 扩展 键集 T | 键集 U>(x: T, y: U, k: K) => (T & U)[K]) => 无值
>func : <T, U, K 扩展 键集 T | 键集 U>(x: T, y: U, k: K) => (T & U)[K]
>T : T
>U : U
>K : K
>T : T
>U : U
>x : T
>T : T
>y : U
>U : U
>k : K
>K : K
>T : T
>U : U
>K : K

    let a = func({ a: 1, b: "hello" }, { c: true }, 'a');  // number
>a : 数字
>类型别名 :=> 数字
>func({ a: 1, b: "hello" }, { c: true }, 'a') : 数字
>类型别名 :=> 数字
>func : <T, U, K 扩展 键集 T | 键集 U>(x: T, y: U, k: K) => (T & U)[K]
>{ a: 1, b: "hello" } : { a: 数字; b: 文字; }
>a : 数字
>类型别名 :=> 数字
>1 : 1
>b : 文字
>类型别名 :=> 文字
>"hello" : "hello"
>{ c: true } : { c: 为真; }
>c : 真假
>类型别名 :=> 真假
>true : 为真
>类型别名 :=> 为真
>'a' : "a"

    let b = func({ a: 1, b: "hello" }, { c: true }, 'b');  // string
>b : 文字
>类型别名 :=> 文字
>func({ a: 1, b: "hello" }, { c: true }, 'b') : 文字
>类型别名 :=> 文字
>func : <T, U, K 扩展 键集 T | 键集 U>(x: T, y: U, k: K) => (T & U)[K]
>{ a: 1, b: "hello" } : { a: 数字; b: 文字; }
>a : 数字
>类型别名 :=> 数字
>1 : 1
>b : 文字
>类型别名 :=> 文字
>"hello" : "hello"
>{ c: true } : { c: 为真; }
>c : 真假
>类型别名 :=> 真假
>true : 为真
>类型别名 :=> 为真
>'b' : "b"

    let c = func({ a: 1, b: "hello" }, { c: true }, 'c');  // boolean
>c : 真假
>类型别名 :=> 真假
>func({ a: 1, b: "hello" }, { c: true }, 'c') : 真假
>类型别名 :=> 真假
>func : <T, U, K 扩展 键集 T | 键集 U>(x: T, y: U, k: K) => (T & U)[K]
>{ a: 1, b: "hello" } : { a: 数字; b: 文字; }
>a : 数字
>类型别名 :=> 数字
>1 : 1
>b : 文字
>类型别名 :=> 文字
>"hello" : "hello"
>{ c: true } : { c: 为真; }
>c : 真假
>类型别名 :=> 真假
>true : 为真
>类型别名 :=> 为真
>'c' : "c"
}

function f73(func: <T, U, K extends keyof (T & U)>(x: T, y: U, k: K) => (T & U)[K]) {
>f73 : (func: <T, U, K 扩展 键集 (T & U)>(x: T, y: U, k: K) => (T & U)[K]) => 无值
>func : <T, U, K 扩展 键集 (T & U)>(x: T, y: U, k: K) => (T & U)[K]
>T : T
>U : U
>K : K
>T : T
>U : U
>x : T
>T : T
>y : U
>U : U
>k : K
>K : K
>T : T
>U : U
>K : K

    let a = func({ a: 1, b: "hello" }, { c: true }, 'a');  // number
>a : 数字
>类型别名 :=> 数字
>func({ a: 1, b: "hello" }, { c: true }, 'a') : 数字
>类型别名 :=> 数字
>func : <T, U, K 扩展 键集 (T & U)>(x: T, y: U, k: K) => (T & U)[K]
>{ a: 1, b: "hello" } : { a: 数字; b: 文字; }
>a : 数字
>类型别名 :=> 数字
>1 : 1
>b : 文字
>类型别名 :=> 文字
>"hello" : "hello"
>{ c: true } : { c: 为真; }
>c : 真假
>类型别名 :=> 真假
>true : 为真
>类型别名 :=> 为真
>'a' : "a"

    let b = func({ a: 1, b: "hello" }, { c: true }, 'b');  // string
>b : 文字
>类型别名 :=> 文字
>func({ a: 1, b: "hello" }, { c: true }, 'b') : 文字
>类型别名 :=> 文字
>func : <T, U, K 扩展 键集 (T & U)>(x: T, y: U, k: K) => (T & U)[K]
>{ a: 1, b: "hello" } : { a: 数字; b: 文字; }
>a : 数字
>类型别名 :=> 数字
>1 : 1
>b : 文字
>类型别名 :=> 文字
>"hello" : "hello"
>{ c: true } : { c: 为真; }
>c : 真假
>类型别名 :=> 真假
>true : 为真
>类型别名 :=> 为真
>'b' : "b"

    let c = func({ a: 1, b: "hello" }, { c: true }, 'c');  // boolean
>c : 真假
>类型别名 :=> 真假
>func({ a: 1, b: "hello" }, { c: true }, 'c') : 真假
>类型别名 :=> 真假
>func : <T, U, K 扩展 键集 (T & U)>(x: T, y: U, k: K) => (T & U)[K]
>{ a: 1, b: "hello" } : { a: 数字; b: 文字; }
>a : 数字
>类型别名 :=> 数字
>1 : 1
>b : 文字
>类型别名 :=> 文字
>"hello" : "hello"
>{ c: true } : { c: 为真; }
>c : 真假
>类型别名 :=> 真假
>true : 为真
>类型别名 :=> 为真
>'c' : "c"
}

function f74(func: <T, U, K extends keyof (T | U)>(x: T, y: U, k: K) => (T | U)[K]) {
>f74 : (func: <T, U, K 扩展 键集 (T | U)>(x: T, y: U, k: K) => (T | U)[K]) => 无值
>func : <T, U, K 扩展 键集 (T | U)>(x: T, y: U, k: K) => (T | U)[K]
>T : T
>U : U
>K : K
>T : T
>U : U
>x : T
>T : T
>y : U
>U : U
>k : K
>K : K
>T : T
>U : U
>K : K

    let a = func({ a: 1, b: "hello" }, { a: 2, b: true }, 'a');  // number
>a : 数字
>类型别名 :=> 数字
>func({ a: 1, b: "hello" }, { a: 2, b: true }, 'a') : 数字
>类型别名 :=> 数字
>func : <T, U, K 扩展 键集 (T | U)>(x: T, y: U, k: K) => (T | U)[K]
>{ a: 1, b: "hello" } : { a: 数字; b: 文字; }
>a : 数字
>类型别名 :=> 数字
>1 : 1
>b : 文字
>类型别名 :=> 文字
>"hello" : "hello"
>{ a: 2, b: true } : { a: 数字; b: 为真; }
>a : 数字
>类型别名 :=> 数字
>2 : 2
>b : 真假
>类型别名 :=> 真假
>true : 为真
>类型别名 :=> 为真
>'a' : "a"

    let b = func({ a: 1, b: "hello" }, { a: 2, b: true }, 'b');  // string | boolean
>b : 文字 | 真假
>func({ a: 1, b: "hello" }, { a: 2, b: true }, 'b') : 文字 | 真假
>func : <T, U, K 扩展 键集 (T | U)>(x: T, y: U, k: K) => (T | U)[K]
>{ a: 1, b: "hello" } : { a: 数字; b: 文字; }
>a : 数字
>类型别名 :=> 数字
>1 : 1
>b : 文字
>类型别名 :=> 文字
>"hello" : "hello"
>{ a: 2, b: true } : { a: 数字; b: 为真; }
>a : 数字
>类型别名 :=> 数字
>2 : 2
>b : 真假
>类型别名 :=> 真假
>true : 为真
>类型别名 :=> 为真
>'b' : "b"
}

function f80<T extends { a: { x: any } }>(obj: T) {
>f80 : <T 扩展 { a: { x: 任意; }; }>(obj: T) => 无值
>T : T
>a : { x: 任意; }
>x : 任意
>类型别名 :=> 任意
>obj : T
>T : T

    let a1 = obj.a;  // { x: any }
>a1 : { x: 任意; }
>obj.a : { x: 任意; }
>obj : T
>a : { x: 任意; }

    let a2 = obj['a'];  // { x: any }
>a2 : { x: 任意; }
>obj['a'] : { x: 任意; }
>obj : T
>'a' : "a"

    let a3 = obj['a'] as T['a'];  // T["a"]
>a3 : T["a"]
>obj['a'] as T['a'] : T["a"]
>obj['a'] : { x: 任意; }
>obj : T
>'a' : "a"
>T : T

    let x1 = obj.a.x;  // any
>x1 : 任意
>类型别名 :=> 任意
>obj.a.x : 任意
>类型别名 :=> 任意
>obj.a : { x: 任意; }
>obj : T
>a : { x: 任意; }
>x : 任意
>类型别名 :=> 任意

    let x2 = obj['a']['x'];  // any
>x2 : 任意
>类型别名 :=> 任意
>obj['a']['x'] : 任意
>类型别名 :=> 任意
>obj['a'] : { x: 任意; }
>obj : T
>'a' : "a"
>'x' : "x"

    let x3 = obj['a']['x'] as T['a']['x'];  // T["a"]["x"]
>x3 : T["a"]["x"]
>obj['a']['x'] as T['a']['x'] : T["a"]["x"]
>obj['a']['x'] : 任意
>类型别名 :=> 任意
>obj['a'] : { x: 任意; }
>obj : T
>'a' : "a"
>'x' : "x"
>T : T
}

function f81<T extends { a: { x: any } }>(obj: T) {
>f81 : <T 扩展 { a: { x: 任意; }; }>(obj: T) => T["a"]["x"]
>T : T
>a : { x: 任意; }
>x : 任意
>类型别名 :=> 任意
>obj : T
>T : T

    return obj['a']['x'] as T['a']['x'];
>obj['a']['x'] as T['a']['x'] : T["a"]["x"]
>obj['a']['x'] : 任意
>类型别名 :=> 任意
>obj['a'] : { x: 任意; }
>obj : T
>'a' : "a"
>'x' : "x"
>T : T
}

function f82() {
>f82 : () => 无值

    let x1 = f81({ a: { x: "hello" } });  // string
>x1 : 文字
>类型别名 :=> 文字
>f81({ a: { x: "hello" } }) : 文字
>类型别名 :=> 文字
>f81 : <T 扩展 { a: { x: 任意; }; }>(obj: T) => T["a"]["x"]
>{ a: { x: "hello" } } : { a: { x: 文字; }; }
>a : { x: 文字; }
>{ x: "hello" } : { x: 文字; }
>x : 文字
>类型别名 :=> 文字
>"hello" : "hello"

    let x2 = f81({ a: { x: 42 } });  // number
>x2 : 数字
>类型别名 :=> 数字
>f81({ a: { x: 42 } }) : 数字
>类型别名 :=> 数字
>f81 : <T 扩展 { a: { x: 任意; }; }>(obj: T) => T["a"]["x"]
>{ a: { x: 42 } } : { a: { x: 数字; }; }
>a : { x: 数字; }
>{ x: 42 } : { x: 数字; }
>x : 数字
>类型别名 :=> 数字
>42 : 42
}

function f83<T extends { [x: string]: { x: any } }, K extends keyof T>(obj: T, key: K) {
>f83 : <T 扩展 { [x: 文字]: { x: 任意; }; }, K 扩展 键集 T>(obj: T, key: K) => T[K]["x"]
>T : T
>x : 文字
>类型别名 :=> 文字
>x : 任意
>类型别名 :=> 任意
>K : K
>T : T
>obj : T
>T : T
>key : K
>K : K

    return obj[key]['x'] as T[K]['x'];
>obj[key]['x'] as T[K]['x'] : T[K]["x"]
>obj[key]['x'] : 任意
>类型别名 :=> 任意
>obj[key] : T[K]
>obj : T
>key : K
>'x' : "x"
>T : T
>K : K
}

function f84() {
>f84 : () => 无值

    let x1 = f83({ foo: { x: "hello" } }, "foo");  // string
>x1 : 文字
>类型别名 :=> 文字
>f83({ foo: { x: "hello" } }, "foo") : 文字
>类型别名 :=> 文字
>f83 : <T 扩展 { [x: 文字]: { x: 任意; }; }, K 扩展 键集 T>(obj: T, key: K) => T[K]["x"]
>{ foo: { x: "hello" } } : { foo: { x: 文字; }; }
>foo : { x: 文字; }
>{ x: "hello" } : { x: 文字; }
>x : 文字
>类型别名 :=> 文字
>"hello" : "hello"
>"foo" : "foo"

    let x2 = f83({ bar: { x: 42 } }, "bar");  // number
>x2 : 数字
>类型别名 :=> 数字
>f83({ bar: { x: 42 } }, "bar") : 数字
>类型别名 :=> 数字
>f83 : <T 扩展 { [x: 文字]: { x: 任意; }; }, K 扩展 键集 T>(obj: T, key: K) => T[K]["x"]
>{ bar: { x: 42 } } : { bar: { x: 数字; }; }
>bar : { x: 数字; }
>{ x: 42 } : { x: 数字; }
>x : 数字
>类型别名 :=> 数字
>42 : 42
>"bar" : "bar"
}

class C1 {
>C1 : C1

    x: number;
>x : 数字
>类型别名 :=> 数字

    get<K extends keyof this>(key: K) {
>get : <K 扩展 键集 本体>(key: K) => 本体[K]
>K : K
>key : K
>K : K

        return this[key];
>this[key] : 本体[K]
>this : 本体
>key : K
    }
    set<K extends keyof this>(key: K, value: this[K]) {
>set : <K 扩展 键集 本体>(key: K, value: 本体[K]) => 无值
>K : K
>key : K
>K : K
>value : 本体[K]
>K : K

        this[key] = value;
>this[key] = value : 本体[K]
>this[key] : 本体[K]
>this : 本体
>key : K
>value : 本体[K]
    }
    foo() {
>foo : () => 无值

        let x1 = this.x;  // number
>x1 : 数字
>类型别名 :=> 数字
>this.x : 数字
>类型别名 :=> 数字
>this : 本体
>x : 数字
>类型别名 :=> 数字

        let x2 = this["x"];  // number
>x2 : 数字
>类型别名 :=> 数字
>this["x"] : 数字
>类型别名 :=> 数字
>this : 本体
>"x" : "x"

        let x3 = this.get("x");  // this["x"]
>x3 : 本体["x"]
>this.get("x") : 本体["x"]
>this.get : <K 扩展 键集 本体>(key: K) => 本体[K]
>this : 本体
>get : <K 扩展 键集 本体>(key: K) => 本体[K]
>"x" : "x"

        let x4 = getProperty(this, "x"); // this["x"]
>x4 : 本体["x"]
>getProperty(this, "x") : 本体["x"]
>getProperty : <T, K 扩展 键集 T>(obj: T, key: K) => T[K]
>this : 本体
>"x" : "x"

        this.x = 42;
>this.x = 42 : 42
>this.x : 数字
>类型别名 :=> 数字
>this : 本体
>x : 数字
>类型别名 :=> 数字
>42 : 42

        this["x"] = 42;
>this["x"] = 42 : 42
>this["x"] : 数字
>类型别名 :=> 数字
>this : 本体
>"x" : "x"
>42 : 42

        this.set("x", 42);
>this.set("x", 42) : 无值
>类型别名 :=> 无值
>this.set : <K 扩展 键集 本体>(key: K, value: 本体[K]) => 无值
>this : 本体
>set : <K 扩展 键集 本体>(key: K, value: 本体[K]) => 无值
>"x" : "x"
>42 : 42

        setProperty(this, "x", 42);
>setProperty(this, "x", 42) : 无值
>类型别名 :=> 无值
>setProperty : <T, K 扩展 键集 T>(obj: T, key: K, value: T[K]) => 无值
>this : 本体
>"x" : "x"
>42 : 42
    }
}

type S2 = {
>S2 : S2

    a: string;
>a : 文字
>类型别名 :=> 文字

    b: string;
>b : 文字
>类型别名 :=> 文字

};

function f90<T extends S2, K extends keyof S2>(x1: S2[keyof S2], x2: T[keyof S2], x3: S2[K], x4: T[K]) {
>f90 : <T 扩展 S2, K 扩展 "a" | "b">(x1: 文字, x2: T["a" | "b"], x3: S2[K], x4: T[K]) => 无值
>T : T
>S2 : S2
>K : K
>S2 : S2
>x1 : 文字
>类型别名 :=> 文字
>S2 : S2
>S2 : S2
>x2 : T["a" | "b"]
>T : T
>S2 : S2
>x3 : S2[K]
>S2 : S2
>K : K
>x4 : T[K]
>T : T
>K : K

    x1 = x2;
>x1 = x2 : T["a" | "b"]
>x1 : 文字
>类型别名 :=> 文字
>x2 : T["a" | "b"]

    x1 = x3;
>x1 = x3 : S2[K]
>x1 : 文字
>类型别名 :=> 文字
>x3 : S2[K]

    x1 = x4;
>x1 = x4 : T[K]
>x1 : 文字
>类型别名 :=> 文字
>x4 : T[K]

    x2 = x1;
>x2 = x1 : 文字
>类型别名 :=> 文字
>x2 : T["a" | "b"]
>x1 : 文字
>类型别名 :=> 文字

    x2 = x3;
>x2 = x3 : S2[K]
>x2 : T["a" | "b"]
>x3 : S2[K]

    x2 = x4;
>x2 = x4 : T[K]
>x2 : T["a" | "b"]
>x4 : T[K]

    x3 = x1;
>x3 = x1 : 文字
>类型别名 :=> 文字
>x3 : S2[K]
>x1 : 文字
>类型别名 :=> 文字

    x3 = x2;
>x3 = x2 : T["a" | "b"]
>x3 : S2[K]
>x2 : T["a" | "b"]

    x3 = x4;
>x3 = x4 : T[K]
>x3 : S2[K]
>x4 : T[K]

    x4 = x1;
>x4 = x1 : 文字
>类型别名 :=> 文字
>x4 : T[K]
>x1 : 文字
>类型别名 :=> 文字

    x4 = x2;
>x4 = x2 : T["a" | "b"]
>x4 : T[K]
>x2 : T["a" | "b"]

    x4 = x3;
>x4 = x3 : S2[K]
>x4 : T[K]
>x3 : S2[K]

    x1.length;
>x1.length : 数字
>类型别名 :=> 数字
>x1 : 文字
>类型别名 :=> 文字
>length : 数字
>类型别名 :=> 数字

    x2.length;
>x2.length : 数字
>类型别名 :=> 数字
>x2 : T["a" | "b"]
>length : 数字
>类型别名 :=> 数字

    x3.length;
>x3.length : 数字
>类型别名 :=> 数字
>x3 : S2[K]
>length : 数字
>类型别名 :=> 数字

    x4.length;
>x4.length : 数字
>类型别名 :=> 数字
>x4 : T[K]
>length : 数字
>类型别名 :=> 数字
}

// Repros from #12011

class Base {
>Base : Base

    get<K extends keyof this>(prop: K) {
>get : <K 扩展 键集 本体>(prop: K) => 本体[K]
>K : K
>prop : K
>K : K

        return this[prop];
>this[prop] : 本体[K]
>this : 本体
>prop : K
    }
    set<K extends keyof this>(prop: K, value: this[K]) {
>set : <K 扩展 键集 本体>(prop: K, value: 本体[K]) => 无值
>K : K
>prop : K
>K : K
>value : 本体[K]
>K : K

        this[prop] = value;
>this[prop] = value : 本体[K]
>this[prop] : 本体[K]
>this : 本体
>prop : K
>value : 本体[K]
    }
}

class Person extends Base {
>Person : Person
>Base : Base

    parts: number;
>parts : 数字
>类型别名 :=> 数字

    constructor(parts: number) {
>parts : 数字
>类型别名 :=> 数字

        super();
>super() : 无值
>类型别名 :=> 无值
>super : 类为 Base

        this.set("parts", parts);
>this.set("parts", parts) : 无值
>类型别名 :=> 无值
>this.set : <K 扩展 键集 本体>(prop: K, value: 本体[K]) => 无值
>this : 本体
>set : <K 扩展 键集 本体>(prop: K, value: 本体[K]) => 无值
>"parts" : "parts"
>parts : 数字
>类型别名 :=> 数字
    }
    getParts() {
>getParts : () => 本体["parts"]

        return this.get("parts")
>this.get("parts") : 本体["parts"]
>this.get : <K 扩展 键集 本体>(prop: K) => 本体[K]
>this : 本体
>get : <K 扩展 键集 本体>(prop: K) => 本体[K]
>"parts" : "parts"
    }
}

class OtherPerson {
>OtherPerson : OtherPerson

    parts: number;
>parts : 数字
>类型别名 :=> 数字

    constructor(parts: number) {
>parts : 数字
>类型别名 :=> 数字

        setProperty(this, "parts", parts);
>setProperty(this, "parts", parts) : 无值
>类型别名 :=> 无值
>setProperty : <T, K 扩展 键集 T>(obj: T, key: K, value: T[K]) => 无值
>this : 本体
>"parts" : "parts"
>parts : 数字
>类型别名 :=> 数字
    }
    getParts() {
>getParts : () => 本体["parts"]

        return getProperty(this, "parts")
>getProperty(this, "parts") : 本体["parts"]
>getProperty : <T, K 扩展 键集 T>(obj: T, key: K) => T[K]
>this : 本体
>"parts" : "parts"
    }
}

// Modified repro from #12544

function path<T, K1 extends keyof T>(obj: T, key1: K1): T[K1];
>path : { <T, K1 扩展 键集 T>(obj: T, key1: K1): T[K1]; <T, K1 扩展 键集 T, K2 扩展 键集 T[K1]>(obj: T, key1: K1, key2: K2): T[K1][K2]; <T, K1 扩展 键集 T, K2 扩展 键集 T[K1], K3 扩展 键集 T[K1][K2]>(obj: T, key1: K1, key2: K2, key3: K3): T[K1][K2][K3]; (obj: 任意, ...keys: (文字 | 数字)[]): 任意; }
>T : T
>K1 : K1
>T : T
>obj : T
>T : T
>key1 : K1
>K1 : K1
>T : T
>K1 : K1

function path<T, K1 extends keyof T, K2 extends keyof T[K1]>(obj: T, key1: K1, key2: K2): T[K1][K2];
>path : { <T, K1 扩展 键集 T>(obj: T, key1: K1): T[K1]; <T, K1 扩展 键集 T, K2 扩展 键集 T[K1]>(obj: T, key1: K1, key2: K2): T[K1][K2]; <T, K1 扩展 键集 T, K2 扩展 键集 T[K1], K3 扩展 键集 T[K1][K2]>(obj: T, key1: K1, key2: K2, key3: K3): T[K1][K2][K3]; (obj: 任意, ...keys: (文字 | 数字)[]): 任意; }
>T : T
>K1 : K1
>T : T
>K2 : K2
>T : T
>K1 : K1
>obj : T
>T : T
>key1 : K1
>K1 : K1
>key2 : K2
>K2 : K2
>T : T
>K1 : K1
>K2 : K2

function path<T, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2]>(obj: T, key1: K1, key2: K2, key3: K3): T[K1][K2][K3];
>path : { <T, K1 扩展 键集 T>(obj: T, key1: K1): T[K1]; <T, K1 扩展 键集 T, K2 扩展 键集 T[K1]>(obj: T, key1: K1, key2: K2): T[K1][K2]; <T, K1 扩展 键集 T, K2 扩展 键集 T[K1], K3 扩展 键集 T[K1][K2]>(obj: T, key1: K1, key2: K2, key3: K3): T[K1][K2][K3]; (obj: 任意, ...keys: (文字 | 数字)[]): 任意; }
>T : T
>K1 : K1
>T : T
>K2 : K2
>T : T
>K1 : K1
>K3 : K3
>T : T
>K1 : K1
>K2 : K2
>obj : T
>T : T
>key1 : K1
>K1 : K1
>key2 : K2
>K2 : K2
>key3 : K3
>K3 : K3
>T : T
>K1 : K1
>K2 : K2
>K3 : K3

function path(obj: any, ...keys: (string | number)[]): any;
>path : { <T, K1 扩展 键集 T>(obj: T, key1: K1): T[K1]; <T, K1 扩展 键集 T, K2 扩展 键集 T[K1]>(obj: T, key1: K1, key2: K2): T[K1][K2]; <T, K1 扩展 键集 T, K2 扩展 键集 T[K1], K3 扩展 键集 T[K1][K2]>(obj: T, key1: K1, key2: K2, key3: K3): T[K1][K2][K3]; (obj: 任意, ...keys: (文字 | 数字)[]): 任意; }
>obj : 任意
>类型别名 :=> 任意
>keys : (文字 | 数字)[]

function path(obj: any, ...keys: (string | number)[]): any {
>path : { <T, K1 扩展 键集 T>(obj: T, key1: K1): T[K1]; <T, K1 扩展 键集 T, K2 扩展 键集 T[K1]>(obj: T, key1: K1, key2: K2): T[K1][K2]; <T, K1 扩展 键集 T, K2 扩展 键集 T[K1], K3 扩展 键集 T[K1][K2]>(obj: T, key1: K1, key2: K2, key3: K3): T[K1][K2][K3]; (obj: 任意, ...keys: (文字 | 数字)[]): 任意; }
>obj : 任意
>类型别名 :=> 任意
>keys : (文字 | 数字)[]

    let result = obj;
>result : 任意
>类型别名 :=> 任意
>obj : 任意
>类型别名 :=> 任意

    for (let k of keys) {
>k : 文字 | 数字
>keys : (文字 | 数字)[]

        result = result[k];
>result = result[k] : 任意
>类型别名 :=> 任意
>result : 任意
>类型别名 :=> 任意
>result[k] : 任意
>类型别名 :=> 任意
>result : 任意
>类型别名 :=> 任意
>k : 文字 | 数字
    }
    return result;
>result : 任意
>类型别名 :=> 任意
}

type Thing = {
>Thing : Thing

    a: { x: number, y: string },
>a : { x: 数字; y: 文字; }
>x : 数字
>类型别名 :=> 数字
>y : 文字
>类型别名 :=> 文字

    b: boolean
>b : 真假
>类型别名 :=> 真假

};


function f1(thing: Thing) {
>f1 : (thing: Thing) => 无值
>thing : Thing
>Thing : Thing

    let x1 = path(thing, 'a');  // { x: number, y: string }
>x1 : { x: 数字; y: 文字; }
>path(thing, 'a') : { x: 数字; y: 文字; }
>path : { <T, K1 扩展 键集 T>(obj: T, key1: K1): T[K1]; <T, K1 扩展 键集 T, K2 扩展 键集 T[K1]>(obj: T, key1: K1, key2: K2): T[K1][K2]; <T, K1 扩展 键集 T, K2 扩展 键集 T[K1], K3 扩展 键集 T[K1][K2]>(obj: T, key1: K1, key2: K2, key3: K3): T[K1][K2][K3]; (obj: 任意, ...keys: (文字 | 数字)[]): 任意; }
>thing : Thing
>'a' : "a"

    let x2 = path(thing, 'a', 'y');  // string
>x2 : 文字
>类型别名 :=> 文字
>path(thing, 'a', 'y') : 文字
>类型别名 :=> 文字
>path : { <T, K1 扩展 键集 T>(obj: T, key1: K1): T[K1]; <T, K1 扩展 键集 T, K2 扩展 键集 T[K1]>(obj: T, key1: K1, key2: K2): T[K1][K2]; <T, K1 扩展 键集 T, K2 扩展 键集 T[K1], K3 扩展 键集 T[K1][K2]>(obj: T, key1: K1, key2: K2, key3: K3): T[K1][K2][K3]; (obj: 任意, ...keys: (文字 | 数字)[]): 任意; }
>thing : Thing
>'a' : "a"
>'y' : "y"

    let x3 = path(thing, 'b');  // boolean
>x3 : 真假
>类型别名 :=> 真假
>path(thing, 'b') : 真假
>类型别名 :=> 真假
>path : { <T, K1 扩展 键集 T>(obj: T, key1: K1): T[K1]; <T, K1 扩展 键集 T, K2 扩展 键集 T[K1]>(obj: T, key1: K1, key2: K2): T[K1][K2]; <T, K1 扩展 键集 T, K2 扩展 键集 T[K1], K3 扩展 键集 T[K1][K2]>(obj: T, key1: K1, key2: K2, key3: K3): T[K1][K2][K3]; (obj: 任意, ...keys: (文字 | 数字)[]): 任意; }
>thing : Thing
>'b' : "b"

    let x4 = path(thing, ...['a', 'x']);  // any
>x4 : 任意
>类型别名 :=> 任意
>path(thing, ...['a', 'x']) : 任意
>类型别名 :=> 任意
>path : { <T, K1 扩展 键集 T>(obj: T, key1: K1): T[K1]; <T, K1 扩展 键集 T, K2 扩展 键集 T[K1]>(obj: T, key1: K1, key2: K2): T[K1][K2]; <T, K1 扩展 键集 T, K2 扩展 键集 T[K1], K3 扩展 键集 T[K1][K2]>(obj: T, key1: K1, key2: K2, key3: K3): T[K1][K2][K3]; (obj: 任意, ...keys: (文字 | 数字)[]): 任意; }
>thing : Thing
>...['a', 'x'] : 文字
>类型别名 :=> 文字
>['a', 'x'] : 文字[]
>'a' : "a"
>'x' : "x"
}

// Repro from comment in #12114

const assignTo2 = <T, K1 extends keyof T, K2 extends keyof T[K1]>(object: T, key1: K1, key2: K2) =>
>assignTo2 : <T, K1 扩展 键集 T, K2 扩展 键集 T[K1]>(object: T, key1: K1, key2: K2) => (value: T[K1][K2]) => T[K1][K2]
><T, K1 extends keyof T, K2 extends keyof T[K1]>(object: T, key1: K1, key2: K2) =>    (value: T[K1][K2]) => object[key1][key2] = value : <T, K1 扩展 键集 T, K2 扩展 键集 T[K1]>(object: T, key1: K1, key2: K2) => (value: T[K1][K2]) => T[K1][K2]
>T : T
>K1 : K1
>T : T
>K2 : K2
>T : T
>K1 : K1
>object : T
>T : T
>key1 : K1
>K1 : K1
>key2 : K2
>K2 : K2

    (value: T[K1][K2]) => object[key1][key2] = value;
>(value: T[K1][K2]) => object[key1][key2] = value : (value: T[K1][K2]) => T[K1][K2]
>value : T[K1][K2]
>T : T
>K1 : K1
>K2 : K2
>object[key1][key2] = value : T[K1][K2]
>object[key1][key2] : T[K1][K2]
>object[key1] : T[K1]
>object : T
>key1 : K1
>key2 : K2
>value : T[K1][K2]

// Modified repro from #12573

declare function one<T>(handler: (t: T) => void): T
>one : <T>(handler: (t: T) => 无值) => T
>T : T
>handler : (t: T) => 无值
>t : T
>T : T
>T : T

var empty = one(() => {}) // inferred as {}, expected
>empty : {}
>one(() => {}) : {}
>one : <T>(handler: (t: T) => 无值) => T
>() => {} : () => 无值

type Handlers<T> = { [K in keyof T]: (t: T[K]) => void }
>Handlers : Handlers<T>
>T : T
>K : K
>T : T
>t : T[K]
>T : T
>K : K

declare function on<T>(handlerHash: Handlers<T>): T
>on : <T>(handlerHash: Handlers<T>) => T
>T : T
>handlerHash : Handlers<T>
>Handlers : Handlers<T>
>T : T
>T : T

var hashOfEmpty1 = on({ test: () => {} });  // {}
>hashOfEmpty1 : { test: {}; }
>on({ test: () => {} }) : { test: {}; }
>on : <T>(handlerHash: Handlers<T>) => T
>{ test: () => {} } : { test: () => 无值; }
>test : () => 无值
>() => {} : () => 无值

var hashOfEmpty2 = on({ test: (x: boolean) => {} });  // { test: boolean }
>hashOfEmpty2 : { test: 真假; }
>on({ test: (x: boolean) => {} }) : { test: 真假; }
>on : <T>(handlerHash: Handlers<T>) => T
>{ test: (x: boolean) => {} } : { test: (x: 真假) => 无值; }
>test : (x: 真假) => 无值
>(x: boolean) => {} : (x: 真假) => 无值
>x : 真假
>类型别名 :=> 真假

// Repro from #12624

interface Options1<Data, Computed> {
>Options1 : Options1<Data, Computed>
>Data : Data
>Computed : Computed

    data?: Data
>data : Data | 未定
>Data : Data

    computed?: Computed;
>computed : Computed | 未定
>Computed : Computed
}

declare class Component1<Data, Computed> {
>Component1 : Component1<Data, Computed>
>Data : Data
>Computed : Computed

    constructor(options: Options1<Data, Computed>);
>options : Options1<Data, Computed>
>Options1 : Options1<Data, Computed>
>Data : Data
>Computed : Computed

    get<K extends keyof (Data & Computed)>(key: K): (Data & Computed)[K];
>get : <K 扩展 键集 (Data & Computed)>(key: K) => (Data & Computed)[K]
>K : K
>Data : Data
>Computed : Computed
>key : K
>K : K
>Data : Data
>Computed : Computed
>K : K
}

let c1 = new Component1({
>c1 : Component1<{ hello: 文字; }, {}>
>new Component1({    data: {        hello: ""    }}) : Component1<{ hello: 文字; }, {}>
>Component1 : 类为 Component1
>{    data: {        hello: ""    }} : { data: { hello: 文字; }; }

    data: {
>data : { hello: 文字; }
>{        hello: ""    } : { hello: 文字; }

        hello: ""
>hello : 文字
>类型别名 :=> 文字
>"" : ""
    }
});

c1.get("hello");
>c1.get("hello") : 文字
>类型别名 :=> 文字
>c1.get : <K 扩展 "hello">(key: K) => { hello: 文字; }[K]
>c1 : Component1<{ hello: 文字; }, {}>
>get : <K 扩展 "hello">(key: K) => { hello: 文字; }[K]
>"hello" : "hello"

// Repro from #12625

interface Options2<Data, Computed> {
>Options2 : Options2<Data, Computed>
>Data : Data
>Computed : Computed

    data?: Data
>data : Data | 未定
>Data : Data

    computed?: Computed;
>computed : Computed | 未定
>Computed : Computed
}

declare class Component2<Data, Computed> {
>Component2 : Component2<Data, Computed>
>Data : Data
>Computed : Computed

    constructor(options: Options2<Data, Computed>);
>options : Options2<Data, Computed>
>Options2 : Options2<Data, Computed>
>Data : Data
>Computed : Computed

    get<K extends keyof Data | keyof Computed>(key: K): (Data & Computed)[K];
>get : <K 扩展 键集 Data | 键集 Computed>(key: K) => (Data & Computed)[K]
>K : K
>Data : Data
>Computed : Computed
>key : K
>K : K
>Data : Data
>Computed : Computed
>K : K
}

// Repro from #12641

interface R {
>R : R

    p: number;
>p : 数字
>类型别名 :=> 数字
}

function f<K extends keyof R>(p: K) {
>f : <K 扩展 "p">(p: K) => 无值
>K : K
>R : R
>p : K
>K : K

    let a: any;
>a : 任意
>类型别名 :=> 任意

    a[p].add;  // any
>a[p].add : 任意
>类型别名 :=> 任意
>a[p] : 任意
>类型别名 :=> 任意
>a : 任意
>类型别名 :=> 任意
>p : K
>add : 任意
>类型别名 :=> 任意
}

// Repro from #12651

type MethodDescriptor = {
>MethodDescriptor : MethodDescriptor

	name: string;
>name : 文字
>类型别名 :=> 文字

	args: any[];
>args : 任意[]

	returnValue: any;
>returnValue : 任意
>类型别名 :=> 任意
}

declare function dispatchMethod<M extends MethodDescriptor>(name: M['name'], args: M['args']): M['returnValue'];
>dispatchMethod : <M 扩展 MethodDescriptor>(name: M["name"], args: M["args"]) => M["returnValue"]
>M : M
>MethodDescriptor : MethodDescriptor
>name : M["name"]
>M : M
>args : M["args"]
>M : M
>M : M

type SomeMethodDescriptor = {
>SomeMethodDescriptor : SomeMethodDescriptor

	name: "someMethod";
>name : "someMethod"

	args: [string, number];
>args : [文字, 数字]

	returnValue: string[];
>returnValue : 文字[]
}

let result = dispatchMethod<SomeMethodDescriptor>("someMethod", ["hello", 35]);
>result : 文字[]
>dispatchMethod<SomeMethodDescriptor>("someMethod", ["hello", 35]) : 文字[]
>dispatchMethod : <M 扩展 MethodDescriptor>(name: M["name"], args: M["args"]) => M["returnValue"]
>SomeMethodDescriptor : SomeMethodDescriptor
>"someMethod" : "someMethod"
>["hello", 35] : [文字, 数字]
>"hello" : "hello"
>35 : 35

// Repro from #13073

type KeyTypes = "a" | "b"
>KeyTypes : "a" | "b"

let MyThingy: { [key in KeyTypes]: string[] };
>MyThingy : { a: 文字[]; b: 文字[]; }
>key : key
>KeyTypes : "a" | "b"

function addToMyThingy<S extends KeyTypes>(key: S) {
>addToMyThingy : <S 扩展 "a" | "b">(key: S) => 无值
>S : S
>KeyTypes : "a" | "b"
>key : S
>S : S

    MyThingy[key].push("a");
>MyThingy[key].push("a") : 数字
>类型别名 :=> 数字
>MyThingy[key].push : (...items: 文字[]) => 数字
>MyThingy[key] : { a: 文字[]; b: 文字[]; }[S]
>MyThingy : { a: 文字[]; b: 文字[]; }
>key : S
>push : (...items: 文字[]) => 数字
>"a" : "a"
}

// Repro from #13102

type Handler<T> = {
>Handler : Handler<T>
>T : T

    onChange: (name: keyof T) => void;
>onChange : (name: 键集 T) => 无值
>name : 键集 T
>T : T

};

function onChangeGenericFunction<T>(handler: Handler<T & {preset: number}>) {
>onChangeGenericFunction : <T>(handler: Handler<T & { preset: 数字; }>) => 无值
>T : T
>handler : Handler<T & { preset: 数字; }>
>Handler : Handler<T>
>T : T
>preset : 数字
>类型别名 :=> 数字

    handler.onChange('preset')
>handler.onChange('preset') : 无值
>类型别名 :=> 无值
>handler.onChange : (name: 键集 (T & { preset: 数字; })) => 无值
>handler : Handler<T & { preset: 数字; }>
>onChange : (name: 键集 (T & { preset: 数字; })) => 无值
>'preset' : "preset"
}

// Repro from #13285

function updateIds<T extends Record<K, string>, K extends string>(
>updateIds : <T 扩展 Record<K, 文字>, K 扩展 文字>(obj: T, idFields: K[], idMapping: { [oldId: 文字]: 文字; }) => Record<K, 文字>
>T : T
>Record : Record<K, T>
>K : K
>K : K

    obj: T,
>obj : T
>T : T

    idFields: K[],
>idFields : K[]
>K : K

    idMapping: { [oldId: string]: string }
>idMapping : { [oldId: 文字]: 文字; }
>oldId : 文字
>类型别名 :=> 文字

): Record<K, string> {
>Record : Record<K, T>
>K : K

    for (const idField of idFields) {
>idField : K
>idFields : K[]

        const newId = idMapping[obj[idField]];
>newId : { [oldId: 文字]: 文字; }[T[K]]
>idMapping[obj[idField]] : { [oldId: 文字]: 文字; }[T[K]]
>idMapping : { [oldId: 文字]: 文字; }
>obj[idField] : T[K]
>obj : T
>idField : K

        if (newId) {
>newId : { [oldId: 文字]: 文字; }[T[K]]

            obj[idField] = newId;
>obj[idField] = newId : { [oldId: 文字]: 文字; }[T[K]]
>obj[idField] : T[K]
>obj : T
>idField : K
>newId : { [oldId: 文字]: 文字; }[T[K]]
        }
    }
    return obj;
>obj : T
}

// Repro from #13285

function updateIds2<T extends { [x: string]: string }, K extends keyof T>(
>updateIds2 : <T 扩展 { [x: 文字]: 文字; }, K 扩展 键集 T>(obj: T, key: K, stringMap: { [oldId: 文字]: 文字; }) => 无值
>T : T
>x : 文字
>类型别名 :=> 文字
>K : K
>T : T

    obj: T,
>obj : T
>T : T

    key: K,
>key : K
>K : K

    stringMap: { [oldId: string]: string }
>stringMap : { [oldId: 文字]: 文字; }
>oldId : 文字
>类型别名 :=> 文字

) {
    var x = obj[key];
>x : T[K]
>obj[key] : T[K]
>obj : T
>key : K

    stringMap[x]; // Should be OK.
>stringMap[x] : { [oldId: 文字]: 文字; }[T[K]]
>stringMap : { [oldId: 文字]: 文字; }
>x : T[K]
}

// Repro from #13514

declare function head<T extends Array<any>>(list: T): T[0];
>head : <T 扩展 任意[]>(list: T) => T[0]
>T : T
>Array : T[]
>list : T
>T : T
>T : T

// Repro from #13604

class A<T> {
>A : A<T>
>T : T

	props: T & { foo: string };
>props : T & { foo: 文字; }
>T : T
>foo : 文字
>类型别名 :=> 文字
}

class B extends A<{ x: number}> {
>B : B
>A : A<{ x: 数字; }>
>x : 数字
>类型别名 :=> 数字

	f(p: this["props"]) {
>f : (p: 本体["props"]) => 无值
>p : 本体["props"]

		p.x;
>p.x : 数字
>类型别名 :=> 数字
>p : 本体["props"]
>x : 数字
>类型别名 :=> 数字
	}
}

// Repro from #13749

class Form<T> {
>Form : Form<T>
>T : T

    private childFormFactories: {[K in keyof T]: (v: T[K]) => Form<T[K]>}
>childFormFactories : { [K 位于 键集 T]: (v: T[K]) => Form<T[K]>; }
>K : K
>T : T
>v : T[K]
>T : T
>K : K
>Form : Form<T>
>T : T
>K : K

    public set<K extends keyof T>(prop: K, value: T[K]) {
>set : <K 扩展 键集 T>(prop: K, value: T[K]) => 无值
>K : K
>T : T
>prop : K
>K : K
>value : T[K]
>T : T
>K : K

        this.childFormFactories[prop](value)
>this.childFormFactories[prop](value) : Form<T[K]>
>this.childFormFactories[prop] : { [K 位于 键集 T]: (v: T[K]) => Form<T[K]>; }[K]
>this.childFormFactories : { [K 位于 键集 T]: (v: T[K]) => Form<T[K]>; }
>this : 本体
>childFormFactories : { [K 位于 键集 T]: (v: T[K]) => Form<T[K]>; }
>prop : K
>value : T[K]
    }
}

// Repro from #13787

class SampleClass<P> {
>SampleClass : SampleClass<P>
>P : P

    public props: Readonly<P>;
>props : Readonly<P>
>Readonly : Readonly<T>
>P : P

    constructor(props: P) {
>props : P
>P : P

        this.props = Object.freeze(props);
>this.props = Object.freeze(props) : Readonly<P>
>this.props : Readonly<P>
>this : 本体
>props : Readonly<P>
>Object.freeze(props) : Readonly<P>
>Object.freeze : { <T>(a: T[]): ReadonlyArray<T>; <T 扩展 Function>(f: T): T; <T>(o: T): Readonly<T>; }
>Object : ObjectConstructor
>freeze : { <T>(a: T[]): ReadonlyArray<T>; <T 扩展 Function>(f: T): T; <T>(o: T): Readonly<T>; }
>props : P
    }
}

interface Foo {
>Foo : Foo

    foo: string;
>foo : 文字
>类型别名 :=> 文字
}

declare function merge<T, U>(obj1: T, obj2: U): T & U;
>merge : <T, U>(obj1: T, obj2: U) => T & U
>T : T
>U : U
>obj1 : T
>T : T
>obj2 : U
>U : U
>T : T
>U : U

class AnotherSampleClass<T> extends SampleClass<T & Foo> {
>AnotherSampleClass : AnotherSampleClass<T>
>T : T
>SampleClass : SampleClass<T & Foo>
>T : T
>Foo : Foo

    constructor(props: T) {
>props : T
>T : T

        const foo: Foo = { foo: "bar" };
>foo : Foo
>Foo : Foo
>{ foo: "bar" } : { foo: 文字; }
>foo : 文字
>类型别名 :=> 文字
>"bar" : "bar"

        super(merge(props, foo));
>super(merge(props, foo)) : 无值
>类型别名 :=> 无值
>super : 类为 SampleClass
>merge(props, foo) : T & Foo
>merge : <T, U>(obj1: T, obj2: U) => T & U
>props : T
>foo : Foo
    }

    public brokenMethod() {
>brokenMethod : () => 无值

        this.props.foo.concat;
>this.props.foo.concat : (...strings: 文字[]) => 文字
>this.props.foo : (T & Foo)["foo"]
>this.props : Readonly<T & Foo>
>this : 本体
>props : Readonly<T & Foo>
>foo : (T & Foo)["foo"]
>concat : (...strings: 文字[]) => 文字
    }
}
new AnotherSampleClass({});
>new AnotherSampleClass({}) : AnotherSampleClass<{}>
>AnotherSampleClass : 类为 AnotherSampleClass
>{} : {}

