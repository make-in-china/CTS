=== tests/cases/conformance/types/thisType/thisTypeInObjectLiterals.ts ===
let o = {
>o : { d: string; m(): number; f: () => number; }
>{    d: "bar",    m() {        return this.d.length;    },    f: function() {        return this.d.length;    }} : { d: string; m(): number; f: () => number; }

    d: "bar",
>d : string
>类型别名 :=> 文字
>"bar" : "bar"

    m() {
>m : () => number

        return this.d.length;
>this.d.length : number
>类型别名 :=> 数字
>this.d : string
>类型别名 :=> 文字
>this : { d: string; m(): number; f: () => number; }
>d : string
>类型别名 :=> 文字
>length : number
>类型别名 :=> 数字

    },
    f: function() {
>f : () => number
>function() {        return this.d.length;    } : () => number

        return this.d.length;
>this.d.length : number
>类型别名 :=> 数字
>this.d : string
>类型别名 :=> 文字
>this : { d: string; m(): number; f: () => number; }
>d : string
>类型别名 :=> 文字
>length : number
>类型别名 :=> 数字
    }
}

let mutuallyRecursive = {
>mutuallyRecursive : { a: number; start(): number; passthrough(n: number): number; sub1(n: number): number; }
>{    a: 100,    start() {        return this.passthrough(this.a);    },    passthrough(n: number) {        return this.sub1(n);    },    sub1(n: number): number {        if (n > 0) {            return this.passthrough(n - 1);        }        return n;    }} : { a: number; start(): number; passthrough(n: number): number; sub1(n: number): number; }

    a: 100,
>a : number
>类型别名 :=> 数字
>100 : 100

    start() {
>start : () => number

        return this.passthrough(this.a);
>this.passthrough(this.a) : number
>类型别名 :=> 数字
>this.passthrough : (n: number) => number
>this : { a: number; start(): number; passthrough(n: number): number; sub1(n: number): number; }
>passthrough : (n: number) => number
>this.a : number
>类型别名 :=> 数字
>this : { a: number; start(): number; passthrough(n: number): number; sub1(n: number): number; }
>a : number
>类型别名 :=> 数字

    },
    passthrough(n: number) {
>passthrough : (n: number) => number
>n : number
>类型别名 :=> 数字

        return this.sub1(n);
>this.sub1(n) : number
>类型别名 :=> 数字
>this.sub1 : (n: number) => number
>this : { a: number; start(): number; passthrough(n: number): number; sub1(n: number): number; }
>sub1 : (n: number) => number
>n : number
>类型别名 :=> 数字

    },
    sub1(n: number): number {
>sub1 : (n: number) => number
>n : number
>类型别名 :=> 数字

        if (n > 0) {
>n > 0 : boolean
>类型别名 :=> 真假
>n : number
>类型别名 :=> 数字
>0 : 0

            return this.passthrough(n - 1);
>this.passthrough(n - 1) : number
>类型别名 :=> 数字
>this.passthrough : (n: number) => number
>this : { a: number; start(): number; passthrough(n: number): number; sub1(n: number): number; }
>passthrough : (n: number) => number
>n - 1 : number
>类型别名 :=> 数字
>n : number
>类型别名 :=> 数字
>1 : 1
        }
        return n;
>n : number
>类型别名 :=> 数字
    }
}
var i: number = mutuallyRecursive.start();
>i : number
>类型别名 :=> 数字
>mutuallyRecursive.start() : number
>类型别名 :=> 数字
>mutuallyRecursive.start : () => number
>mutuallyRecursive : { a: number; start(): number; passthrough(n: number): number; sub1(n: number): number; }
>start : () => number

interface I {
>I : I

    a: number;
>a : number
>类型别名 :=> 数字

    start(): number;
>start : () => number

    passthrough(n: number): number;
>passthrough : (n: number) => number
>n : number
>类型别名 :=> 数字

    sub1(n: number): number;
>sub1 : (n: number) => number
>n : number
>类型别名 :=> 数字
}
var impl: I = mutuallyRecursive;
>impl : I
>I : I
>mutuallyRecursive : { a: number; start(): number; passthrough(n: number): number; sub1(n: number): number; }

