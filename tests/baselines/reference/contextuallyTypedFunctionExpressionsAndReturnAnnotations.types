=== tests/cases/conformance/expressions/functions/contextuallyTypedFunctionExpressionsAndReturnAnnotations.ts ===
declare function foo(x: (y: string) => (y2: number) => void);
>foo : (x: (y: string) => (y2: number) => void) => any
>x : (y: string) => (y2: number) => void
>y : string
>类型别名 :=> 文字
>y2 : number
>类型别名 :=> 数字

// Contextually type the parameter even if there is a return annotation
foo((y): (y2: number) => void => {
>foo((y): (y2: number) => void => {    var z = y.charAt(0); // Should be string    return null;}) : any
>类型别名 :=> 任意
>foo : (x: (y: string) => (y2: number) => void) => any
>(y): (y2: number) => void => {    var z = y.charAt(0); // Should be string    return null;} : (y: string) => (y2: number) => void
>y : string
>类型别名 :=> 文字
>y2 : number
>类型别名 :=> 数字

    var z = y.charAt(0); // Should be string
>z : string
>类型别名 :=> 文字
>y.charAt(0) : string
>类型别名 :=> 文字
>y.charAt : (pos: number) => string
>y : string
>类型别名 :=> 文字
>charAt : (pos: number) => string
>0 : 0

    return null;
>null : null
>类型别名 :=> 空值

});

foo((y: string) => {
>foo((y: string) => {    return y2 => {        var z = y2.toFixed(); // Should be string        return 0;    };}) : any
>类型别名 :=> 任意
>foo : (x: (y: string) => (y2: number) => void) => any
>(y: string) => {    return y2 => {        var z = y2.toFixed(); // Should be string        return 0;    };} : (y: string) => (y2: number) => number
>y : string
>类型别名 :=> 文字

    return y2 => {
>y2 => {        var z = y2.toFixed(); // Should be string        return 0;    } : (y2: number) => number
>y2 : number
>类型别名 :=> 数字

        var z = y2.toFixed(); // Should be string
>z : string
>类型别名 :=> 文字
>y2.toFixed() : string
>类型别名 :=> 文字
>y2.toFixed : (fractionDigits?: number) => string
>y2 : number
>类型别名 :=> 数字
>toFixed : (fractionDigits?: number) => string

        return 0;
>0 : 0

    };
});
