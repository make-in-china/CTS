=== tests/cases/compiler/a.js ===
"use strict";
>"use strict" : "use strict"

var a = {
>a : { [x: string]: any; a: number; b: number; }
>{    a: "hello", // error    b: 10,    a: 10 // error} : { [x: string]: any; a: number; b: number; }

    a: "hello", // error
>a : string
>类型别名 :=> 文字
>"hello" : "hello"

    b: 10,
>b : number
>类型别名 :=> 数字
>10 : 10

    a: 10 // error
>a : string
>类型别名 :=> 文字
>10 : 10

};
var let = 10; // error
>let : number
>类型别名 :=> 数字
>10 : 10

delete a; // error
>delete a : boolean
>类型别名 :=> 真假
>a : { [x: string]: any; a: number; b: number; }

try {
} catch (eval) { // error
>eval : any
>类型别名 :=> 任意
}
function arguments() { // error
>arguments : () => void
}

with (a) {
>a : { [x: string]: any; a: number; b: number; }

    b = 10;
>b = 10 : any
>类型别名 :=> 任意
>b : any
>类型别名 :=> 任意
>10 : any
>类型别名 :=> 任意
}

=== tests/cases/compiler/b.js ===
// this is not in strict mode but class definitions are always in strict mode
class c {
>c : c

    a(eval) { //error
>a : (eval: any) => void
>eval : any
>类型别名 :=> 任意
    }
    method() {
>method : () => void

        var let = 10; // error
>let : number
>类型别名 :=> 数字
>10 : 10
    }
}

=== tests/cases/compiler/c.js ===
export var let = 10; // external modules are automatically in strict mode
>let : number
>类型别名 :=> 数字
>10 : 10

var eval = function () {
>eval : () => void
>function () {} : () => void

};

=== tests/cases/compiler/d.js ===
"use strict";
>"use strict" : "use strict"

var x = 009; // error
>x : number
>类型别名 :=> 数字
>00 : 0
>9 : 9

