=== tests/cases/conformance/types/witness/witness.ts ===
// Initializers
var varInit = varInit; // any
>varInit : any
>类型别名 :=> 任意
>varInit : any
>类型别名 :=> 任意

var pInit: any;
>pInit : any
>类型别名 :=> 任意

function fn(pInit = pInit) {
>fn : (pInit?: any) => void
>pInit : any
>类型别名 :=> 任意
>pInit : any
>类型别名 :=> 任意

    var pInit: any;
>pInit : any
>类型别名 :=> 任意
}
class InitClass {
>InitClass : InitClass

    x = this.x;
>x : any
>类型别名 :=> 任意
>this.x : any
>类型别名 :=> 任意
>this : this
>x : any
>类型别名 :=> 任意

    fn() {
>fn : () => void

        var y = this.x;
>y : any
>类型别名 :=> 任意
>this.x : any
>类型别名 :=> 任意
>this : this
>x : any
>类型别名 :=> 任意

        var y: any;
>y : any
>类型别名 :=> 任意
    }
}

// Return type
function fnReturn1() {
>fnReturn1 : () => any

    return fnReturn1();
>fnReturn1() : any
>类型别名 :=> 任意
>fnReturn1 : () => any
}
var a: any;
>a : any
>类型别名 :=> 任意

var a = fnReturn1();
>a : any
>类型别名 :=> 任意
>fnReturn1() : any
>类型别名 :=> 任意
>fnReturn1 : () => any

function fnReturn2() {
>fnReturn2 : () => typeof fnReturn2

    return fnReturn2;
>fnReturn2 : () => typeof fnReturn2
}
var fnr2: () => any = fnReturn2();
>fnr2 : () => any
>fnReturn2() : () => typeof fnReturn2
>fnReturn2 : () => typeof fnReturn2

// Comma
var co1 = (co1, 3);
>co1 : any
>类型别名 :=> 任意
>(co1, 3) : 3
>co1, 3 : 3
>co1 : any
>类型别名 :=> 任意
>3 : 3

var co1: number;
>co1 : any
>类型别名 :=> 任意

var co2 = (3, 4, co2);
>co2 : any
>类型别名 :=> 任意
>(3, 4, co2) : any
>类型别名 :=> 任意
>3, 4, co2 : any
>类型别名 :=> 任意
>3, 4 : 4
>3 : 3
>4 : 4
>co2 : any
>类型别名 :=> 任意

var co2: any;
>co2 : any
>类型别名 :=> 任意

var co3 = (co1, co2, co3, co1);
>co3 : any
>类型别名 :=> 任意
>(co1, co2, co3, co1) : any
>类型别名 :=> 任意
>co1, co2, co3, co1 : any
>类型别名 :=> 任意
>co1, co2, co3 : any
>类型别名 :=> 任意
>co1, co2 : any
>类型别名 :=> 任意
>co1 : any
>类型别名 :=> 任意
>co2 : any
>类型别名 :=> 任意
>co3 : any
>类型别名 :=> 任意
>co1 : any
>类型别名 :=> 任意

var co3: number;
>co3 : any
>类型别名 :=> 任意

// Assignment
var as1 = (as1 = 2);
>as1 : any
>类型别名 :=> 任意
>(as1 = 2) : 2
>as1 = 2 : 2
>as1 : any
>类型别名 :=> 任意
>2 : 2

var as1: number;
>as1 : any
>类型别名 :=> 任意

var as2 = (as2 = as2 = 2);
>as2 : any
>类型别名 :=> 任意
>(as2 = as2 = 2) : 2
>as2 = as2 = 2 : 2
>as2 : any
>类型别名 :=> 任意
>as2 = 2 : 2
>as2 : any
>类型别名 :=> 任意
>2 : 2

var as2: number;
>as2 : any
>类型别名 :=> 任意

// Conditional
var cnd1 = cnd1 ? 0 : 1;
>cnd1 : any
>类型别名 :=> 任意
>cnd1 ? 0 : 1 : 0 | 1
>cnd1 : any
>类型别名 :=> 任意
>0 : 0
>1 : 1

var cnd1: number;
>cnd1 : any
>类型别名 :=> 任意

var cnd2 = cnd1 ? cnd1 ? '' : "" : '';
>cnd2 : string
>类型别名 :=> 文字
>cnd1 ? cnd1 ? '' : "" : '' : ""
>cnd1 : any
>类型别名 :=> 任意
>cnd1 ? '' : "" : ""
>cnd1 : any
>类型别名 :=> 任意
>'' : ""
>"" : ""
>'' : ""

var cnd2: string;
>cnd2 : string
>类型别名 :=> 文字

// ||
var or1 = or1 || '';
>or1 : any
>类型别名 :=> 任意
>or1 || '' : any
>类型别名 :=> 任意
>or1 : any
>类型别名 :=> 任意
>'' : ""

var or1: any;
>or1 : any
>类型别名 :=> 任意

var or2 = '' || or2;
>or2 : any
>类型别名 :=> 任意
>'' || or2 : any
>类型别名 :=> 任意
>'' : ""
>or2 : any
>类型别名 :=> 任意

var or2: any;
>or2 : any
>类型别名 :=> 任意

var or3 = or3 || or3;
>or3 : any
>类型别名 :=> 任意
>or3 || or3 : any
>类型别名 :=> 任意
>or3 : any
>类型别名 :=> 任意
>or3 : any
>类型别名 :=> 任意

var or3: any;
>or3 : any
>类型别名 :=> 任意

// &&
var and1 = and1 && '';
>and1 : any
>类型别名 :=> 任意
>and1 && '' : ""
>and1 : any
>类型别名 :=> 任意
>'' : ""

var and1: string;
>and1 : any
>类型别名 :=> 任意

var and2 = '' && and2;
>and2 : any
>类型别名 :=> 任意
>'' && and2 : ""
>'' : ""
>and2 : any
>类型别名 :=> 任意

var and2: any;
>and2 : any
>类型别名 :=> 任意

var and3 = and3 && and3;
>and3 : any
>类型别名 :=> 任意
>and3 && and3 : any
>类型别名 :=> 任意
>and3 : any
>类型别名 :=> 任意
>and3 : any
>类型别名 :=> 任意

var and3: any;
>and3 : any
>类型别名 :=> 任意

// function call return type
function fnCall() {
>fnCall : () => any

    return fnCall();
>fnCall() : any
>类型别名 :=> 任意
>fnCall : () => any
}
var fnCallResult = fnCall();
>fnCallResult : any
>类型别名 :=> 任意
>fnCall() : any
>类型别名 :=> 任意
>fnCall : () => any

var fnCallResult: any;
>fnCallResult : any
>类型别名 :=> 任意

// Call argument
function fnArg1(x: typeof fnArg1, y: number) {
>fnArg1 : (x: typeof fnArg1, y: number) => void
>x : (x: typeof fnArg1, y: number) => void
>fnArg1 : (x: typeof fnArg1, y: number) => void
>y : number
>类型别名 :=> 数字

    var x: (n: typeof fnArg1, m: number) => void;
>x : (x: typeof fnArg1, y: number) => void
>n : (x: typeof fnArg1, y: number) => void
>fnArg1 : (x: typeof fnArg1, y: number) => void
>m : number
>类型别名 :=> 数字

    fnArg1(fnArg1, 0);
>fnArg1(fnArg1, 0) : void
>类型别名 :=> 无值
>fnArg1 : (x: typeof fnArg1, y: number) => void
>fnArg1 : (x: typeof fnArg1, y: number) => void
>0 : 0
}

function overload1(x: (n: string) => string): string;
>overload1 : { (x: (n: string) => string): string; (x: (n: number) => number): number; (x: (n: any) => any): any; }
>x : (n: string) => string
>n : string
>类型别名 :=> 文字

function overload1(x: (n: number) => number): number;
>overload1 : { (x: (n: string) => string): string; (x: (n: number) => number): number; (x: (n: any) => any): any; }
>x : (n: number) => number
>n : number
>类型别名 :=> 数字

function overload1(x: (n: any) => any): any;
>overload1 : { (x: (n: string) => string): string; (x: (n: number) => number): number; (x: (n: any) => any): any; }
>x : (n: any) => any
>n : any
>类型别名 :=> 任意

function overload1() { return undefined; };
>overload1 : { (x: (n: string) => string): string; (x: (n: number) => number): number; (x: (n: any) => any): any; }
>undefined : undefined
>类型别名 :=> 未定

function fnArg2() {
>fnArg2 : () => any

    return overload1(fnArg2);
>overload1(fnArg2) : any
>类型别名 :=> 任意
>overload1 : { (x: (n: string) => string): string; (x: (n: number) => number): number; (x: (n: any) => any): any; }
>fnArg2 : () => any
}
var t = fnArg2(); // t: should be 'any', but is 'string'
>t : any
>类型别名 :=> 任意
>fnArg2() : any
>类型别名 :=> 任意
>fnArg2 : () => any

// New operator
class C {
>C : C

    fn1() {
>fn1 : () => any

        return new (this.fn1())();
>new (this.fn1())() : any
>类型别名 :=> 任意
>(this.fn1()) : any
>类型别名 :=> 任意
>this.fn1() : any
>类型别名 :=> 任意
>this.fn1 : () => any
>this : this
>fn1 : () => any
    }
    fn2() {
>fn2 : () => any

        return new (this.fn2());
>new (this.fn2()) : any
>类型别名 :=> 任意
>(this.fn2()) : any
>类型别名 :=> 任意
>this.fn2() : any
>类型别名 :=> 任意
>this.fn2 : () => any
>this : this
>fn2 : () => any
    }
    fn3() {
>fn3 : () => number

        var a: new(x) => number;
>a : new (x: any) => number
>x : any
>类型别名 :=> 任意

        return new a(this.fn3);
>new a(this.fn3) : number
>类型别名 :=> 数字
>a : new (x: any) => number
>this.fn3 : () => number
>this : this
>fn3 : () => number
    }
}

function fn5() {
>fn5 : () => number

    var a: new (x) => number;
>a : new (x: any) => number
>x : any
>类型别名 :=> 任意

    return new a(fn5);
>new a(fn5) : number
>类型别名 :=> 数字
>a : new (x: any) => number
>fn5 : () => number
}
var fn5r = fn5(); // fn5r: should be 'any', but is 'number'
>fn5r : number
>类型别名 :=> 数字
>fn5() : number
>类型别名 :=> 数字
>fn5 : () => number

// Property access
var propAcc1 = {
>propAcc1 : any
>类型别名 :=> 任意
>{    m: propAcc1.m} : { m: any; }

    m: propAcc1.m
>m : any
>类型别名 :=> 任意
>propAcc1.m : any
>类型别名 :=> 任意
>propAcc1 : any
>类型别名 :=> 任意
>m : any
>类型别名 :=> 任意

};
var propAcc1: { m: any; }
>propAcc1 : any
>类型别名 :=> 任意
>m : any
>类型别名 :=> 任意

// Property access of module member
module M2 {
>M2 : typeof M2

    export var x = M2.x;
>x : any
>类型别名 :=> 任意
>M2.x : any
>类型别名 :=> 任意
>M2 : typeof M2
>x : any
>类型别名 :=> 任意

    var y = x;
>y : any
>类型别名 :=> 任意
>x : any
>类型别名 :=> 任意

    var y: any;
>y : any
>类型别名 :=> 任意
}

// Property access of class instance type
class C2 {
>C2 : C2

    n = this.n; // n: any
>n : any
>类型别名 :=> 任意
>this.n : any
>类型别名 :=> 任意
>this : this
>n : any
>类型别名 :=> 任意
}
var c2inst = new C2().n;
>c2inst : any
>类型别名 :=> 任意
>new C2().n : any
>类型别名 :=> 任意
>new C2() : C2
>C2 : typeof C2
>n : any
>类型别名 :=> 任意

var c2inst: any;
>c2inst : any
>类型别名 :=> 任意

// Constructor function property access
class C3 {
>C3 : C3

    static q = C3.q;
>q : any
>类型别名 :=> 任意
>C3.q : any
>类型别名 :=> 任意
>C3 : typeof C3
>q : any
>类型别名 :=> 任意
}
var qq = C3.q;
>qq : any
>类型别名 :=> 任意
>C3.q : any
>类型别名 :=> 任意
>C3 : typeof C3
>q : any
>类型别名 :=> 任意

var qq: any;
>qq : any
>类型别名 :=> 任意

// Parentheses - tested a bunch above



