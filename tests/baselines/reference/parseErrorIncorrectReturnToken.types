=== tests/cases/compiler/parseErrorIncorrectReturnToken.ts ===
type F1 = {
>F1 : F1

    (n: number) => string; // should be : not =>
>n : number
>类型别名 :=> 数字
}
type F2 = (n: number): string; // should be => not :
>F2 : F2
>n : number
>类型别名 :=> 数字
> : No type information available!
>string : any
>类型别名 :=> 任意

// doesn't work in non-type contexts, where the return type is optional
let f = (n: number) => string => n.toString();
>f : (n: number) => (string: any) => string
>(n: number) => string => n.toString() : (n: number) => (string: any) => string
>n : number
>类型别名 :=> 数字
>string => n.toString() : (string: any) => string
>string : any
>类型别名 :=> 任意
>n.toString() : string
>类型别名 :=> 文字
>n.toString : (radix?: number) => string
>n : number
>类型别名 :=> 数字
>toString : (radix?: number) => string

let o = {
>o : { m(n: number): any; }
>{    m(n: number) : { m(n: number): any; }

    m(n: number) => string {
>m : (n: number) => any
>n : number
>类型别名 :=> 数字
>string : any
>类型别名 :=> 任意

        return n.toString();
>n.toString() : any
>类型别名 :=> 任意
>n.toString : any
>类型别名 :=> 任意
>n : any
>类型别名 :=> 任意
>toString : any
>类型别名 :=> 任意
    }
};

