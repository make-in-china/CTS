=== tests/cases/compiler/es6ClassTest2.ts ===
class BasicMonster {
>BasicMonster : BasicMonster

    constructor(public name: string, public health: number) {
>name : string
>类型别名 :=> 文字
>health : number
>类型别名 :=> 数字

    }

    attack(target) {
>attack : (target: any) => void
>target : any
>类型别名 :=> 任意

      // WScript.Echo("Attacks " + target);
    }

    isAlive = true;
>isAlive : boolean
>类型别名 :=> 真假
>true : true
>类型别名 :=> 为真
}

var m1 = new BasicMonster("1", 100);
>m1 : BasicMonster
>new BasicMonster("1", 100) : BasicMonster
>BasicMonster : typeof BasicMonster
>"1" : "1"
>100 : 100

var m2 = new BasicMonster("2", 100);
>m2 : BasicMonster
>new BasicMonster("2", 100) : BasicMonster
>BasicMonster : typeof BasicMonster
>"2" : "2"
>100 : 100

m1.attack(m2);
>m1.attack(m2) : void
>类型别名 :=> 无值
>m1.attack : (target: any) => void
>m1 : BasicMonster
>attack : (target: any) => void
>m2 : BasicMonster

m1.health = 0;
>m1.health = 0 : 0
>m1.health : number
>类型别名 :=> 数字
>m1 : BasicMonster
>health : number
>类型别名 :=> 数字
>0 : 0

console.log((<any>m5.isAlive).toString());
>console.log((<any>m5.isAlive).toString()) : any
>类型别名 :=> 任意
>console.log : any
>类型别名 :=> 任意
>console : any
>类型别名 :=> 任意
>log : any
>类型别名 :=> 任意
>(<any>m5.isAlive).toString() : any
>类型别名 :=> 任意
>(<any>m5.isAlive).toString : any
>类型别名 :=> 任意
>(<any>m5.isAlive) : any
>类型别名 :=> 任意
><any>m5.isAlive : any
>类型别名 :=> 任意
>m5.isAlive : boolean
>类型别名 :=> 真假
>m5 : OverloadedMonster
>isAlive : boolean
>类型别名 :=> 真假
>toString : any
>类型别名 :=> 任意

class GetSetMonster {
>GetSetMonster : GetSetMonster

    constructor(public name: string, private _health: number) {
>name : string
>类型别名 :=> 文字
>_health : number
>类型别名 :=> 数字

    }

    attack(target) {
>attack : (target: any) => void
>target : any
>类型别名 :=> 任意

      // WScript.Echo("Attacks " + target);
    }
  // The contextual keyword "get" followed by an identifier and
  // a curly body defines a getter in the same way that "get"
  // defines one in an object literal.
    get isAlive() {
>isAlive : boolean
>类型别名 :=> 真假

        return this._health > 0;
>this._health > 0 : boolean
>类型别名 :=> 真假
>this._health : number
>类型别名 :=> 数字
>this : this
>_health : number
>类型别名 :=> 数字
>0 : 0
    }

  // Likewise, "set" can be used to define setters.
    set health(value: number) {
>health : number
>类型别名 :=> 数字
>value : number
>类型别名 :=> 数字

        if (value < 0) {
>value < 0 : boolean
>类型别名 :=> 真假
>value : number
>类型别名 :=> 数字
>0 : 0

            throw new Error('Health must be non-negative.')
>new Error('Health must be non-negative.') : Error
>Error : ErrorConstructor
>'Health must be non-negative.' : "Health must be non-negative."
    }
        this._health = value
>this._health = value : number
>类型别名 :=> 数字
>this._health : number
>类型别名 :=> 数字
>this : this
>_health : number
>类型别名 :=> 数字
>value : number
>类型别名 :=> 数字
  }
}

var m3 = new BasicMonster("1", 100);
>m3 : BasicMonster
>new BasicMonster("1", 100) : BasicMonster
>BasicMonster : typeof BasicMonster
>"1" : "1"
>100 : 100

var m4 = new BasicMonster("2", 100);
>m4 : BasicMonster
>new BasicMonster("2", 100) : BasicMonster
>BasicMonster : typeof BasicMonster
>"2" : "2"
>100 : 100

m3.attack(m4);
>m3.attack(m4) : void
>类型别名 :=> 无值
>m3.attack : (target: any) => void
>m3 : BasicMonster
>attack : (target: any) => void
>m4 : BasicMonster

m3.health = 0;
>m3.health = 0 : 0
>m3.health : number
>类型别名 :=> 数字
>m3 : BasicMonster
>health : number
>类型别名 :=> 数字
>0 : 0

var x = (<any>m5.isAlive).toString()
>x : any
>类型别名 :=> 任意
>(<any>m5.isAlive).toString() : any
>类型别名 :=> 任意
>(<any>m5.isAlive).toString : any
>类型别名 :=> 任意
>(<any>m5.isAlive) : any
>类型别名 :=> 任意
><any>m5.isAlive : any
>类型别名 :=> 任意
>m5.isAlive : boolean
>类型别名 :=> 真假
>m5 : OverloadedMonster
>isAlive : boolean
>类型别名 :=> 真假
>toString : any
>类型别名 :=> 任意

class OverloadedMonster {
>OverloadedMonster : OverloadedMonster

    constructor(name: string);
>name : string
>类型别名 :=> 文字

    constructor(public name: string, public health?: number) {
>name : string
>类型别名 :=> 文字
>health : number
>类型别名 :=> 数字

    }

    attack();
>attack : { (): any; (a: any): any; }

    attack(a: any);
>attack : { (): any; (a: any): any; }
>a : any
>类型别名 :=> 任意

    attack(target?) {
>attack : { (): any; (a: any): any; }
>target : any
>类型别名 :=> 任意

        //WScript.Echo("Attacks " + target);
    }

    isAlive = true;
>isAlive : boolean
>类型别名 :=> 真假
>true : true
>类型别名 :=> 为真
}

var m5 = new OverloadedMonster("1");
>m5 : OverloadedMonster
>new OverloadedMonster("1") : OverloadedMonster
>OverloadedMonster : typeof OverloadedMonster
>"1" : "1"

var m6 = new OverloadedMonster("2");
>m6 : OverloadedMonster
>new OverloadedMonster("2") : OverloadedMonster
>OverloadedMonster : typeof OverloadedMonster
>"2" : "2"

m5.attack(m6);
>m5.attack(m6) : any
>类型别名 :=> 任意
>m5.attack : { (): any; (a: any): any; }
>m5 : OverloadedMonster
>attack : { (): any; (a: any): any; }
>m6 : OverloadedMonster

m5.health = 0;
>m5.health = 0 : 0
>m5.health : number
>类型别名 :=> 数字
>m5 : OverloadedMonster
>health : number
>类型别名 :=> 数字
>0 : 0

var y = (<any>m5.isAlive).toString()
>y : any
>类型别名 :=> 任意
>(<any>m5.isAlive).toString() : any
>类型别名 :=> 任意
>(<any>m5.isAlive).toString : any
>类型别名 :=> 任意
>(<any>m5.isAlive) : any
>类型别名 :=> 任意
><any>m5.isAlive : any
>类型别名 :=> 任意
>m5.isAlive : boolean
>类型别名 :=> 真假
>m5 : OverloadedMonster
>isAlive : boolean
>类型别名 :=> 真假
>toString : any
>类型别名 :=> 任意

class SplatMonster {
>SplatMonster : SplatMonster

    constructor(...args: string[]) { }
>args : string[]

    roar(name: string, ...args: number[]) { }
>roar : (name: string, ...args: number[]) => void
>name : string
>类型别名 :=> 文字
>args : number[]
}


function foo() { return true; }
>foo : () => boolean
>true : true
>类型别名 :=> 为真

class PrototypeMonster {
>PrototypeMonster : PrototypeMonster

    age: number = 1;
>age : number
>类型别名 :=> 数字
>1 : 1

    name: string;
>name : string
>类型别名 :=> 文字

    b = foo();
>b : boolean
>类型别名 :=> 真假
>foo() : boolean
>类型别名 :=> 真假
>foo : () => boolean
}

class SuperParent {
>SuperParent : SuperParent

    constructor(a: number) {
>a : number
>类型别名 :=> 数字

    }

    b(b: string) {
>b : (b: string) => void
>b : string
>类型别名 :=> 文字

    }

    c() {
>c : () => void

    }
}

class SuperChild extends SuperParent {
>SuperChild : SuperChild
>SuperParent : SuperParent

    constructor() {
        super(1);
>super(1) : void
>类型别名 :=> 无值
>super : typeof SuperParent
>1 : 1
    }

    b() {
>b : () => void

        super.b('str');
>super.b('str') : void
>类型别名 :=> 无值
>super.b : (b: string) => void
>super : SuperParent
>b : (b: string) => void
>'str' : "str"
    }

    c() {
>c : () => void

        super.c();
>super.c() : void
>类型别名 :=> 无值
>super.c : () => void
>super : SuperParent
>c : () => void
    }
}

class Statics {
>Statics : Statics

    static foo = 1;
>foo : number
>类型别名 :=> 数字
>1 : 1

    static bar: string;
>bar : string
>类型别名 :=> 文字

    static baz() {
>baz : () => string

        return "";
>"" : ""
    }
}

var stat = new Statics();
>stat : Statics
>new Statics() : Statics
>Statics : typeof Statics

interface IFoo {
>IFoo : IFoo

    x: number;
>x : number
>类型别名 :=> 数字

    z: string;
>z : string
>类型别名 :=> 文字
}

class ImplementsInterface implements IFoo {
>ImplementsInterface : ImplementsInterface
>IFoo : IFoo

    public x: number;
>x : number
>类型别名 :=> 数字

    public z: string;
>z : string
>类型别名 :=> 文字

    constructor() {
        this.x = 1;
>this.x = 1 : 1
>this.x : number
>类型别名 :=> 数字
>this : this
>x : number
>类型别名 :=> 数字
>1 : 1

        this.z = "foo";
>this.z = "foo" : "foo"
>this.z : string
>类型别名 :=> 文字
>this : this
>z : string
>类型别名 :=> 文字
>"foo" : "foo"
    }
}

class Visibility {
>Visibility : Visibility

    public foo() { }
>foo : () => void

    private bar() { }
>bar : () => void

    private x: number;
>x : number
>类型别名 :=> 数字

    public y: number;
>y : number
>类型别名 :=> 数字

    public z: number;
>z : number
>类型别名 :=> 数字

    constructor() {
        this.x = 1;
>this.x = 1 : 1
>this.x : number
>类型别名 :=> 数字
>this : this
>x : number
>类型别名 :=> 数字
>1 : 1

        this.y = 2;
>this.y = 2 : 2
>this.y : number
>类型别名 :=> 数字
>this : this
>y : number
>类型别名 :=> 数字
>2 : 2
    }
}

class BaseClassWithConstructor {
>BaseClassWithConstructor : BaseClassWithConstructor

    constructor(public x: number, public s: string) { }
>x : number
>类型别名 :=> 数字
>s : string
>类型别名 :=> 文字
}

// used to test codegen
class ChildClassWithoutConstructor extends BaseClassWithConstructor { }
>ChildClassWithoutConstructor : ChildClassWithoutConstructor
>BaseClassWithConstructor : BaseClassWithConstructor


var ccwc = new ChildClassWithoutConstructor(1, "s");
>ccwc : ChildClassWithoutConstructor
>new ChildClassWithoutConstructor(1, "s") : ChildClassWithoutConstructor
>ChildClassWithoutConstructor : typeof ChildClassWithoutConstructor
>1 : 1
>"s" : "s"


