=== tests/cases/compiler/narrowingConstrainedTypeParameter.ts ===
// Repro from #10811

interface Pet {
>Pet : Pet

    name: string;
>name : string
>类型别名 :=> 文字
}

function isPet(pet: any): pet is Pet {
>isPet : (pet: any) => pet is Pet
>pet : any
>类型别名 :=> 任意
>pet : any
>类型别名 :=> 任意
>Pet : Pet

    return typeof pet.name === "string";
>typeof pet.name === "string" : boolean
>类型别名 :=> 真假
>typeof pet.name : "string" | "number" | "boolean" | "symbol" | "undefined" | "object" | "function" | "文字" | "数字" | "真假" | "符号" | "未定" | "对象" | "函数"
>pet.name : any
>类型别名 :=> 任意
>pet : any
>类型别名 :=> 任意
>name : any
>类型别名 :=> 任意
>"string" : "string"
}

export function speak<TPet extends Pet>(pet: TPet, voice: (pet: TPet) => string): string {
>speak : <TPet extends Pet>(pet: TPet, voice: (pet: TPet) => string) => string
>TPet : TPet
>Pet : Pet
>pet : TPet
>TPet : TPet
>voice : (pet: TPet) => string
>pet : TPet
>TPet : TPet

    if (!isPet(pet)) {
>!isPet(pet) : boolean
>类型别名 :=> 真假
>isPet(pet) : boolean
>类型别名 :=> 真假
>isPet : (pet: any) => pet is Pet
>pet : TPet

        throw new Error("Expected \"pet\" to be a Pet");
>new Error("Expected \"pet\" to be a Pet") : Error
>Error : ErrorConstructor
>"Expected \"pet\" to be a Pet" : "Expected \"pet\" to be a Pet"
    }
    return voice(pet);
>voice(pet) : string
>类型别名 :=> 文字
>voice : (pet: TPet) => string
>pet : TPet
}
