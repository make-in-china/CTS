=== tests/cases/compiler/constIndexedAccess.ts ===
const enum numbers {
>numbers : numbers

    zero,
>zero : numbers.zero

    one
>one : numbers.one
}

interface indexAccess {
>indexAccess : indexAccess

    0: string;
    1: number;
}

let test: indexAccess;
>test : indexAccess
>indexAccess : indexAccess

let s = test[0];
>s : string
>类型别名 :=> 文字
>test[0] : string
>类型别名 :=> 文字
>test : indexAccess
>0 : 0

let n = test[1];
>n : number
>类型别名 :=> 数字
>test[1] : number
>类型别名 :=> 数字
>test : indexAccess
>1 : 1

let s1 = test[numbers.zero];
>s1 : string
>类型别名 :=> 文字
>test[numbers.zero] : string
>类型别名 :=> 文字
>test : indexAccess
>numbers.zero : numbers.zero
>numbers : typeof numbers
>zero : numbers.zero

let n1 = test[numbers.one];
>n1 : number
>类型别名 :=> 数字
>test[numbers.one] : number
>类型别名 :=> 数字
>test : indexAccess
>numbers.one : numbers.one
>numbers : typeof numbers
>one : numbers.one

let s2 = test[numbers["zero"]];
>s2 : string
>类型别名 :=> 文字
>test[numbers["zero"]] : string
>类型别名 :=> 文字
>test : indexAccess
>numbers["zero"] : numbers.zero
>numbers : typeof numbers
>"zero" : "zero"

let n2 = test[numbers["one"]];
>n2 : number
>类型别名 :=> 数字
>test[numbers["one"]] : number
>类型别名 :=> 数字
>test : indexAccess
>numbers["one"] : numbers.one
>numbers : typeof numbers
>"one" : "one"

enum numbersNotConst {
>numbersNotConst : numbersNotConst

    zero,
>zero : numbersNotConst.zero

    one
>one : numbersNotConst.one
}

let s3 = test[numbersNotConst.zero];
>s3 : string
>类型别名 :=> 文字
>test[numbersNotConst.zero] : string
>类型别名 :=> 文字
>test : indexAccess
>numbersNotConst.zero : numbersNotConst.zero
>numbersNotConst : typeof numbersNotConst
>zero : numbersNotConst.zero

let n3 = test[numbersNotConst.one];
>n3 : number
>类型别名 :=> 数字
>test[numbersNotConst.one] : number
>类型别名 :=> 数字
>test : indexAccess
>numbersNotConst.one : numbersNotConst.one
>numbersNotConst : typeof numbersNotConst
>one : numbersNotConst.one

