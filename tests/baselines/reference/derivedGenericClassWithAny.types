=== tests/cases/conformance/classes/members/inheritanceAndOverriding/derivedGenericClassWithAny.ts ===
class C<T extends number> {
>C : C<T>
>T : T

    x: T;
>x : T
>T : T

    get X(): T { return null; }
>X : T
>T : T
>null : null
>类型别名 :=> 空值

    foo(): T {
>foo : () => T
>T : T

        return null;
>null : null
>类型别名 :=> 空值
    }
}

class D extends C<number> {
>D : D
>C : C<number>

    x: any;
>x : any
>类型别名 :=> 任意

    get X(): any {
>X : any
>类型别名 :=> 任意

        return null;
>null : null
>类型别名 :=> 空值
    }
    foo(): any {
>foo : () => any

        return 1;
>1 : 1
    }

    static y: any;
>y : any
>类型别名 :=> 任意

    static get Y(): any {
>Y : any
>类型别名 :=> 任意

        return null;
>null : null
>类型别名 :=> 空值
    }
    static bar(): any {
>bar : () => any

        return null;
>null : null
>类型别名 :=> 空值
    }
}

// if D is a valid class definition than E is now not safe tranisitively through C
class E<T extends string> extends D {
>E : E<T>
>T : T
>D : D

    x: T;
>x : T
>T : T

    get X(): T { return ''; } // error
>X : T
>T : T
>'' : ""

    foo(): T {
>foo : () => T
>T : T

        return ''; // error
>'' : ""
    }
}

var c: C<number>;
>c : C<number>
>C : C<T>

var d: D;
>d : D
>D : D

var e: E<string>;
>e : E<string>
>E : E<T>

c = d;
>c = d : D
>c : C<number>
>d : D

c = e;
>c = e : E<string>
>c : C<number>
>e : E<string>

var r = c.foo(); // e.foo would return string
>r : number
>类型别名 :=> 数字
>c.foo() : number
>类型别名 :=> 数字
>c.foo : () => number
>c : C<number>
>foo : () => number

