=== tests/cases/conformance/classes/constructorDeclarations/constructorParameters/readonlyConstructorAssignment.ts ===
// Tests that readonly parameter properties behave like regular readonly properties

class A {
>A : A

    constructor(readonly x: number) {
>x : number
>类型别名 :=> 数字

        this.x = 0;
>this.x = 0 : 0
>this.x : number
>类型别名 :=> 数字
>this : this
>x : number
>类型别名 :=> 数字
>0 : 0
    }
}

class B extends A {
>B : B
>A : A

    constructor(x: number) {
>x : number
>类型别名 :=> 数字

        super(x);
>super(x) : void
>类型别名 :=> 无值
>super : typeof A
>x : number
>类型别名 :=> 数字

        // Fails, x is readonly
        this.x = 1;
>this.x = 1 : 1
>this.x : any
>类型别名 :=> 任意
>this : this
>x : any
>类型别名 :=> 任意
>1 : 1
    }
}

class C extends A {
>C : C
>A : A

    // This is the usual behavior of readonly properties:
    // if one is redeclared in a base class, then it can be assigned to.
    constructor(readonly x: number) {
>x : number
>类型别名 :=> 数字

        super(x);
>super(x) : void
>类型别名 :=> 无值
>super : typeof A
>x : number
>类型别名 :=> 数字

        this.x = 1;
>this.x = 1 : 1
>this.x : number
>类型别名 :=> 数字
>this : this
>x : number
>类型别名 :=> 数字
>1 : 1
    }
}

class D {
>D : D

    constructor(private readonly x: number) {
>x : number
>类型别名 :=> 数字

        this.x = 0;
>this.x = 0 : 0
>this.x : number
>类型别名 :=> 数字
>this : this
>x : number
>类型别名 :=> 数字
>0 : 0
    }
}

// Fails, can't redeclare readonly property
class E extends D {
>E : E
>D : D

    constructor(readonly x: number) {
>x : number
>类型别名 :=> 数字

        super(x);
>super(x) : void
>类型别名 :=> 无值
>super : typeof D
>x : number
>类型别名 :=> 数字

        this.x = 1;
>this.x = 1 : 1
>this.x : number
>类型别名 :=> 数字
>this : this
>x : number
>类型别名 :=> 数字
>1 : 1
    }
}

