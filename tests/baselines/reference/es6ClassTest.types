=== tests/cases/compiler/es6ClassTest.ts ===
class Bar {
>Bar : Bar

    public goo: number;
>goo : number
>类型别名 :=> 数字

    public prop1(x) {
>prop1 : (x: any) => any
>x : any
>类型别名 :=> 任意

        return x;
>x : any
>类型别名 :=> 任意
    }

    constructor (n) { }
>n : any
>类型别名 :=> 任意
}

// new-style class
class Foo  extends Bar {
>Foo : Foo
>Bar : Bar

	foo:number;
>foo : number
>类型别名 :=> 数字

	gar = 0;
>gar : number
>类型别名 :=> 数字
>0 : 0

	zoo:string = "zoo";
>zoo : string
>类型别名 :=> 文字
>"zoo" : "zoo"

	x: any;
>x : any
>类型别名 :=> 任意

	bar() { return 0; }
>bar : () => number
>0 : 0

	private boo();
>boo : () => any

	private boo(x?) { return x; }
>boo : () => any
>x : any
>类型别名 :=> 任意
>x : any
>类型别名 :=> 任意

    static statVal = 0;
>statVal : number
>类型别名 :=> 数字
>0 : 0

	constructor();
	constructor(x?, private y?:string, public z?=0) {
>x : any
>类型别名 :=> 任意
>y : string
>类型别名 :=> 文字
>z : number
>类型别名 :=> 数字
>0 : 0

        super(x);
>super(x) : void
>类型别名 :=> 无值
>super : typeof Bar
>x : any
>类型别名 :=> 任意

		this.x = x;
>this.x = x : any
>类型别名 :=> 任意
>this.x : any
>类型别名 :=> 任意
>this : this
>x : any
>类型别名 :=> 任意
>x : any
>类型别名 :=> 任意

        this.gar = 5;
>this.gar = 5 : 5
>this.gar : number
>类型别名 :=> 数字
>this : this
>gar : number
>类型别名 :=> 数字
>5 : 5
	 }
}

var f = new Foo();
>f : Foo
>new Foo() : Foo
>Foo : typeof Foo

declare module AmbientMod {
>AmbientMod : typeof AmbientMod

	export class Provide {
>Provide : Provide

		foo:number;
>foo : number
>类型别名 :=> 数字

		zoo:string;
>zoo : string
>类型别名 :=> 文字

		constructor();
		
		private boo();
>boo : () => any

		bar();
>bar : () => any
	}
}


//class GetSetMonster {


//  // attack(target) {
//  //     WScript.Echo("Attacks " + target);
//  // }
//  // The contextual keyword "get" followed by an identifier and
//  // a curly body defines a getter in the same way that "get"
//  // defines one in an object literal.
//  // get isAlive() {
//  //   return this.health > 0;
//  // }
 
//  // Likewise, "set" can be used to define setters.
//  set health(value:number) {
//    if (value < 0) {
//      throw new Error('Health must be non-negative.')
//    }
//    this.health = value
//  }
//  get health() { return 0; }

//  constructor(this.name: string, health: number) {
//    this.health = 0;
//  }
//}


//class bar {

//   static fnOverload( );

//   static fnOverload(foo: string){ } // no error

//   constructor(){};    

//}

