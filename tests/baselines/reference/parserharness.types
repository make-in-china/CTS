=== tests/cases/conformance/parser/ecmascript5/RealWorld/parserharness.ts ===
//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='..\compiler\io.ts'/>
///<reference path='..\compiler\typescript.ts'/>
///<reference path='..\services\typescriptServices.ts' />
///<reference path='diff.ts'/>

declare var assert: Harness.Assert;
>assert : any
>类型别名 :=> 任意
>Harness : any
>类型别名 :=> 任意
>Assert : No type information available!

declare var it;
>it : any
>类型别名 :=> 任意

declare var describe;
>describe : any
>类型别名 :=> 任意

declare var run;
>run : any
>类型别名 :=> 任意

declare var IO: IIO;
>IO : any
>类型别名 :=> 任意
>IIO : No type information available!

declare var __dirname; // Node-specific
>__dirname : any
>类型别名 :=> 任意

function switchToForwardSlashes(path: string) {
>switchToForwardSlashes : (path: string) => string
>path : string
>类型别名 :=> 文字

    return path.replace(/\\/g, "/");
>path.replace(/\\/g, "/") : string
>类型别名 :=> 文字
>path.replace : { (searchValue: string | RegExp, replaceValue: string): string; (searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string; }
>path : string
>类型别名 :=> 文字
>replace : { (searchValue: string | RegExp, replaceValue: string): string; (searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string; }
>/\\/g : RegExp
>"/" : "/"
}

function filePath(fullPath: string) {
>filePath : (fullPath: string) => string
>fullPath : string
>类型别名 :=> 文字

    fullPath = switchToForwardSlashes(fullPath);
>fullPath = switchToForwardSlashes(fullPath) : string
>类型别名 :=> 文字
>fullPath : string
>类型别名 :=> 文字
>switchToForwardSlashes(fullPath) : string
>类型别名 :=> 文字
>switchToForwardSlashes : (path: string) => string
>fullPath : string
>类型别名 :=> 文字

    var components = fullPath.split("/");
>components : string[]
>fullPath.split("/") : string[]
>fullPath.split : (separator: string | RegExp, limit?: number) => string[]
>fullPath : string
>类型别名 :=> 文字
>split : (separator: string | RegExp, limit?: number) => string[]
>"/" : "/"

    var path: string[] = components.slice(0, components.length - 1);
>path : string[]
>components.slice(0, components.length - 1) : string[]
>components.slice : (start?: number, end?: number) => string[]
>components : string[]
>slice : (start?: number, end?: number) => string[]
>0 : 0
>components.length - 1 : number
>类型别名 :=> 数字
>components.length : number
>类型别名 :=> 数字
>components : string[]
>length : number
>类型别名 :=> 数字
>1 : 1

    return path.join("/") + "/";
>path.join("/") + "/" : string
>类型别名 :=> 文字
>path.join("/") : string
>类型别名 :=> 文字
>path.join : (separator?: string) => string
>path : string[]
>join : (separator?: string) => string
>"/" : "/"
>"/" : "/"
}

var typescriptServiceFileName = filePath(IO.getExecutingFilePath()) + "typescriptServices.js";
>typescriptServiceFileName : string
>类型别名 :=> 文字
>filePath(IO.getExecutingFilePath()) + "typescriptServices.js" : string
>类型别名 :=> 文字
>filePath(IO.getExecutingFilePath()) : string
>类型别名 :=> 文字
>filePath : (fullPath: string) => string
>IO.getExecutingFilePath() : any
>类型别名 :=> 任意
>IO.getExecutingFilePath : any
>类型别名 :=> 任意
>IO : any
>类型别名 :=> 任意
>getExecutingFilePath : any
>类型别名 :=> 任意
>"typescriptServices.js" : "typescriptServices.js"

var typescriptServiceFile = IO.readFile(typescriptServiceFileName);
>typescriptServiceFile : any
>类型别名 :=> 任意
>IO.readFile(typescriptServiceFileName) : any
>类型别名 :=> 任意
>IO.readFile : any
>类型别名 :=> 任意
>IO : any
>类型别名 :=> 任意
>readFile : any
>类型别名 :=> 任意
>typescriptServiceFileName : string
>类型别名 :=> 文字

if (typeof ActiveXObject === "function") {
>typeof ActiveXObject === "function" : boolean
>类型别名 :=> 真假
>typeof ActiveXObject : "string" | "number" | "boolean" | "symbol" | "undefined" | "object" | "function" | "文字" | "数字" | "真假" | "符号" | "未定" | "对象" | "函数"
>ActiveXObject : any
>类型别名 :=> 任意
>"function" : "function"

    eval(typescriptServiceFile);
>eval(typescriptServiceFile) : any
>类型别名 :=> 任意
>eval : (x: string) => any
>typescriptServiceFile : any
>类型别名 :=> 任意

} else if (typeof require === "function") {
>typeof require === "function" : boolean
>类型别名 :=> 真假
>typeof require : "string" | "number" | "boolean" | "symbol" | "undefined" | "object" | "function" | "文字" | "数字" | "真假" | "符号" | "未定" | "对象" | "函数"
>require : any
>类型别名 :=> 任意
>"function" : "function"

    var vm = require('vm');
>vm : any
>类型别名 :=> 任意
>require('vm') : any
>类型别名 :=> 任意
>require : any
>类型别名 :=> 任意
>'vm' : "vm"

    vm.runInThisContext(typescriptServiceFile, 'typescriptServices.js');
>vm.runInThisContext(typescriptServiceFile, 'typescriptServices.js') : any
>类型别名 :=> 任意
>vm.runInThisContext : any
>类型别名 :=> 任意
>vm : any
>类型别名 :=> 任意
>runInThisContext : any
>类型别名 :=> 任意
>typescriptServiceFile : any
>类型别名 :=> 任意
>'typescriptServices.js' : "typescriptServices.js"

} else {
    throw new Error('Unknown context');
>new Error('Unknown context') : Error
>Error : ErrorConstructor
>'Unknown context' : "Unknown context"
}

declare module process {
>process : typeof process

    export function nextTick(callback: () => any): void;
>nextTick : (callback: () => any) => void
>callback : () => any

    export function on(event: string, listener: Function);
>on : (event: string, listener: Function) => any
>event : string
>类型别名 :=> 文字
>listener : Function
>Function : Function
}

module Harness {
>Harness : typeof Harness

    // Settings 
    export var userSpecifiedroot = "";
>userSpecifiedroot : string
>类型别名 :=> 文字
>"" : ""

    var global = <any>Function("return this").call(null);
>global : any
>类型别名 :=> 任意
><any>Function("return this").call(null) : any
>类型别名 :=> 任意
>Function("return this").call(null) : any
>类型别名 :=> 任意
>Function("return this").call : (this: Function, thisArg: any, ...argArray: any[]) => any
>Function("return this") : Function
>Function : FunctionConstructor
>"return this" : "return this"
>call : (this: Function, thisArg: any, ...argArray: any[]) => any
>null : null
>类型别名 :=> 空值

    export var usePull = false;
>usePull : boolean
>类型别名 :=> 真假
>false : false
>类型别名 :=> 为假

    export interface ITestMetadata {
>ITestMetadata : ITestMetadata

        id: string;
>id : string
>类型别名 :=> 文字

        desc: string;
>desc : string
>类型别名 :=> 文字

        pass: boolean;
>pass : boolean
>类型别名 :=> 真假

        perfResults: {
>perfResults : { mean: number; min: number; max: number; stdDev: number; trials: number[]; }

            mean: number;
>mean : number
>类型别名 :=> 数字

            min: number;
>min : number
>类型别名 :=> 数字

            max: number;
>max : number
>类型别名 :=> 数字

            stdDev: number;
>stdDev : number
>类型别名 :=> 数字

            trials: number[];
>trials : number[]

        };
    }
    export interface IScenarioMetadata {
>IScenarioMetadata : IScenarioMetadata

        id: string;
>id : string
>类型别名 :=> 文字

        desc: string;
>desc : string
>类型别名 :=> 文字

        pass: boolean;
>pass : boolean
>类型别名 :=> 真假

        bugs: string[];
>bugs : string[]
    }

    // Assert functions
    export module Assert {
>Assert : typeof Assert

        export var bugIds: string[] = [];
>bugIds : string[]
>[] : undefined[]

        export var throwAssertError = (error: Error) => {
>throwAssertError : (error: Error) => never
>(error: Error) => {            throw error;        } : (error: Error) => never
>error : Error
>Error : Error

            throw error;
>error : Error

        };

        // Marks that the current scenario is impacted by a bug
        export function bug(id: string) {
>bug : (id: string) => void
>id : string
>类型别名 :=> 文字

            if (bugIds.indexOf(id) < 0) {
>bugIds.indexOf(id) < 0 : boolean
>类型别名 :=> 真假
>bugIds.indexOf(id) : number
>类型别名 :=> 数字
>bugIds.indexOf : (searchElement: string, fromIndex?: number) => number
>bugIds : string[]
>indexOf : (searchElement: string, fromIndex?: number) => number
>id : string
>类型别名 :=> 文字
>0 : 0

                bugIds.push(id);
>bugIds.push(id) : number
>类型别名 :=> 数字
>bugIds.push : (...items: string[]) => number
>bugIds : string[]
>push : (...items: string[]) => number
>id : string
>类型别名 :=> 文字
            }
        }

        // If there are any bugs in the test code, mark the scenario as impacted appropriately
        export function bugs(content: string) {
>bugs : (content: string) => void
>content : string
>类型别名 :=> 文字

            var bugs = content.match(/\bbug (\d+)/i);
>bugs : RegExpMatchArray
>content.match(/\bbug (\d+)/i) : RegExpMatchArray
>content.match : (regexp: string | RegExp) => RegExpMatchArray
>content : string
>类型别名 :=> 文字
>match : (regexp: string | RegExp) => RegExpMatchArray
>/\bbug (\d+)/i : RegExp

            if (bugs) {
>bugs : RegExpMatchArray

                bugs.forEach(bug => assert.bug(bug));
>bugs.forEach(bug => assert.bug(bug)) : void
>类型别名 :=> 无值
>bugs.forEach : (callbackfn: (value: string, index: number, array: string[]) => void, thisArg?: any) => void
>bugs : RegExpMatchArray
>forEach : (callbackfn: (value: string, index: number, array: string[]) => void, thisArg?: any) => void
>bug => assert.bug(bug) : (bug: string) => any
>bug : string
>类型别名 :=> 文字
>assert.bug(bug) : any
>类型别名 :=> 任意
>assert.bug : any
>类型别名 :=> 任意
>assert : any
>类型别名 :=> 任意
>bug : any
>类型别名 :=> 任意
>bug : string
>类型别名 :=> 文字
            }
        }

        export function is(result: boolean, msg?: string) {
>is : (result: boolean, msg?: string) => void
>result : boolean
>类型别名 :=> 真假
>msg : string
>类型别名 :=> 文字

            if (!result) {
>!result : boolean
>类型别名 :=> 真假
>result : boolean
>类型别名 :=> 真假

                throwAssertError(new Error(msg || "Expected true, got false."));
>throwAssertError(new Error(msg || "Expected true, got false.")) : never
>类型别名 :=> 不及
>throwAssertError : (error: Error) => never
>new Error(msg || "Expected true, got false.") : Error
>Error : ErrorConstructor
>msg || "Expected true, got false." : string
>类型别名 :=> 文字
>msg : string
>类型别名 :=> 文字
>"Expected true, got false." : "Expected true, got false."
            }
        }

        export function arrayLengthIs(arr: any[], length: number) {
>arrayLengthIs : (arr: any[], length: number) => void
>arr : any[]
>length : number
>类型别名 :=> 数字

            if (arr.length != length) {
>arr.length != length : boolean
>类型别名 :=> 真假
>arr.length : number
>类型别名 :=> 数字
>arr : any[]
>length : number
>类型别名 :=> 数字
>length : number
>类型别名 :=> 数字

                var actual = '';
>actual : string
>类型别名 :=> 文字
>'' : ""

                arr.forEach(n => actual = actual + '\n      ' + n.toString());
>arr.forEach(n => actual = actual + '\n      ' + n.toString()) : void
>类型别名 :=> 无值
>arr.forEach : (callbackfn: (value: any, index: number, array: any[]) => void, thisArg?: any) => void
>arr : any[]
>forEach : (callbackfn: (value: any, index: number, array: any[]) => void, thisArg?: any) => void
>n => actual = actual + '\n      ' + n.toString() : (n: any) => string
>n : any
>类型别名 :=> 任意
>actual = actual + '\n      ' + n.toString() : string
>类型别名 :=> 文字
>actual : string
>类型别名 :=> 文字
>actual + '\n      ' + n.toString() : string
>类型别名 :=> 文字
>actual + '\n      ' : string
>类型别名 :=> 文字
>actual : string
>类型别名 :=> 文字
>'\n      ' : "\n      "
>n.toString() : any
>类型别名 :=> 任意
>n.toString : any
>类型别名 :=> 任意
>n : any
>类型别名 :=> 任意
>toString : any
>类型别名 :=> 任意

                throwAssertError(new Error('Expected array to have ' + length + ' elements. Actual elements were:' + actual));
>throwAssertError(new Error('Expected array to have ' + length + ' elements. Actual elements were:' + actual)) : never
>类型别名 :=> 不及
>throwAssertError : (error: Error) => never
>new Error('Expected array to have ' + length + ' elements. Actual elements were:' + actual) : Error
>Error : ErrorConstructor
>'Expected array to have ' + length + ' elements. Actual elements were:' + actual : string
>类型别名 :=> 文字
>'Expected array to have ' + length + ' elements. Actual elements were:' : string
>类型别名 :=> 文字
>'Expected array to have ' + length : string
>类型别名 :=> 文字
>'Expected array to have ' : "Expected array to have "
>length : number
>类型别名 :=> 数字
>' elements. Actual elements were:' : " elements. Actual elements were:"
>actual : string
>类型别名 :=> 文字
            }
        }

        export function equal(actual, expected) {
>equal : (actual: any, expected: any) => void
>actual : any
>类型别名 :=> 任意
>expected : any
>类型别名 :=> 任意

            if (actual !== expected) {
>actual !== expected : boolean
>类型别名 :=> 真假
>actual : any
>类型别名 :=> 任意
>expected : any
>类型别名 :=> 任意

                throwAssertError(new Error("Expected " + actual + " to equal " + expected));
>throwAssertError(new Error("Expected " + actual + " to equal " + expected)) : never
>类型别名 :=> 不及
>throwAssertError : (error: Error) => never
>new Error("Expected " + actual + " to equal " + expected) : Error
>Error : ErrorConstructor
>"Expected " + actual + " to equal " + expected : string
>类型别名 :=> 文字
>"Expected " + actual + " to equal " : string
>类型别名 :=> 文字
>"Expected " + actual : string
>类型别名 :=> 文字
>"Expected " : "Expected "
>actual : any
>类型别名 :=> 任意
>" to equal " : " to equal "
>expected : any
>类型别名 :=> 任意
            }
        }

        export function notEqual(actual, expected) {
>notEqual : (actual: any, expected: any) => void
>actual : any
>类型别名 :=> 任意
>expected : any
>类型别名 :=> 任意

            if (actual === expected) {
>actual === expected : boolean
>类型别名 :=> 真假
>actual : any
>类型别名 :=> 任意
>expected : any
>类型别名 :=> 任意

                throwAssertError(new Error("Expected " + actual + " to *not* equal " + expected));
>throwAssertError(new Error("Expected " + actual + " to *not* equal " + expected)) : never
>类型别名 :=> 不及
>throwAssertError : (error: Error) => never
>new Error("Expected " + actual + " to *not* equal " + expected) : Error
>Error : ErrorConstructor
>"Expected " + actual + " to *not* equal " + expected : string
>类型别名 :=> 文字
>"Expected " + actual + " to *not* equal " : string
>类型别名 :=> 文字
>"Expected " + actual : string
>类型别名 :=> 文字
>"Expected " : "Expected "
>actual : any
>类型别名 :=> 任意
>" to *not* equal " : " to *not* equal "
>expected : any
>类型别名 :=> 任意
            }
        }

        export function notNull(result) {
>notNull : (result: any) => void
>result : any
>类型别名 :=> 任意

            if (result === null) {
>result === null : boolean
>类型别名 :=> 真假
>result : any
>类型别名 :=> 任意
>null : null
>类型别名 :=> 空值

                throwAssertError(new Error("Expected " + result + " to *not* be null"));
>throwAssertError(new Error("Expected " + result + " to *not* be null")) : never
>类型别名 :=> 不及
>throwAssertError : (error: Error) => never
>new Error("Expected " + result + " to *not* be null") : Error
>Error : ErrorConstructor
>"Expected " + result + " to *not* be null" : string
>类型别名 :=> 文字
>"Expected " + result : string
>类型别名 :=> 文字
>"Expected " : "Expected "
>result : any
>类型别名 :=> 任意
>" to *not* be null" : " to *not* be null"
            }
        }

        export function compilerWarning(result: Compiler.CompilerResult, line: number, column: number, desc: string) {
>compilerWarning : (result: Compiler.CompilerResult, line: number, column: number, desc: string) => void
>result : Compiler.CompilerResult
>Compiler : any
>类型别名 :=> 任意
>CompilerResult : Compiler.CompilerResult
>line : number
>类型别名 :=> 数字
>column : number
>类型别名 :=> 数字
>desc : string
>类型别名 :=> 文字

            if (!result.isErrorAt(line, column, desc)) {
>!result.isErrorAt(line, column, desc) : boolean
>类型别名 :=> 真假
>result.isErrorAt(line, column, desc) : boolean
>类型别名 :=> 真假
>result.isErrorAt : (line: number, column: number, message: string) => boolean
>result : Compiler.CompilerResult
>isErrorAt : (line: number, column: number, message: string) => boolean
>line : number
>类型别名 :=> 数字
>column : number
>类型别名 :=> 数字
>desc : string
>类型别名 :=> 文字

                var actual = '';
>actual : string
>类型别名 :=> 文字
>'' : ""

                result.errors.forEach(err => {
>result.errors.forEach(err => {                    actual = actual + '\n     ' + err.toString();                }) : void
>类型别名 :=> 无值
>result.errors.forEach : (callbackfn: (value: Compiler.CompilerError, index: number, array: Compiler.CompilerError[]) => void, thisArg?: any) => void
>result.errors : Compiler.CompilerError[]
>result : Compiler.CompilerResult
>errors : Compiler.CompilerError[]
>forEach : (callbackfn: (value: Compiler.CompilerError, index: number, array: Compiler.CompilerError[]) => void, thisArg?: any) => void
>err => {                    actual = actual + '\n     ' + err.toString();                } : (err: Compiler.CompilerError) => void
>err : Compiler.CompilerError

                    actual = actual + '\n     ' + err.toString();
>actual = actual + '\n     ' + err.toString() : string
>类型别名 :=> 文字
>actual : string
>类型别名 :=> 文字
>actual + '\n     ' + err.toString() : string
>类型别名 :=> 文字
>actual + '\n     ' : string
>类型别名 :=> 文字
>actual : string
>类型别名 :=> 文字
>'\n     ' : "\n     "
>err.toString() : string
>类型别名 :=> 文字
>err.toString : () => string
>err : Compiler.CompilerError
>toString : () => string

                });

                throwAssertError(new Error("Expected compiler warning at (" + line + ", " + column + "): " + desc + "\nActual errors follow: " + actual));
>throwAssertError(new Error("Expected compiler warning at (" + line + ", " + column + "): " + desc + "\nActual errors follow: " + actual)) : never
>类型别名 :=> 不及
>throwAssertError : (error: Error) => never
>new Error("Expected compiler warning at (" + line + ", " + column + "): " + desc + "\nActual errors follow: " + actual) : Error
>Error : ErrorConstructor
>"Expected compiler warning at (" + line + ", " + column + "): " + desc + "\nActual errors follow: " + actual : string
>类型别名 :=> 文字
>"Expected compiler warning at (" + line + ", " + column + "): " + desc + "\nActual errors follow: " : string
>类型别名 :=> 文字
>"Expected compiler warning at (" + line + ", " + column + "): " + desc : string
>类型别名 :=> 文字
>"Expected compiler warning at (" + line + ", " + column + "): " : string
>类型别名 :=> 文字
>"Expected compiler warning at (" + line + ", " + column : string
>类型别名 :=> 文字
>"Expected compiler warning at (" + line + ", " : string
>类型别名 :=> 文字
>"Expected compiler warning at (" + line : string
>类型别名 :=> 文字
>"Expected compiler warning at (" : "Expected compiler warning at ("
>line : number
>类型别名 :=> 数字
>", " : ", "
>column : number
>类型别名 :=> 数字
>"): " : "): "
>desc : string
>类型别名 :=> 文字
>"\nActual errors follow: " : "\nActual errors follow: "
>actual : string
>类型别名 :=> 文字
            }
        }

        export function noDiff(text1, text2) {
>noDiff : (text1: any, text2: any) => void
>text1 : any
>类型别名 :=> 任意
>text2 : any
>类型别名 :=> 任意

            text1 = text1.replace(/^\s+|\s+$/g, "").replace(/\r\n?/g, "\n");
>text1 = text1.replace(/^\s+|\s+$/g, "").replace(/\r\n?/g, "\n") : any
>类型别名 :=> 任意
>text1 : any
>类型别名 :=> 任意
>text1.replace(/^\s+|\s+$/g, "").replace(/\r\n?/g, "\n") : any
>类型别名 :=> 任意
>text1.replace(/^\s+|\s+$/g, "").replace : any
>类型别名 :=> 任意
>text1.replace(/^\s+|\s+$/g, "") : any
>类型别名 :=> 任意
>text1.replace : any
>类型别名 :=> 任意
>text1 : any
>类型别名 :=> 任意
>replace : any
>类型别名 :=> 任意
>/^\s+|\s+$/g : RegExp
>"" : ""
>replace : any
>类型别名 :=> 任意
>/\r\n?/g : RegExp
>"\n" : "\n"

            text2 = text2.replace(/^\s+|\s+$/g, "").replace(/\r\n?/g, "\n");
>text2 = text2.replace(/^\s+|\s+$/g, "").replace(/\r\n?/g, "\n") : any
>类型别名 :=> 任意
>text2 : any
>类型别名 :=> 任意
>text2.replace(/^\s+|\s+$/g, "").replace(/\r\n?/g, "\n") : any
>类型别名 :=> 任意
>text2.replace(/^\s+|\s+$/g, "").replace : any
>类型别名 :=> 任意
>text2.replace(/^\s+|\s+$/g, "") : any
>类型别名 :=> 任意
>text2.replace : any
>类型别名 :=> 任意
>text2 : any
>类型别名 :=> 任意
>replace : any
>类型别名 :=> 任意
>/^\s+|\s+$/g : RegExp
>"" : ""
>replace : any
>类型别名 :=> 任意
>/\r\n?/g : RegExp
>"\n" : "\n"

            if (text1 !== text2) {
>text1 !== text2 : boolean
>类型别名 :=> 真假
>text1 : any
>类型别名 :=> 任意
>text2 : any
>类型别名 :=> 任意

                var errorString = "";
>errorString : string
>类型别名 :=> 文字
>"" : ""

                var text1Lines = text1.split(/\n/);
>text1Lines : any
>类型别名 :=> 任意
>text1.split(/\n/) : any
>类型别名 :=> 任意
>text1.split : any
>类型别名 :=> 任意
>text1 : any
>类型别名 :=> 任意
>split : any
>类型别名 :=> 任意
>/\n/ : RegExp

                var text2Lines = text2.split(/\n/);
>text2Lines : any
>类型别名 :=> 任意
>text2.split(/\n/) : any
>类型别名 :=> 任意
>text2.split : any
>类型别名 :=> 任意
>text2 : any
>类型别名 :=> 任意
>split : any
>类型别名 :=> 任意
>/\n/ : RegExp

                for (var i = 0; i < text1Lines.length; i++) {
>i : number
>类型别名 :=> 数字
>0 : 0
>i < text1Lines.length : boolean
>类型别名 :=> 真假
>i : number
>类型别名 :=> 数字
>text1Lines.length : any
>类型别名 :=> 任意
>text1Lines : any
>类型别名 :=> 任意
>length : any
>类型别名 :=> 任意
>i++ : number
>类型别名 :=> 数字
>i : number
>类型别名 :=> 数字

                    if (text1Lines[i] !== text2Lines[i]) {
>text1Lines[i] !== text2Lines[i] : boolean
>类型别名 :=> 真假
>text1Lines[i] : any
>类型别名 :=> 任意
>text1Lines : any
>类型别名 :=> 任意
>i : number
>类型别名 :=> 数字
>text2Lines[i] : any
>类型别名 :=> 任意
>text2Lines : any
>类型别名 :=> 任意
>i : number
>类型别名 :=> 数字

                        errorString += "Difference at line " + (i + 1) + ":\n";
>errorString += "Difference at line " + (i + 1) + ":\n" : string
>类型别名 :=> 文字
>errorString : string
>类型别名 :=> 文字
>"Difference at line " + (i + 1) + ":\n" : string
>类型别名 :=> 文字
>"Difference at line " + (i + 1) : string
>类型别名 :=> 文字
>"Difference at line " : "Difference at line "
>(i + 1) : number
>类型别名 :=> 数字
>i + 1 : number
>类型别名 :=> 数字
>i : number
>类型别名 :=> 数字
>1 : 1
>":\n" : ":\n"

                        errorString += "                  Left File: " + text1Lines[i] + "\n";
>errorString += "                  Left File: " + text1Lines[i] + "\n" : string
>类型别名 :=> 文字
>errorString : string
>类型别名 :=> 文字
>"                  Left File: " + text1Lines[i] + "\n" : string
>类型别名 :=> 文字
>"                  Left File: " + text1Lines[i] : string
>类型别名 :=> 文字
>"                  Left File: " : "                  Left File: "
>text1Lines[i] : any
>类型别名 :=> 任意
>text1Lines : any
>类型别名 :=> 任意
>i : number
>类型别名 :=> 数字
>"\n" : "\n"

                        errorString += "                 Right File: " + text2Lines[i] + "\n\n";
>errorString += "                 Right File: " + text2Lines[i] + "\n\n" : string
>类型别名 :=> 文字
>errorString : string
>类型别名 :=> 文字
>"                 Right File: " + text2Lines[i] + "\n\n" : string
>类型别名 :=> 文字
>"                 Right File: " + text2Lines[i] : string
>类型别名 :=> 文字
>"                 Right File: " : "                 Right File: "
>text2Lines[i] : any
>类型别名 :=> 任意
>text2Lines : any
>类型别名 :=> 任意
>i : number
>类型别名 :=> 数字
>"\n\n" : "\n\n"
                    }
                }
                throwAssertError(new Error(errorString));
>throwAssertError(new Error(errorString)) : never
>类型别名 :=> 不及
>throwAssertError : (error: Error) => never
>new Error(errorString) : Error
>Error : ErrorConstructor
>errorString : string
>类型别名 :=> 文字
            }
        }

        export function arrayContains(arr: any[], contains: any[]) {
>arrayContains : (arr: any[], contains: any[]) => void
>arr : any[]
>contains : any[]

            var found;
>found : any
>类型别名 :=> 任意

            for (var i = 0; i < contains.length; i++) {
>i : number
>类型别名 :=> 数字
>0 : 0
>i < contains.length : boolean
>类型别名 :=> 真假
>i : number
>类型别名 :=> 数字
>contains.length : number
>类型别名 :=> 数字
>contains : any[]
>length : number
>类型别名 :=> 数字
>i++ : number
>类型别名 :=> 数字
>i : number
>类型别名 :=> 数字

                found = false;
>found = false : false
>类型别名 :=> 为假
>found : any
>类型别名 :=> 任意
>false : false
>类型别名 :=> 为假

                for (var j = 0; j < arr.length; j++) {
>j : number
>类型别名 :=> 数字
>0 : 0
>j < arr.length : boolean
>类型别名 :=> 真假
>j : number
>类型别名 :=> 数字
>arr.length : number
>类型别名 :=> 数字
>arr : any[]
>length : number
>类型别名 :=> 数字
>j++ : number
>类型别名 :=> 数字
>j : number
>类型别名 :=> 数字

                    if (arr[j] === contains[i]) {
>arr[j] === contains[i] : boolean
>类型别名 :=> 真假
>arr[j] : any
>类型别名 :=> 任意
>arr : any[]
>j : number
>类型别名 :=> 数字
>contains[i] : any
>类型别名 :=> 任意
>contains : any[]
>i : number
>类型别名 :=> 数字

                        found = true;
>found = true : true
>类型别名 :=> 为真
>found : any
>类型别名 :=> 任意
>true : true
>类型别名 :=> 为真

                        break;
                    }
                }

                if (!found) {
>!found : boolean
>类型别名 :=> 真假
>found : any
>类型别名 :=> 任意

                    throwAssertError(new Error("Expected array to contain \"" + contains[i] + "\""));
>throwAssertError(new Error("Expected array to contain \"" + contains[i] + "\"")) : never
>类型别名 :=> 不及
>throwAssertError : (error: Error) => never
>new Error("Expected array to contain \"" + contains[i] + "\"") : Error
>Error : ErrorConstructor
>"Expected array to contain \"" + contains[i] + "\"" : string
>类型别名 :=> 文字
>"Expected array to contain \"" + contains[i] : string
>类型别名 :=> 文字
>"Expected array to contain \"" : "Expected array to contain \""
>contains[i] : any
>类型别名 :=> 任意
>contains : any[]
>i : number
>类型别名 :=> 数字
>"\"" : "\""
                }
            }
        }

        export function arrayContainsOnce(arr: any[], filter: (item: any) => boolean) {
>arrayContainsOnce : (arr: any[], filter: (item: any) => boolean) => void
>arr : any[]
>filter : (item: any) => boolean
>item : any
>类型别名 :=> 任意

            var foundCount = 0;
>foundCount : number
>类型别名 :=> 数字
>0 : 0

            for (var i = 0; i < arr.length; i++) {
>i : number
>类型别名 :=> 数字
>0 : 0
>i < arr.length : boolean
>类型别名 :=> 真假
>i : number
>类型别名 :=> 数字
>arr.length : number
>类型别名 :=> 数字
>arr : any[]
>length : number
>类型别名 :=> 数字
>i++ : number
>类型别名 :=> 数字
>i : number
>类型别名 :=> 数字

                if (filter(arr[i])) {
>filter(arr[i]) : boolean
>类型别名 :=> 真假
>filter : (item: any) => boolean
>arr[i] : any
>类型别名 :=> 任意
>arr : any[]
>i : number
>类型别名 :=> 数字

                    foundCount++;
>foundCount++ : number
>类型别名 :=> 数字
>foundCount : number
>类型别名 :=> 数字
                }
            }

            if (foundCount !== 1) {
>foundCount !== 1 : boolean
>类型别名 :=> 真假
>foundCount : number
>类型别名 :=> 数字
>1 : 1

                throwAssertError(new Error("Expected array to match element only once (instead of " + foundCount + " times)"));
>throwAssertError(new Error("Expected array to match element only once (instead of " + foundCount + " times)")) : never
>类型别名 :=> 不及
>throwAssertError : (error: Error) => never
>new Error("Expected array to match element only once (instead of " + foundCount + " times)") : Error
>Error : ErrorConstructor
>"Expected array to match element only once (instead of " + foundCount + " times)" : string
>类型别名 :=> 文字
>"Expected array to match element only once (instead of " + foundCount : string
>类型别名 :=> 文字
>"Expected array to match element only once (instead of " : "Expected array to match element only once (instead of "
>foundCount : number
>类型别名 :=> 数字
>" times)" : " times)"
            }
        }
    }

    /** Splits the given string on \r\n or on only \n if that fails */
    export function splitContentByNewlines(content: string) {
>splitContentByNewlines : (content: string) => string[]
>content : string
>类型别名 :=> 文字

        // Split up the input file by line
        // Note: IE JS engine incorrectly handles consecutive delimiters here when using RegExp split, so
        // we have to string-based splitting instead and try to figure out the delimiting chars
        var lines = content.split('\r\n');
>lines : string[]
>content.split('\r\n') : string[]
>content.split : (separator: string | RegExp, limit?: number) => string[]
>content : string
>类型别名 :=> 文字
>split : (separator: string | RegExp, limit?: number) => string[]
>'\r\n' : "\r\n"

        if (lines.length === 1) {
>lines.length === 1 : boolean
>类型别名 :=> 真假
>lines.length : number
>类型别名 :=> 数字
>lines : string[]
>length : number
>类型别名 :=> 数字
>1 : 1

            lines = content.split('\n');
>lines = content.split('\n') : string[]
>lines : string[]
>content.split('\n') : string[]
>content.split : (separator: string | RegExp, limit?: number) => string[]
>content : string
>类型别名 :=> 文字
>split : (separator: string | RegExp, limit?: number) => string[]
>'\n' : "\n"
        }
        return lines;
>lines : string[]
    }

    /** Reads a file under /tests */
    export function readFile(path: string) {
>readFile : (path: string) => any
>path : string
>类型别名 :=> 文字

        if (path.indexOf('tests') < 0) {
>path.indexOf('tests') < 0 : boolean
>类型别名 :=> 真假
>path.indexOf('tests') : number
>类型别名 :=> 数字
>path.indexOf : (searchString: string, position?: number) => number
>path : string
>类型别名 :=> 文字
>indexOf : (searchString: string, position?: number) => number
>'tests' : "tests"
>0 : 0

            path = "tests/" + path;
>path = "tests/" + path : string
>类型别名 :=> 文字
>path : string
>类型别名 :=> 文字
>"tests/" + path : string
>类型别名 :=> 文字
>"tests/" : "tests/"
>path : string
>类型别名 :=> 文字
        }

        var content = IO.readFile(Harness.userSpecifiedroot + path);
>content : any
>类型别名 :=> 任意
>IO.readFile(Harness.userSpecifiedroot + path) : any
>类型别名 :=> 任意
>IO.readFile : any
>类型别名 :=> 任意
>IO : any
>类型别名 :=> 任意
>readFile : any
>类型别名 :=> 任意
>Harness.userSpecifiedroot + path : string
>类型别名 :=> 文字
>Harness.userSpecifiedroot : string
>类型别名 :=> 文字
>Harness : typeof Harness
>userSpecifiedroot : string
>类型别名 :=> 文字
>path : string
>类型别名 :=> 文字

        if (content == null) {
>content == null : boolean
>类型别名 :=> 真假
>content : any
>类型别名 :=> 任意
>null : null
>类型别名 :=> 空值

            throw new Error("failed to read file at: '" + Harness.userSpecifiedroot + path + "'");
>new Error("failed to read file at: '" + Harness.userSpecifiedroot + path + "'") : Error
>Error : ErrorConstructor
>"failed to read file at: '" + Harness.userSpecifiedroot + path + "'" : string
>类型别名 :=> 文字
>"failed to read file at: '" + Harness.userSpecifiedroot + path : string
>类型别名 :=> 文字
>"failed to read file at: '" + Harness.userSpecifiedroot : string
>类型别名 :=> 文字
>"failed to read file at: '" : "failed to read file at: '"
>Harness.userSpecifiedroot : string
>类型别名 :=> 文字
>Harness : typeof Harness
>userSpecifiedroot : string
>类型别名 :=> 文字
>path : string
>类型别名 :=> 文字
>"'" : "'"
        }

        return content;
>content : any
>类型别名 :=> 任意
    }

    // Logger
    export interface ILogger {
>ILogger : ILogger

        start: (fileName?: string, priority?: number) => void;
>start : (fileName?: string, priority?: number) => void
>fileName : string
>类型别名 :=> 文字
>priority : number
>类型别名 :=> 数字

        end: (fileName?: string) => void;
>end : (fileName?: string) => void
>fileName : string
>类型别名 :=> 文字

        scenarioStart: (scenario: IScenarioMetadata) => void;
>scenarioStart : (scenario: IScenarioMetadata) => void
>scenario : IScenarioMetadata
>IScenarioMetadata : IScenarioMetadata

        scenarioEnd: (scenario: IScenarioMetadata, error?: Error) => void;
>scenarioEnd : (scenario: IScenarioMetadata, error?: Error) => void
>scenario : IScenarioMetadata
>IScenarioMetadata : IScenarioMetadata
>error : Error
>Error : Error

        testStart: (test: ITestMetadata) => void;
>testStart : (test: ITestMetadata) => void
>test : ITestMetadata
>ITestMetadata : ITestMetadata

        pass: (test: ITestMetadata) => void;
>pass : (test: ITestMetadata) => void
>test : ITestMetadata
>ITestMetadata : ITestMetadata

        bug: (test: ITestMetadata) => void;
>bug : (test: ITestMetadata) => void
>test : ITestMetadata
>ITestMetadata : ITestMetadata

        fail: (test: ITestMetadata) => void;
>fail : (test: ITestMetadata) => void
>test : ITestMetadata
>ITestMetadata : ITestMetadata

        error: (test: ITestMetadata, error: Error) => void;
>error : (test: ITestMetadata, error: Error) => void
>test : ITestMetadata
>ITestMetadata : ITestMetadata
>error : Error
>Error : Error

        comment: (comment: string) => void;
>comment : (comment: string) => void
>comment : string
>类型别名 :=> 文字

        verify: (test: ITestMetadata, passed: boolean, actual: any, expected: any, message: string) => void;
>verify : (test: ITestMetadata, passed: boolean, actual: any, expected: any, message: string) => void
>test : ITestMetadata
>ITestMetadata : ITestMetadata
>passed : boolean
>类型别名 :=> 真假
>actual : any
>类型别名 :=> 任意
>expected : any
>类型别名 :=> 任意
>message : string
>类型别名 :=> 文字
    }

    export class Logger implements ILogger {
>Logger : Logger
>ILogger : ILogger

        public start(fileName?: string, priority?: number) { }
>start : (fileName?: string, priority?: number) => void
>fileName : string
>类型别名 :=> 文字
>priority : number
>类型别名 :=> 数字

        public end(fileName?: string) { }
>end : (fileName?: string) => void
>fileName : string
>类型别名 :=> 文字

        public scenarioStart(scenario: IScenarioMetadata) { }
>scenarioStart : (scenario: IScenarioMetadata) => void
>scenario : IScenarioMetadata
>IScenarioMetadata : IScenarioMetadata

        public scenarioEnd(scenario: IScenarioMetadata, error?: Error) { }
>scenarioEnd : (scenario: IScenarioMetadata, error?: Error) => void
>scenario : IScenarioMetadata
>IScenarioMetadata : IScenarioMetadata
>error : Error
>Error : Error

        public testStart(test: ITestMetadata) { }
>testStart : (test: ITestMetadata) => void
>test : ITestMetadata
>ITestMetadata : ITestMetadata

        public pass(test: ITestMetadata) { }
>pass : (test: ITestMetadata) => void
>test : ITestMetadata
>ITestMetadata : ITestMetadata

        public bug(test: ITestMetadata) { }
>bug : (test: ITestMetadata) => void
>test : ITestMetadata
>ITestMetadata : ITestMetadata

        public fail(test: ITestMetadata) { }
>fail : (test: ITestMetadata) => void
>test : ITestMetadata
>ITestMetadata : ITestMetadata

        public error(test: ITestMetadata, error: Error) { }
>error : (test: ITestMetadata, error: Error) => void
>test : ITestMetadata
>ITestMetadata : ITestMetadata
>error : Error
>Error : Error

        public comment(comment: string) { }
>comment : (comment: string) => void
>comment : string
>类型别名 :=> 文字

        public verify(test: ITestMetadata, passed: boolean, actual: any, expected: any, message: string) { }
>verify : (test: ITestMetadata, passed: boolean, actual: any, expected: any, message: string) => void
>test : ITestMetadata
>ITestMetadata : ITestMetadata
>passed : boolean
>类型别名 :=> 真假
>actual : any
>类型别名 :=> 任意
>expected : any
>类型别名 :=> 任意
>message : string
>类型别名 :=> 文字
    }

    // Logger-related functions
    var loggers: ILogger[] = [];
>loggers : ILogger[]
>ILogger : ILogger
>[] : undefined[]

    export function registerLogger(logger: ILogger) {
>registerLogger : (logger: ILogger) => void
>logger : ILogger
>ILogger : ILogger

        loggers.push(logger);
>loggers.push(logger) : number
>类型别名 :=> 数字
>loggers.push : (...items: ILogger[]) => number
>loggers : ILogger[]
>push : (...items: ILogger[]) => number
>logger : ILogger
    }
    export function emitLog(field: string, ...params: any[]) {
>emitLog : (field: string, ...params: any[]) => void
>field : string
>类型别名 :=> 文字
>params : any[]

        for (var i = 0; i < loggers.length; i++) {
>i : number
>类型别名 :=> 数字
>0 : 0
>i < loggers.length : boolean
>类型别名 :=> 真假
>i : number
>类型别名 :=> 数字
>loggers.length : number
>类型别名 :=> 数字
>loggers : ILogger[]
>length : number
>类型别名 :=> 数字
>i++ : number
>类型别名 :=> 数字
>i : number
>类型别名 :=> 数字

            if (typeof loggers[i][field] === 'function') {
>typeof loggers[i][field] === 'function' : boolean
>类型别名 :=> 真假
>typeof loggers[i][field] : "string" | "number" | "boolean" | "symbol" | "undefined" | "object" | "function" | "文字" | "数字" | "真假" | "符号" | "未定" | "对象" | "函数"
>loggers[i][field] : any
>类型别名 :=> 任意
>loggers[i] : ILogger
>loggers : ILogger[]
>i : number
>类型别名 :=> 数字
>field : string
>类型别名 :=> 文字
>'function' : "function"

                loggers[i][field].apply(loggers[i], params);
>loggers[i][field].apply(loggers[i], params) : any
>类型别名 :=> 任意
>loggers[i][field].apply : any
>类型别名 :=> 任意
>loggers[i][field] : any
>类型别名 :=> 任意
>loggers[i] : ILogger
>loggers : ILogger[]
>i : number
>类型别名 :=> 数字
>field : string
>类型别名 :=> 文字
>apply : any
>类型别名 :=> 任意
>loggers[i] : ILogger
>loggers : ILogger[]
>i : number
>类型别名 :=> 数字
>params : any[]
            }
        }
    }

    // BDD Framework
    export interface IDone {
>IDone : IDone

        (e?: Error): void;
>e : Error
>Error : Error
    }
    export class Runnable {
>Runnable : Runnable

        constructor(public description: string, public block: any) { }
>description : string
>类型别名 :=> 文字
>block : any
>类型别名 :=> 任意

        // The current stack of Runnable objects
        static currentStack: Runnable[] = [];
>currentStack : Runnable[]
>Runnable : Runnable
>[] : undefined[]

        // The error, if any, that occurred when running 'block'
        public error: Error = null;
>error : Error
>Error : Error
>null : null
>类型别名 :=> 空值

        // Whether or not this object has any failures (including in its descendants)
        public passed = null;
>passed : any
>类型别名 :=> 任意
>null : null
>类型别名 :=> 空值

        // A list of bugs impacting this object
        public bugs: string[] = [];
>bugs : string[]
>[] : undefined[]

        // A list of all our child Runnables
        public children: Runnable[] = [];
>children : Runnable[]
>Runnable : Runnable
>[] : undefined[]

        public addChild(child: Runnable): void {
>addChild : (child: Runnable) => void
>child : Runnable
>Runnable : Runnable

            this.children.push(child);
>this.children.push(child) : number
>类型别名 :=> 数字
>this.children.push : (...items: Runnable[]) => number
>this.children : Runnable[]
>this : this
>children : Runnable[]
>push : (...items: Runnable[]) => number
>child : Runnable
        }

        /** Call function fn, which may take a done function and may possibly execute
         *  asynchronously, calling done when finished. Returns true or false depending
         *  on whether the function was asynchronous or not.
         */
        public call(fn: (done?: IDone) => void , done: IDone) {
>call : (fn: (done?: IDone) => void, done: IDone) => boolean
>fn : (done?: IDone) => void
>done : IDone
>IDone : IDone
>done : IDone
>IDone : IDone

            var isAsync = true;
>isAsync : boolean
>类型别名 :=> 真假
>true : true
>类型别名 :=> 为真

            try {
                if (fn.length === 0) {
>fn.length === 0 : boolean
>类型别名 :=> 真假
>fn.length : number
>类型别名 :=> 数字
>fn : (done?: IDone) => void
>length : number
>类型别名 :=> 数字
>0 : 0

                    // No async.
                    fn();
>fn() : void
>类型别名 :=> 无值
>fn : (done?: IDone) => void

                    done();
>done() : void
>类型别名 :=> 无值
>done : IDone

                    return false;
>false : false
>类型别名 :=> 为假

                } else {
                    // Possibly async

                    Runnable.pushGlobalErrorHandler(done);
>Runnable.pushGlobalErrorHandler(done) : void
>类型别名 :=> 无值
>Runnable.pushGlobalErrorHandler : (done: IDone) => void
>Runnable : typeof Runnable
>pushGlobalErrorHandler : (done: IDone) => void
>done : IDone

                    fn(function () {
>fn(function () {                        isAsync = false; // If we execute synchronously, this will get called before the return below.                        Runnable.popGlobalErrorHandler();                        done();                    }) : void
>类型别名 :=> 无值
>fn : (done?: IDone) => void
>function () {                        isAsync = false; // If we execute synchronously, this will get called before the return below.                        Runnable.popGlobalErrorHandler();                        done();                    } : () => void

                        isAsync = false; // If we execute synchronously, this will get called before the return below.
>isAsync = false : false
>类型别名 :=> 为假
>isAsync : boolean
>类型别名 :=> 真假
>false : false
>类型别名 :=> 为假

                        Runnable.popGlobalErrorHandler();
>Runnable.popGlobalErrorHandler() : void
>类型别名 :=> 无值
>Runnable.popGlobalErrorHandler : () => void
>Runnable : typeof Runnable
>popGlobalErrorHandler : () => void

                        done();
>done() : void
>类型别名 :=> 无值
>done : IDone

                    });

                    return isAsync;
>isAsync : true
>类型别名 :=> 为真
                }

            } catch (e) {
>e : any
>类型别名 :=> 任意

                done(e);
>done(e) : void
>类型别名 :=> 无值
>done : IDone
>e : any
>类型别名 :=> 任意

                return false;
>false : false
>类型别名 :=> 为假
            }
        }

        public run(done: IDone) { }
>run : (done: IDone) => void
>done : IDone
>IDone : IDone

        public runBlock(done: IDone) {
>runBlock : (done: IDone) => boolean
>done : IDone
>IDone : IDone

            return this.call(this.block, done);
>this.call(this.block, done) : boolean
>类型别名 :=> 真假
>this.call : (fn: (done?: IDone) => void, done: IDone) => boolean
>this : this
>call : (fn: (done?: IDone) => void, done: IDone) => boolean
>this.block : any
>类型别名 :=> 任意
>this : this
>block : any
>类型别名 :=> 任意
>done : IDone
        }

        public runChild(index: number, done: IDone) {
>runChild : (index: number, done: IDone) => boolean
>index : number
>类型别名 :=> 数字
>done : IDone
>IDone : IDone

            return this.call(<any>((done) => this.children[index].run(done)), done);
>this.call(<any>((done) => this.children[index].run(done)), done) : boolean
>类型别名 :=> 真假
>this.call : (fn: (done?: IDone) => void, done: IDone) => boolean
>this : this
>call : (fn: (done?: IDone) => void, done: IDone) => boolean
><any>((done) => this.children[index].run(done)) : any
>类型别名 :=> 任意
>((done) => this.children[index].run(done)) : (done: any) => void
>(done) => this.children[index].run(done) : (done: any) => void
>done : any
>类型别名 :=> 任意
>this.children[index].run(done) : void
>类型别名 :=> 无值
>this.children[index].run : (done: IDone) => void
>this.children[index] : Runnable
>this.children : Runnable[]
>this : this
>children : Runnable[]
>index : number
>类型别名 :=> 数字
>run : (done: IDone) => void
>done : any
>类型别名 :=> 任意
>done : IDone
        }

        static errorHandlerStack: { (e: Error): void; }[] = [];
>errorHandlerStack : ((e: Error) => void)[]
>e : Error
>Error : Error
>[] : undefined[]

        static pushGlobalErrorHandler(done: IDone) {
>pushGlobalErrorHandler : (done: IDone) => void
>done : IDone
>IDone : IDone

            errorHandlerStack.push(function (e) {
>errorHandlerStack.push(function (e) {                done(e);            }) : any
>类型别名 :=> 任意
>errorHandlerStack.push : any
>类型别名 :=> 任意
>errorHandlerStack : any
>类型别名 :=> 任意
>push : any
>类型别名 :=> 任意
>function (e) {                done(e);            } : (e: any) => void
>e : any
>类型别名 :=> 任意

                done(e);
>done(e) : void
>类型别名 :=> 无值
>done : IDone
>e : any
>类型别名 :=> 任意

            });
        }

        static popGlobalErrorHandler() {
>popGlobalErrorHandler : () => void

            errorHandlerStack.pop();
>errorHandlerStack.pop() : any
>类型别名 :=> 任意
>errorHandlerStack.pop : any
>类型别名 :=> 任意
>errorHandlerStack : any
>类型别名 :=> 任意
>pop : any
>类型别名 :=> 任意
        }

        static handleError(e: Error) {
>handleError : (e: Error) => void
>e : Error
>Error : Error

            if (errorHandlerStack.length === 0) {
>errorHandlerStack.length === 0 : boolean
>类型别名 :=> 真假
>errorHandlerStack.length : any
>类型别名 :=> 任意
>errorHandlerStack : any
>类型别名 :=> 任意
>length : any
>类型别名 :=> 任意
>0 : 0

                IO.printLine('Global error: ' + e);
>IO.printLine('Global error: ' + e) : any
>类型别名 :=> 任意
>IO.printLine : any
>类型别名 :=> 任意
>IO : any
>类型别名 :=> 任意
>printLine : any
>类型别名 :=> 任意
>'Global error: ' + e : string
>类型别名 :=> 文字
>'Global error: ' : "Global error: "
>e : Error

            } else {
                errorHandlerStack[errorHandlerStack.length - 1](e);
>errorHandlerStack[errorHandlerStack.length - 1](e) : any
>类型别名 :=> 任意
>errorHandlerStack[errorHandlerStack.length - 1] : any
>类型别名 :=> 任意
>errorHandlerStack : any
>类型别名 :=> 任意
>errorHandlerStack.length - 1 : number
>类型别名 :=> 数字
>errorHandlerStack.length : any
>类型别名 :=> 任意
>errorHandlerStack : any
>类型别名 :=> 任意
>length : any
>类型别名 :=> 任意
>1 : 1
>e : Error
            }
        }
    }
    export class TestCase extends Runnable {
>TestCase : TestCase
>Runnable : Runnable

        public description: string;
>description : string
>类型别名 :=> 文字

        public block;
>block : any
>类型别名 :=> 任意

        constructor(description: string, block: any) {
>description : string
>类型别名 :=> 文字
>block : any
>类型别名 :=> 任意

            super(description, block);
>super(description, block) : void
>类型别名 :=> 无值
>super : typeof Runnable
>description : string
>类型别名 :=> 文字
>block : any
>类型别名 :=> 任意

            this.description = description;
>this.description = description : string
>类型别名 :=> 文字
>this.description : string
>类型别名 :=> 文字
>this : this
>description : string
>类型别名 :=> 文字
>description : string
>类型别名 :=> 文字

            this.block = block;
>this.block = block : any
>类型别名 :=> 任意
>this.block : any
>类型别名 :=> 任意
>this : this
>block : any
>类型别名 :=> 任意
>block : any
>类型别名 :=> 任意
        }

        public addChild(child: Runnable): void {
>addChild : (child: Runnable) => void
>child : Runnable
>Runnable : Runnable

            throw new Error("Testcases may not be nested inside other testcases");
>new Error("Testcases may not be nested inside other testcases") : Error
>Error : ErrorConstructor
>"Testcases may not be nested inside other testcases" : "Testcases may not be nested inside other testcases"
        }

        /** Run the test case block and fail the test if it raised an error. If no error is raised, the test passes. */
        public run(done: IDone) {
>run : (done: IDone) => void
>done : IDone
>IDone : IDone

            var that = this;
>that : this
>this : this

            Runnable.currentStack.push(this);
>Runnable.currentStack.push(this) : number
>类型别名 :=> 数字
>Runnable.currentStack.push : (...items: Runnable[]) => number
>Runnable.currentStack : Runnable[]
>Runnable : typeof Runnable
>currentStack : Runnable[]
>push : (...items: Runnable[]) => number
>this : this

            emitLog('testStart', { desc: this.description });
>emitLog('testStart', { desc: this.description }) : void
>类型别名 :=> 无值
>emitLog : (field: string, ...params: any[]) => void
>'testStart' : "testStart"
>{ desc: this.description } : { desc: string; }
>desc : string
>类型别名 :=> 文字
>this.description : string
>类型别名 :=> 文字
>this : this
>description : string
>类型别名 :=> 文字

            if (this.block) {
>this.block : any
>类型别名 :=> 任意
>this : this
>block : any
>类型别名 :=> 任意

                var async = this.runBlock(<any>function (e) {
>async : boolean
>类型别名 :=> 真假
>this.runBlock(<any>function (e) {                    if (e) {                        that.passed = false;                        that.error = e;                        emitLog('error', { desc: this.description, pass: false }, e);                    } else {                        that.passed = true;                        emitLog('pass', { desc: this.description, pass: true });                    }                    Runnable.currentStack.pop();                    done()                }) : boolean
>类型别名 :=> 真假
>this.runBlock : (done: IDone) => boolean
>this : this
>runBlock : (done: IDone) => boolean
><any>function (e) {                    if (e) {                        that.passed = false;                        that.error = e;                        emitLog('error', { desc: this.description, pass: false }, e);                    } else {                        that.passed = true;                        emitLog('pass', { desc: this.description, pass: true });                    }                    Runnable.currentStack.pop();                    done()                } : any
>类型别名 :=> 任意
>function (e) {                    if (e) {                        that.passed = false;                        that.error = e;                        emitLog('error', { desc: this.description, pass: false }, e);                    } else {                        that.passed = true;                        emitLog('pass', { desc: this.description, pass: true });                    }                    Runnable.currentStack.pop();                    done()                } : (e: any) => void
>e : any
>类型别名 :=> 任意

                    if (e) {
>e : any
>类型别名 :=> 任意

                        that.passed = false;
>that.passed = false : false
>类型别名 :=> 为假
>that.passed : any
>类型别名 :=> 任意
>that : this
>passed : any
>类型别名 :=> 任意
>false : false
>类型别名 :=> 为假

                        that.error = e;
>that.error = e : any
>类型别名 :=> 任意
>that.error : Error
>that : this
>error : Error
>e : any
>类型别名 :=> 任意

                        emitLog('error', { desc: this.description, pass: false }, e);
>emitLog('error', { desc: this.description, pass: false }, e) : void
>类型别名 :=> 无值
>emitLog : (field: string, ...params: any[]) => void
>'error' : "error"
>{ desc: this.description, pass: false } : { desc: any; pass: boolean; }
>desc : any
>类型别名 :=> 任意
>this.description : any
>类型别名 :=> 任意
>this : any
>类型别名 :=> 任意
>description : any
>类型别名 :=> 任意
>pass : boolean
>类型别名 :=> 真假
>false : false
>类型别名 :=> 为假
>e : any
>类型别名 :=> 任意

                    } else {
                        that.passed = true;
>that.passed = true : true
>类型别名 :=> 为真
>that.passed : any
>类型别名 :=> 任意
>that : this
>passed : any
>类型别名 :=> 任意
>true : true
>类型别名 :=> 为真

                        emitLog('pass', { desc: this.description, pass: true });
>emitLog('pass', { desc: this.description, pass: true }) : void
>类型别名 :=> 无值
>emitLog : (field: string, ...params: any[]) => void
>'pass' : "pass"
>{ desc: this.description, pass: true } : { desc: any; pass: boolean; }
>desc : any
>类型别名 :=> 任意
>this.description : any
>类型别名 :=> 任意
>this : any
>类型别名 :=> 任意
>description : any
>类型别名 :=> 任意
>pass : boolean
>类型别名 :=> 真假
>true : true
>类型别名 :=> 为真
                    }

                    Runnable.currentStack.pop();
>Runnable.currentStack.pop() : Runnable
>Runnable.currentStack.pop : () => Runnable
>Runnable.currentStack : Runnable[]
>Runnable : typeof Runnable
>currentStack : Runnable[]
>pop : () => Runnable

                    done()
>done() : void
>类型别名 :=> 无值
>done : IDone

                });
            }

        }
    }

    export class Scenario extends Runnable {
>Scenario : Scenario
>Runnable : Runnable

        public description: string;
>description : string
>类型别名 :=> 文字

        public block;
>block : any
>类型别名 :=> 任意

        constructor(description: string, block: any) {
>description : string
>类型别名 :=> 文字
>block : any
>类型别名 :=> 任意

            super(description, block);
>super(description, block) : void
>类型别名 :=> 无值
>super : typeof Runnable
>description : string
>类型别名 :=> 文字
>block : any
>类型别名 :=> 任意

            this.description = description;
>this.description = description : string
>类型别名 :=> 文字
>this.description : string
>类型别名 :=> 文字
>this : this
>description : string
>类型别名 :=> 文字
>description : string
>类型别名 :=> 文字

            this.block = block;
>this.block = block : any
>类型别名 :=> 任意
>this.block : any
>类型别名 :=> 任意
>this : this
>block : any
>类型别名 :=> 任意
>block : any
>类型别名 :=> 任意
        }

        /** Run the block, and if the block doesn't raise an error, run the children. */
        public run(done: IDone) {
>run : (done: IDone) => void
>done : IDone
>IDone : IDone

            var that = this;
>that : this
>this : this

            Runnable.currentStack.push(this);
>Runnable.currentStack.push(this) : number
>类型别名 :=> 数字
>Runnable.currentStack.push : (...items: Runnable[]) => number
>Runnable.currentStack : Runnable[]
>Runnable : typeof Runnable
>currentStack : Runnable[]
>push : (...items: Runnable[]) => number
>this : this

            emitLog('scenarioStart', { desc: this.description });
>emitLog('scenarioStart', { desc: this.description }) : void
>类型别名 :=> 无值
>emitLog : (field: string, ...params: any[]) => void
>'scenarioStart' : "scenarioStart"
>{ desc: this.description } : { desc: string; }
>desc : string
>类型别名 :=> 文字
>this.description : string
>类型别名 :=> 文字
>this : this
>description : string
>类型别名 :=> 文字

            var async = this.runBlock(<any>function (e) {
>async : boolean
>类型别名 :=> 真假
>this.runBlock(<any>function (e) {                Runnable.currentStack.pop();                if (e) {                    that.passed = false;                    that.error = e;                    var metadata: IScenarioMetadata = { id: undefined, desc: this.description, pass: false, bugs: assert.bugIds };                    // Report all bugs affecting this scenario                    assert.bugIds.forEach(desc => emitLog('bug', metadata, desc));                    emitLog('scenarioEnd', metadata, e);                    done();                } else {                    that.passed = true; // so far so good.                    that.runChildren(done);                }            }) : boolean
>类型别名 :=> 真假
>this.runBlock : (done: IDone) => boolean
>this : this
>runBlock : (done: IDone) => boolean
><any>function (e) {                Runnable.currentStack.pop();                if (e) {                    that.passed = false;                    that.error = e;                    var metadata: IScenarioMetadata = { id: undefined, desc: this.description, pass: false, bugs: assert.bugIds };                    // Report all bugs affecting this scenario                    assert.bugIds.forEach(desc => emitLog('bug', metadata, desc));                    emitLog('scenarioEnd', metadata, e);                    done();                } else {                    that.passed = true; // so far so good.                    that.runChildren(done);                }            } : any
>类型别名 :=> 任意
>function (e) {                Runnable.currentStack.pop();                if (e) {                    that.passed = false;                    that.error = e;                    var metadata: IScenarioMetadata = { id: undefined, desc: this.description, pass: false, bugs: assert.bugIds };                    // Report all bugs affecting this scenario                    assert.bugIds.forEach(desc => emitLog('bug', metadata, desc));                    emitLog('scenarioEnd', metadata, e);                    done();                } else {                    that.passed = true; // so far so good.                    that.runChildren(done);                }            } : (e: any) => void
>e : any
>类型别名 :=> 任意

                Runnable.currentStack.pop();
>Runnable.currentStack.pop() : Runnable
>Runnable.currentStack.pop : () => Runnable
>Runnable.currentStack : Runnable[]
>Runnable : typeof Runnable
>currentStack : Runnable[]
>pop : () => Runnable

                if (e) {
>e : any
>类型别名 :=> 任意

                    that.passed = false;
>that.passed = false : false
>类型别名 :=> 为假
>that.passed : any
>类型别名 :=> 任意
>that : this
>passed : any
>类型别名 :=> 任意
>false : false
>类型别名 :=> 为假

                    that.error = e;
>that.error = e : any
>类型别名 :=> 任意
>that.error : Error
>that : this
>error : Error
>e : any
>类型别名 :=> 任意

                    var metadata: IScenarioMetadata = { id: undefined, desc: this.description, pass: false, bugs: assert.bugIds };
>metadata : IScenarioMetadata
>IScenarioMetadata : IScenarioMetadata
>{ id: undefined, desc: this.description, pass: false, bugs: assert.bugIds } : { id: undefined; desc: any; pass: false; bugs: any; }
>id : undefined
>类型别名 :=> 未定
>undefined : undefined
>类型别名 :=> 未定
>desc : any
>类型别名 :=> 任意
>this.description : any
>类型别名 :=> 任意
>this : any
>类型别名 :=> 任意
>description : any
>类型别名 :=> 任意
>pass : boolean
>类型别名 :=> 真假
>false : false
>类型别名 :=> 为假
>bugs : any
>类型别名 :=> 任意
>assert.bugIds : any
>类型别名 :=> 任意
>assert : any
>类型别名 :=> 任意
>bugIds : any
>类型别名 :=> 任意

                    // Report all bugs affecting this scenario
                    assert.bugIds.forEach(desc => emitLog('bug', metadata, desc));
>assert.bugIds.forEach(desc => emitLog('bug', metadata, desc)) : any
>类型别名 :=> 任意
>assert.bugIds.forEach : any
>类型别名 :=> 任意
>assert.bugIds : any
>类型别名 :=> 任意
>assert : any
>类型别名 :=> 任意
>bugIds : any
>类型别名 :=> 任意
>forEach : any
>类型别名 :=> 任意
>desc => emitLog('bug', metadata, desc) : (desc: any) => void
>desc : any
>类型别名 :=> 任意
>emitLog('bug', metadata, desc) : void
>类型别名 :=> 无值
>emitLog : (field: string, ...params: any[]) => void
>'bug' : "bug"
>metadata : IScenarioMetadata
>desc : any
>类型别名 :=> 任意

                    emitLog('scenarioEnd', metadata, e);
>emitLog('scenarioEnd', metadata, e) : void
>类型别名 :=> 无值
>emitLog : (field: string, ...params: any[]) => void
>'scenarioEnd' : "scenarioEnd"
>metadata : IScenarioMetadata
>e : any
>类型别名 :=> 任意

                    done();
>done() : void
>类型别名 :=> 无值
>done : IDone

                } else {
                    that.passed = true; // so far so good.
>that.passed = true : true
>类型别名 :=> 为真
>that.passed : any
>类型别名 :=> 任意
>that : this
>passed : any
>类型别名 :=> 任意
>true : true
>类型别名 :=> 为真

                    that.runChildren(done);
>that.runChildren(done) : void
>类型别名 :=> 无值
>that.runChildren : (done: IDone, index?: number) => void
>that : this
>runChildren : (done: IDone, index?: number) => void
>done : IDone
                }
            });
        }

        /** Run the children of the scenario (other scenarios and test cases). If any fail,
         *  set this scenario to failed. Synchronous tests will run synchronously without
         *  adding stack frames.
         */
        public runChildren(done: IDone, index = 0) {
>runChildren : (done: IDone, index?: number) => void
>done : IDone
>IDone : IDone
>index : number
>类型别名 :=> 数字
>0 : 0

            var that = this;
>that : this
>this : this

            var async = false;
>async : boolean
>类型别名 :=> 真假
>false : false
>类型别名 :=> 为假

            for (; index < this.children.length; index++) {
>index < this.children.length : boolean
>类型别名 :=> 真假
>index : number
>类型别名 :=> 数字
>this.children.length : number
>类型别名 :=> 数字
>this.children : Runnable[]
>this : this
>children : Runnable[]
>length : number
>类型别名 :=> 数字
>index++ : number
>类型别名 :=> 数字
>index : number
>类型别名 :=> 数字

                async = this.runChild(index, <any>function (e) {
>async = this.runChild(index, <any>function (e) {                    that.passed = that.passed && that.children[index].passed;                    if (async)                        that.runChildren(done, index + 1);                }) : boolean
>类型别名 :=> 真假
>async : boolean
>类型别名 :=> 真假
>this.runChild(index, <any>function (e) {                    that.passed = that.passed && that.children[index].passed;                    if (async)                        that.runChildren(done, index + 1);                }) : boolean
>类型别名 :=> 真假
>this.runChild : (index: number, done: IDone) => boolean
>this : this
>runChild : (index: number, done: IDone) => boolean
>index : number
>类型别名 :=> 数字
><any>function (e) {                    that.passed = that.passed && that.children[index].passed;                    if (async)                        that.runChildren(done, index + 1);                } : any
>类型别名 :=> 任意
>function (e) {                    that.passed = that.passed && that.children[index].passed;                    if (async)                        that.runChildren(done, index + 1);                } : (e: any) => void
>e : any
>类型别名 :=> 任意

                    that.passed = that.passed && that.children[index].passed;
>that.passed = that.passed && that.children[index].passed : any
>类型别名 :=> 任意
>that.passed : any
>类型别名 :=> 任意
>that : this
>passed : any
>类型别名 :=> 任意
>that.passed && that.children[index].passed : any
>类型别名 :=> 任意
>that.passed : any
>类型别名 :=> 任意
>that : this
>passed : any
>类型别名 :=> 任意
>that.children[index].passed : any
>类型别名 :=> 任意
>that.children[index] : Runnable
>that.children : Runnable[]
>that : this
>children : Runnable[]
>index : number
>类型别名 :=> 数字
>passed : any
>类型别名 :=> 任意

                    if (async)
>async : boolean
>类型别名 :=> 真假

                        that.runChildren(done, index + 1);
>that.runChildren(done, index + 1) : void
>类型别名 :=> 无值
>that.runChildren : (done: IDone, index?: number) => void
>that : this
>runChildren : (done: IDone, index?: number) => void
>done : IDone
>index + 1 : number
>类型别名 :=> 数字
>index : number
>类型别名 :=> 数字
>1 : 1

                });

                if (async)
>async : boolean
>类型别名 :=> 真假

                    return;
            }

            var metadata: IScenarioMetadata = { id: undefined, desc: this.description, pass: this.passed, bugs: assert.bugIds };
>metadata : IScenarioMetadata
>IScenarioMetadata : IScenarioMetadata
>{ id: undefined, desc: this.description, pass: this.passed, bugs: assert.bugIds } : { id: undefined; desc: string; pass: any; bugs: any; }
>id : undefined
>类型别名 :=> 未定
>undefined : undefined
>类型别名 :=> 未定
>desc : string
>类型别名 :=> 文字
>this.description : string
>类型别名 :=> 文字
>this : this
>description : string
>类型别名 :=> 文字
>pass : any
>类型别名 :=> 任意
>this.passed : any
>类型别名 :=> 任意
>this : this
>passed : any
>类型别名 :=> 任意
>bugs : any
>类型别名 :=> 任意
>assert.bugIds : any
>类型别名 :=> 任意
>assert : any
>类型别名 :=> 任意
>bugIds : any
>类型别名 :=> 任意

            // Report all bugs affecting this scenario
            assert.bugIds.forEach(desc => emitLog('bug', metadata, desc));
>assert.bugIds.forEach(desc => emitLog('bug', metadata, desc)) : any
>类型别名 :=> 任意
>assert.bugIds.forEach : any
>类型别名 :=> 任意
>assert.bugIds : any
>类型别名 :=> 任意
>assert : any
>类型别名 :=> 任意
>bugIds : any
>类型别名 :=> 任意
>forEach : any
>类型别名 :=> 任意
>desc => emitLog('bug', metadata, desc) : (desc: any) => void
>desc : any
>类型别名 :=> 任意
>emitLog('bug', metadata, desc) : void
>类型别名 :=> 无值
>emitLog : (field: string, ...params: any[]) => void
>'bug' : "bug"
>metadata : IScenarioMetadata
>desc : any
>类型别名 :=> 任意

            emitLog('scenarioEnd', metadata);
>emitLog('scenarioEnd', metadata) : void
>类型别名 :=> 无值
>emitLog : (field: string, ...params: any[]) => void
>'scenarioEnd' : "scenarioEnd"
>metadata : IScenarioMetadata

            done();
>done() : void
>类型别名 :=> 无值
>done : IDone
        }
    }
    export class Run extends Runnable {
>Run : Run
>Runnable : Runnable

        constructor() {
            super('Test Run', null);
>super('Test Run', null) : void
>类型别名 :=> 无值
>super : typeof Runnable
>'Test Run' : "Test Run"
>null : null
>类型别名 :=> 空值
        }

        public run() {
>run : () => void

            emitLog('start');
>emitLog('start') : void
>类型别名 :=> 无值
>emitLog : (field: string, ...params: any[]) => void
>'start' : "start"

            this.runChildren();
>this.runChildren() : void
>类型别名 :=> 无值
>this.runChildren : (index?: number) => void
>this : this
>runChildren : (index?: number) => void
        }

        public runChildren(index = 0) {
>runChildren : (index?: number) => void
>index : number
>类型别名 :=> 数字
>0 : 0

            var async = false;
>async : boolean
>类型别名 :=> 真假
>false : false
>类型别名 :=> 为假

            var that = this;
>that : this
>this : this

            for (; index < this.children.length; index++) {
>index < this.children.length : boolean
>类型别名 :=> 真假
>index : number
>类型别名 :=> 数字
>this.children.length : number
>类型别名 :=> 数字
>this.children : Runnable[]
>this : this
>children : Runnable[]
>length : number
>类型别名 :=> 数字
>index++ : number
>类型别名 :=> 数字
>index : number
>类型别名 :=> 数字

                // Clear out bug descriptions
                assert.bugIds = [];
>assert.bugIds = [] : undefined[]
>assert.bugIds : any
>类型别名 :=> 任意
>assert : any
>类型别名 :=> 任意
>bugIds : any
>类型别名 :=> 任意
>[] : undefined[]

                async = this.runChild(index, <any>function (e) {
>async = this.runChild(index, <any>function (e) {                    if (async) {                        that.runChildren(index + 1);                    }                }) : boolean
>类型别名 :=> 真假
>async : boolean
>类型别名 :=> 真假
>this.runChild(index, <any>function (e) {                    if (async) {                        that.runChildren(index + 1);                    }                }) : boolean
>类型别名 :=> 真假
>this.runChild : (index: number, done: IDone) => boolean
>this : this
>runChild : (index: number, done: IDone) => boolean
>index : number
>类型别名 :=> 数字
><any>function (e) {                    if (async) {                        that.runChildren(index + 1);                    }                } : any
>类型别名 :=> 任意
>function (e) {                    if (async) {                        that.runChildren(index + 1);                    }                } : (e: any) => void
>e : any
>类型别名 :=> 任意

                    if (async) {
>async : boolean
>类型别名 :=> 真假

                        that.runChildren(index + 1);
>that.runChildren(index + 1) : void
>类型别名 :=> 无值
>that.runChildren : (index?: number) => void
>that : this
>runChildren : (index?: number) => void
>index + 1 : number
>类型别名 :=> 数字
>index : number
>类型别名 :=> 数字
>1 : 1
                    }
                });

                if (async) {
>async : boolean
>类型别名 :=> 真假

                    return;
                }
            }

            Perf.runBenchmarks();
>Perf.runBenchmarks() : void
>类型别名 :=> 无值
>Perf.runBenchmarks : () => void
>Perf : typeof Perf
>runBenchmarks : () => void

            emitLog('end');
>emitLog('end') : void
>类型别名 :=> 无值
>emitLog : (field: string, ...params: any[]) => void
>'end' : "end"
        }
    }

    // Performance test
    export module Perf {
>Perf : typeof Perf

        export module Clock {
>Clock : typeof Clock

            export var now: () => number;
>now : () => number

            export var resolution: number;
>resolution : number
>类型别名 :=> 数字

            declare module WScript {
>WScript : typeof WScript

                export function InitializeProjection();
>InitializeProjection : () => any
            }

            declare module TestUtilities {
>TestUtilities : typeof TestUtilities

                export function QueryPerformanceCounter(): number;
>QueryPerformanceCounter : () => number

                export function QueryPerformanceFrequency(): number;
>QueryPerformanceFrequency : () => number
            }

            if (typeof WScript !== "undefined" && typeof global['WScript'].InitializeProjection !== "undefined") {
>typeof WScript !== "undefined" && typeof global['WScript'].InitializeProjection !== "undefined" : boolean
>类型别名 :=> 真假
>typeof WScript !== "undefined" : boolean
>类型别名 :=> 真假
>typeof WScript : "string" | "number" | "boolean" | "symbol" | "undefined" | "object" | "function" | "文字" | "数字" | "真假" | "符号" | "未定" | "对象" | "函数"
>WScript : typeof WScript
>"undefined" : "undefined"
>typeof global['WScript'].InitializeProjection !== "undefined" : boolean
>类型别名 :=> 真假
>typeof global['WScript'].InitializeProjection : "string" | "number" | "boolean" | "symbol" | "undefined" | "object" | "function" | "文字" | "数字" | "真假" | "符号" | "未定" | "对象" | "函数"
>global['WScript'].InitializeProjection : any
>类型别名 :=> 任意
>global['WScript'] : any
>类型别名 :=> 任意
>global : any
>类型别名 :=> 任意
>'WScript' : "WScript"
>InitializeProjection : any
>类型别名 :=> 任意
>"undefined" : "undefined"

                // Running in JSHost.
                global['WScript'].InitializeProjection();
>global['WScript'].InitializeProjection() : any
>类型别名 :=> 任意
>global['WScript'].InitializeProjection : any
>类型别名 :=> 任意
>global['WScript'] : any
>类型别名 :=> 任意
>global : any
>类型别名 :=> 任意
>'WScript' : "WScript"
>InitializeProjection : any
>类型别名 :=> 任意

                now = function () {
>now = function () {                    return TestUtilities.QueryPerformanceCounter();                } : () => number
>now : () => number
>function () {                    return TestUtilities.QueryPerformanceCounter();                } : () => number

                    return TestUtilities.QueryPerformanceCounter();
>TestUtilities.QueryPerformanceCounter() : number
>类型别名 :=> 数字
>TestUtilities.QueryPerformanceCounter : () => number
>TestUtilities : typeof TestUtilities
>QueryPerformanceCounter : () => number
                }

                resolution = TestUtilities.QueryPerformanceFrequency();
>resolution = TestUtilities.QueryPerformanceFrequency() : number
>类型别名 :=> 数字
>resolution : number
>类型别名 :=> 数字
>TestUtilities.QueryPerformanceFrequency() : number
>类型别名 :=> 数字
>TestUtilities.QueryPerformanceFrequency : () => number
>TestUtilities : typeof TestUtilities
>QueryPerformanceFrequency : () => number

            } else {
                now = function () {
>now = function () {                    return Date.now();                } : () => number
>now : () => number
>function () {                    return Date.now();                } : () => number

                    return Date.now();
>Date.now() : number
>类型别名 :=> 数字
>Date.now : () => number
>Date : DateConstructor
>now : () => number
                }

                resolution = 1000;
>resolution = 1000 : 1000
>resolution : number
>类型别名 :=> 数字
>1000 : 1000
            }
        }

        export class Timer {
>Timer : Timer

            public startTime;
>startTime : any
>类型别名 :=> 任意

            public time = 0;
>time : number
>类型别名 :=> 数字
>0 : 0

            public start() {
>start : () => void

                this.time = 0;
>this.time = 0 : 0
>this.time : number
>类型别名 :=> 数字
>this : this
>time : number
>类型别名 :=> 数字
>0 : 0

                this.startTime = Clock.now();
>this.startTime = Clock.now() : number
>类型别名 :=> 数字
>this.startTime : any
>类型别名 :=> 任意
>this : this
>startTime : any
>类型别名 :=> 任意
>Clock.now() : number
>类型别名 :=> 数字
>Clock.now : () => number
>Clock : typeof Clock
>now : () => number
            }

            public end() {
>end : () => void

                // Set time to MS.
                this.time = (Clock.now() - this.startTime) / Clock.resolution * 1000;
>this.time = (Clock.now() - this.startTime) / Clock.resolution * 1000 : number
>类型别名 :=> 数字
>this.time : number
>类型别名 :=> 数字
>this : this
>time : number
>类型别名 :=> 数字
>(Clock.now() - this.startTime) / Clock.resolution * 1000 : number
>类型别名 :=> 数字
>(Clock.now() - this.startTime) / Clock.resolution : number
>类型别名 :=> 数字
>(Clock.now() - this.startTime) : number
>类型别名 :=> 数字
>Clock.now() - this.startTime : number
>类型别名 :=> 数字
>Clock.now() : number
>类型别名 :=> 数字
>Clock.now : () => number
>Clock : typeof Clock
>now : () => number
>this.startTime : any
>类型别名 :=> 任意
>this : this
>startTime : any
>类型别名 :=> 任意
>Clock.resolution : number
>类型别名 :=> 数字
>Clock : typeof Clock
>resolution : number
>类型别名 :=> 数字
>1000 : 1000
            }
        }

        export class Dataset {
>Dataset : Dataset

            public data: number[] = [];
>data : number[]
>[] : undefined[]

            public add(value: number) {
>add : (value: number) => void
>value : number
>类型别名 :=> 数字

                this.data.push(value);
>this.data.push(value) : number
>类型别名 :=> 数字
>this.data.push : (...items: number[]) => number
>this.data : number[]
>this : this
>data : number[]
>push : (...items: number[]) => number
>value : number
>类型别名 :=> 数字
            }

            public mean() {
>mean : () => number

                var sum = 0;
>sum : number
>类型别名 :=> 数字
>0 : 0

                for (var i = 0; i < this.data.length; i++) {
>i : number
>类型别名 :=> 数字
>0 : 0
>i < this.data.length : boolean
>类型别名 :=> 真假
>i : number
>类型别名 :=> 数字
>this.data.length : number
>类型别名 :=> 数字
>this.data : number[]
>this : this
>data : number[]
>length : number
>类型别名 :=> 数字
>i++ : number
>类型别名 :=> 数字
>i : number
>类型别名 :=> 数字

                    sum += this.data[i];
>sum += this.data[i] : number
>类型别名 :=> 数字
>sum : number
>类型别名 :=> 数字
>this.data[i] : number
>类型别名 :=> 数字
>this.data : number[]
>this : this
>data : number[]
>i : number
>类型别名 :=> 数字
                }

                return sum / this.data.length;
>sum / this.data.length : number
>类型别名 :=> 数字
>sum : number
>类型别名 :=> 数字
>this.data.length : number
>类型别名 :=> 数字
>this.data : number[]
>this : this
>data : number[]
>length : number
>类型别名 :=> 数字
            }

            public min() {
>min : () => number

                var min = this.data[0];
>min : number
>类型别名 :=> 数字
>this.data[0] : number
>类型别名 :=> 数字
>this.data : number[]
>this : this
>data : number[]
>0 : 0

                for (var i = 1; i < this.data.length; i++) {
>i : number
>类型别名 :=> 数字
>1 : 1
>i < this.data.length : boolean
>类型别名 :=> 真假
>i : number
>类型别名 :=> 数字
>this.data.length : number
>类型别名 :=> 数字
>this.data : number[]
>this : this
>data : number[]
>length : number
>类型别名 :=> 数字
>i++ : number
>类型别名 :=> 数字
>i : number
>类型别名 :=> 数字

                    if (this.data[i] < min) {
>this.data[i] < min : boolean
>类型别名 :=> 真假
>this.data[i] : number
>类型别名 :=> 数字
>this.data : number[]
>this : this
>data : number[]
>i : number
>类型别名 :=> 数字
>min : number
>类型别名 :=> 数字

                        min = this.data[i];
>min = this.data[i] : number
>类型别名 :=> 数字
>min : number
>类型别名 :=> 数字
>this.data[i] : number
>类型别名 :=> 数字
>this.data : number[]
>this : this
>data : number[]
>i : number
>类型别名 :=> 数字
                    }
                }

                return min;
>min : number
>类型别名 :=> 数字
            }

            public max() {
>max : () => number

                var max = this.data[0];
>max : number
>类型别名 :=> 数字
>this.data[0] : number
>类型别名 :=> 数字
>this.data : number[]
>this : this
>data : number[]
>0 : 0

                for (var i = 1; i < this.data.length; i++) {
>i : number
>类型别名 :=> 数字
>1 : 1
>i < this.data.length : boolean
>类型别名 :=> 真假
>i : number
>类型别名 :=> 数字
>this.data.length : number
>类型别名 :=> 数字
>this.data : number[]
>this : this
>data : number[]
>length : number
>类型别名 :=> 数字
>i++ : number
>类型别名 :=> 数字
>i : number
>类型别名 :=> 数字

                    if (this.data[i] > max) {
>this.data[i] > max : boolean
>类型别名 :=> 真假
>this.data[i] : number
>类型别名 :=> 数字
>this.data : number[]
>this : this
>data : number[]
>i : number
>类型别名 :=> 数字
>max : number
>类型别名 :=> 数字

                        max = this.data[i];
>max = this.data[i] : number
>类型别名 :=> 数字
>max : number
>类型别名 :=> 数字
>this.data[i] : number
>类型别名 :=> 数字
>this.data : number[]
>this : this
>data : number[]
>i : number
>类型别名 :=> 数字
                    }
                }

                return max;
>max : number
>类型别名 :=> 数字
            }

            public stdDev() {
>stdDev : () => number

                var sampleMean = this.mean();
>sampleMean : number
>类型别名 :=> 数字
>this.mean() : number
>类型别名 :=> 数字
>this.mean : () => number
>this : this
>mean : () => number

                var sumOfSquares = 0;
>sumOfSquares : number
>类型别名 :=> 数字
>0 : 0

                for (var i = 0; i < this.data.length; i++) {
>i : number
>类型别名 :=> 数字
>0 : 0
>i < this.data.length : boolean
>类型别名 :=> 真假
>i : number
>类型别名 :=> 数字
>this.data.length : number
>类型别名 :=> 数字
>this.data : number[]
>this : this
>data : number[]
>length : number
>类型别名 :=> 数字
>i++ : number
>类型别名 :=> 数字
>i : number
>类型别名 :=> 数字

                    sumOfSquares += Math.pow(this.data[i] - sampleMean, 2);
>sumOfSquares += Math.pow(this.data[i] - sampleMean, 2) : number
>类型别名 :=> 数字
>sumOfSquares : number
>类型别名 :=> 数字
>Math.pow(this.data[i] - sampleMean, 2) : number
>类型别名 :=> 数字
>Math.pow : (x: number, y: number) => number
>Math : Math
>pow : (x: number, y: number) => number
>this.data[i] - sampleMean : number
>类型别名 :=> 数字
>this.data[i] : number
>类型别名 :=> 数字
>this.data : number[]
>this : this
>data : number[]
>i : number
>类型别名 :=> 数字
>sampleMean : number
>类型别名 :=> 数字
>2 : 2
                }

                return Math.sqrt(sumOfSquares / this.data.length);
>Math.sqrt(sumOfSquares / this.data.length) : number
>类型别名 :=> 数字
>Math.sqrt : (x: number) => number
>Math : Math
>sqrt : (x: number) => number
>sumOfSquares / this.data.length : number
>类型别名 :=> 数字
>sumOfSquares : number
>类型别名 :=> 数字
>this.data.length : number
>类型别名 :=> 数字
>this.data : number[]
>this : this
>data : number[]
>length : number
>类型别名 :=> 数字
            }
        }

        // Base benchmark class with some defaults.
        export class Benchmark {
>Benchmark : Benchmark

            public iterations = 10;
>iterations : number
>类型别名 :=> 数字
>10 : 10

            public description = "";
>description : string
>类型别名 :=> 文字
>"" : ""

            public bench(subBench?: () => void ) { }
>bench : (subBench?: () => void) => void
>subBench : () => void

            public before() { }
>before : () => void

            public beforeEach() { }
>beforeEach : () => void

            public after() { }
>after : () => void

            public afterEach() { }
>afterEach : () => void

            public results: { [x: string]: Dataset; } = <{ [x: string]: Dataset; }>{};
>results : { [x: string]: Dataset; }
>x : string
>类型别名 :=> 文字
>Dataset : Dataset
><{ [x: string]: Dataset; }>{} : { [x: string]: Dataset; }
>x : string
>类型别名 :=> 文字
>Dataset : Dataset
>{} : {}

            public addTimingFor(name: string, timing: number) {
>addTimingFor : (name: string, timing: number) => void
>name : string
>类型别名 :=> 文字
>timing : number
>类型别名 :=> 数字

                this.results[name] = this.results[name] || new Dataset();
>this.results[name] = this.results[name] || new Dataset() : Dataset
>this.results[name] : Dataset
>this.results : { [x: string]: Dataset; }
>this : this
>results : { [x: string]: Dataset; }
>name : string
>类型别名 :=> 文字
>this.results[name] || new Dataset() : Dataset
>this.results[name] : Dataset
>this.results : { [x: string]: Dataset; }
>this : this
>results : { [x: string]: Dataset; }
>name : string
>类型别名 :=> 文字
>new Dataset() : Dataset
>Dataset : typeof Dataset

                this.results[name].add(timing);
>this.results[name].add(timing) : void
>类型别名 :=> 无值
>this.results[name].add : (value: number) => void
>this.results[name] : Dataset
>this.results : { [x: string]: Dataset; }
>this : this
>results : { [x: string]: Dataset; }
>name : string
>类型别名 :=> 文字
>add : (value: number) => void
>timing : number
>类型别名 :=> 数字
            }
        }

        export var benchmarks: { new (): Benchmark; }[] = [];
>benchmarks : (new () => Benchmark)[]
>Benchmark : Benchmark
>[] : undefined[]

        var timeFunction: (
>timeFunction : (benchmark: Benchmark, description?: string, name?: string, f?: (bench?: () => void) => void) => void

            benchmark: Benchmark,
>benchmark : Benchmark
>Benchmark : Benchmark

            description?: string,
>description : string
>类型别名 :=> 文字

            name?: string,
>name : string
>类型别名 :=> 文字

            f?: (bench?: { (): void; }) => void
>f : (bench?: () => void) => void
>bench : () => void

        ) => void;

        timeFunction = function (
>timeFunction = function (            benchmark: Benchmark,            description: string = benchmark.description,            name: string = '',            f = benchmark.bench        ): void {            var t = new Timer();            t.start();            var subBenchmark = function (name, f): void {                timeFunction(benchmark, description, name, f);            }            f.call(benchmark, subBenchmark);            t.end();            benchmark.addTimingFor(name, t.time);        } : (benchmark: Benchmark, description?: string, name?: string, f?: (bench?: () => void) => void) => void
>timeFunction : (benchmark: Benchmark, description?: string, name?: string, f?: (bench?: () => void) => void) => void
>function (            benchmark: Benchmark,            description: string = benchmark.description,            name: string = '',            f = benchmark.bench        ): void {            var t = new Timer();            t.start();            var subBenchmark = function (name, f): void {                timeFunction(benchmark, description, name, f);            }            f.call(benchmark, subBenchmark);            t.end();            benchmark.addTimingFor(name, t.time);        } : (benchmark: Benchmark, description?: string, name?: string, f?: (bench?: () => void) => void) => void

            benchmark: Benchmark,
>benchmark : Benchmark
>Benchmark : Benchmark

            description: string = benchmark.description,
>description : string
>类型别名 :=> 文字
>benchmark.description : string
>类型别名 :=> 文字
>benchmark : Benchmark
>description : string
>类型别名 :=> 文字

            name: string = '',
>name : string
>类型别名 :=> 文字
>'' : ""

            f = benchmark.bench
>f : (bench?: () => void) => void
>benchmark.bench : (subBench?: () => void) => void
>benchmark : Benchmark
>bench : (subBench?: () => void) => void

        ): void {

            var t = new Timer();
>t : Timer
>new Timer() : Timer
>Timer : typeof Timer

            t.start();
>t.start() : void
>类型别名 :=> 无值
>t.start : () => void
>t : Timer
>start : () => void

            var subBenchmark = function (name, f): void {
>subBenchmark : (name: any, f: any) => void
>function (name, f): void {                timeFunction(benchmark, description, name, f);            } : (name: any, f: any) => void
>name : any
>类型别名 :=> 任意
>f : any
>类型别名 :=> 任意

                timeFunction(benchmark, description, name, f);
>timeFunction(benchmark, description, name, f) : void
>类型别名 :=> 无值
>timeFunction : (benchmark: Benchmark, description?: string, name?: string, f?: (bench?: () => void) => void) => void
>benchmark : Benchmark
>description : string
>类型别名 :=> 文字
>name : any
>类型别名 :=> 任意
>f : any
>类型别名 :=> 任意
            }

            f.call(benchmark, subBenchmark);
>f.call(benchmark, subBenchmark) : any
>类型别名 :=> 任意
>f.call : (this: Function, thisArg: any, ...argArray: any[]) => any
>f : (bench?: () => void) => void
>call : (this: Function, thisArg: any, ...argArray: any[]) => any
>benchmark : Benchmark
>subBenchmark : (name: any, f: any) => void

            t.end();
>t.end() : void
>类型别名 :=> 无值
>t.end : () => void
>t : Timer
>end : () => void

            benchmark.addTimingFor(name, t.time);
>benchmark.addTimingFor(name, t.time) : void
>类型别名 :=> 无值
>benchmark.addTimingFor : (name: string, timing: number) => void
>benchmark : Benchmark
>addTimingFor : (name: string, timing: number) => void
>name : string
>类型别名 :=> 文字
>t.time : number
>类型别名 :=> 数字
>t : Timer
>time : number
>类型别名 :=> 数字
        }

        export function runBenchmarks() {
>runBenchmarks : () => void

            for (var i = 0; i < benchmarks.length; i++) {
>i : number
>类型别名 :=> 数字
>0 : 0
>i < benchmarks.length : boolean
>类型别名 :=> 真假
>i : number
>类型别名 :=> 数字
>benchmarks.length : number
>类型别名 :=> 数字
>benchmarks : (new () => Benchmark)[]
>length : number
>类型别名 :=> 数字
>i++ : number
>类型别名 :=> 数字
>i : number
>类型别名 :=> 数字

                var b = new benchmarks[i]();
>b : Benchmark
>new benchmarks[i]() : Benchmark
>benchmarks[i] : new () => Benchmark
>benchmarks : (new () => Benchmark)[]
>i : number
>类型别名 :=> 数字


                var t = new Timer();
>t : Timer
>new Timer() : Timer
>Timer : typeof Timer

                b.before();
>b.before() : void
>类型别名 :=> 无值
>b.before : () => void
>b : Benchmark
>before : () => void

                for (var j = 0; j < b.iterations; j++) {
>j : number
>类型别名 :=> 数字
>0 : 0
>j < b.iterations : boolean
>类型别名 :=> 真假
>j : number
>类型别名 :=> 数字
>b.iterations : number
>类型别名 :=> 数字
>b : Benchmark
>iterations : number
>类型别名 :=> 数字
>j++ : number
>类型别名 :=> 数字
>j : number
>类型别名 :=> 数字

                    b.beforeEach();
>b.beforeEach() : void
>类型别名 :=> 无值
>b.beforeEach : () => void
>b : Benchmark
>beforeEach : () => void

                    timeFunction(b);
>timeFunction(b) : void
>类型别名 :=> 无值
>timeFunction : (benchmark: Benchmark, description?: string, name?: string, f?: (bench?: () => void) => void) => void
>b : Benchmark

                    b.afterEach();
>b.afterEach() : void
>类型别名 :=> 无值
>b.afterEach : () => void
>b : Benchmark
>afterEach : () => void
                }
                b.after();
>b.after() : void
>类型别名 :=> 无值
>b.after : () => void
>b : Benchmark
>after : () => void

                for (var prop in b.results) {
>prop : string
>类型别名 :=> 文字
>b.results : { [x: string]: Dataset; }
>b : Benchmark
>results : { [x: string]: Dataset; }

                    var description = b.description + (prop ? ": " + prop : '');
>description : string
>类型别名 :=> 文字
>b.description + (prop ? ": " + prop : '') : string
>类型别名 :=> 文字
>b.description : string
>类型别名 :=> 文字
>b : Benchmark
>description : string
>类型别名 :=> 文字
>(prop ? ": " + prop : '') : string
>类型别名 :=> 文字
>prop ? ": " + prop : '' : string
>类型别名 :=> 文字
>prop : string
>类型别名 :=> 文字
>": " + prop : string
>类型别名 :=> 文字
>": " : ": "
>prop : string
>类型别名 :=> 文字
>'' : ""

                    emitLog('testStart', { desc: description });
>emitLog('testStart', { desc: description }) : void
>类型别名 :=> 无值
>emitLog : (field: string, ...params: any[]) => void
>'testStart' : "testStart"
>{ desc: description } : { desc: string; }
>desc : string
>类型别名 :=> 文字
>description : string
>类型别名 :=> 文字

                    emitLog('pass', {
>emitLog('pass', {                        desc: description, pass: true, perfResults: {                            mean: b.results[prop].mean(),                            min: b.results[prop].min(),                            max: b.results[prop].max(),                            stdDev: b.results[prop].stdDev(),                            trials: b.results[prop].data                        }                    }) : void
>类型别名 :=> 无值
>emitLog : (field: string, ...params: any[]) => void
>'pass' : "pass"
>{                        desc: description, pass: true, perfResults: {                            mean: b.results[prop].mean(),                            min: b.results[prop].min(),                            max: b.results[prop].max(),                            stdDev: b.results[prop].stdDev(),                            trials: b.results[prop].data                        }                    } : { desc: string; pass: boolean; perfResults: { mean: number; min: number; max: number; stdDev: number; trials: number[]; }; }

                        desc: description, pass: true, perfResults: {
>desc : string
>类型别名 :=> 文字
>description : string
>类型别名 :=> 文字
>pass : boolean
>类型别名 :=> 真假
>true : true
>类型别名 :=> 为真
>perfResults : { mean: number; min: number; max: number; stdDev: number; trials: number[]; }
>{                            mean: b.results[prop].mean(),                            min: b.results[prop].min(),                            max: b.results[prop].max(),                            stdDev: b.results[prop].stdDev(),                            trials: b.results[prop].data                        } : { mean: number; min: number; max: number; stdDev: number; trials: number[]; }

                            mean: b.results[prop].mean(),
>mean : number
>类型别名 :=> 数字
>b.results[prop].mean() : number
>类型别名 :=> 数字
>b.results[prop].mean : () => number
>b.results[prop] : Dataset
>b.results : { [x: string]: Dataset; }
>b : Benchmark
>results : { [x: string]: Dataset; }
>prop : string
>类型别名 :=> 文字
>mean : () => number

                            min: b.results[prop].min(),
>min : number
>类型别名 :=> 数字
>b.results[prop].min() : number
>类型别名 :=> 数字
>b.results[prop].min : () => number
>b.results[prop] : Dataset
>b.results : { [x: string]: Dataset; }
>b : Benchmark
>results : { [x: string]: Dataset; }
>prop : string
>类型别名 :=> 文字
>min : () => number

                            max: b.results[prop].max(),
>max : number
>类型别名 :=> 数字
>b.results[prop].max() : number
>类型别名 :=> 数字
>b.results[prop].max : () => number
>b.results[prop] : Dataset
>b.results : { [x: string]: Dataset; }
>b : Benchmark
>results : { [x: string]: Dataset; }
>prop : string
>类型别名 :=> 文字
>max : () => number

                            stdDev: b.results[prop].stdDev(),
>stdDev : number
>类型别名 :=> 数字
>b.results[prop].stdDev() : number
>类型别名 :=> 数字
>b.results[prop].stdDev : () => number
>b.results[prop] : Dataset
>b.results : { [x: string]: Dataset; }
>b : Benchmark
>results : { [x: string]: Dataset; }
>prop : string
>类型别名 :=> 文字
>stdDev : () => number

                            trials: b.results[prop].data
>trials : number[]
>b.results[prop].data : number[]
>b.results[prop] : Dataset
>b.results : { [x: string]: Dataset; }
>b : Benchmark
>results : { [x: string]: Dataset; }
>prop : string
>类型别名 :=> 文字
>data : number[]
                        }
                    });
                }

            }
        }

        // Replace with better type when classes are assignment compatible with
        // the below type.
        // export function addBenchmark(BenchmarkClass: {new(): Benchmark;}) {
        export function addBenchmark(BenchmarkClass: any) {
>addBenchmark : (BenchmarkClass: any) => void
>BenchmarkClass : any
>类型别名 :=> 任意

            benchmarks.push(BenchmarkClass);
>benchmarks.push(BenchmarkClass) : number
>类型别名 :=> 数字
>benchmarks.push : (...items: (new () => Benchmark)[]) => number
>benchmarks : (new () => Benchmark)[]
>push : (...items: (new () => Benchmark)[]) => number
>BenchmarkClass : any
>类型别名 :=> 任意
        }

    }

    /** Functionality for compiling TypeScript code */
    export module Compiler {
>Compiler : typeof Compiler

        /** Aggregate various writes into a single array of lines. Useful for passing to the
         *  TypeScript compiler to fill with source code or errors.
         */
        export class WriterAggregator implements ITextWriter {
>WriterAggregator : WriterAggregator
>ITextWriter : No type information available!

            public lines: string[] = [];
>lines : string[]
>[] : undefined[]

            public currentLine = "";
>currentLine : string
>类型别名 :=> 文字
>"" : ""

            public Write(str) {
>Write : (str: any) => void
>str : any
>类型别名 :=> 任意

                this.currentLine += str;
>this.currentLine += str : string
>类型别名 :=> 文字
>this.currentLine : string
>类型别名 :=> 文字
>this : this
>currentLine : string
>类型别名 :=> 文字
>str : any
>类型别名 :=> 任意
            }

            public WriteLine(str) {
>WriteLine : (str: any) => void
>str : any
>类型别名 :=> 任意

                this.lines.push(this.currentLine + str);
>this.lines.push(this.currentLine + str) : number
>类型别名 :=> 数字
>this.lines.push : (...items: string[]) => number
>this.lines : string[]
>this : this
>lines : string[]
>push : (...items: string[]) => number
>this.currentLine + str : string
>类型别名 :=> 文字
>this.currentLine : string
>类型别名 :=> 文字
>this : this
>currentLine : string
>类型别名 :=> 文字
>str : any
>类型别名 :=> 任意

                this.currentLine = "";
>this.currentLine = "" : ""
>this.currentLine : string
>类型别名 :=> 文字
>this : this
>currentLine : string
>类型别名 :=> 文字
>"" : ""
            }

            public Close() {
>Close : () => void

                if (this.currentLine.length > 0) { this.lines.push(this.currentLine); }
>this.currentLine.length > 0 : boolean
>类型别名 :=> 真假
>this.currentLine.length : number
>类型别名 :=> 数字
>this.currentLine : string
>类型别名 :=> 文字
>this : this
>currentLine : string
>类型别名 :=> 文字
>length : number
>类型别名 :=> 数字
>0 : 0
>this.lines.push(this.currentLine) : number
>类型别名 :=> 数字
>this.lines.push : (...items: string[]) => number
>this.lines : string[]
>this : this
>lines : string[]
>push : (...items: string[]) => number
>this.currentLine : string
>类型别名 :=> 文字
>this : this
>currentLine : string
>类型别名 :=> 文字

                this.currentLine = "";
>this.currentLine = "" : ""
>this.currentLine : string
>类型别名 :=> 文字
>this : this
>currentLine : string
>类型别名 :=> 文字
>"" : ""
            }

            public reset() {
>reset : () => void

                this.lines = [];
>this.lines = [] : undefined[]
>this.lines : string[]
>this : this
>lines : string[]
>[] : undefined[]

                this.currentLine = "";
>this.currentLine = "" : ""
>this.currentLine : string
>类型别名 :=> 文字
>this : this
>currentLine : string
>类型别名 :=> 文字
>"" : ""
            }
        }

        /** Mimics having multiple files, later concatenated to a single file. */
        export class EmitterIOHost implements TypeScript.EmitterIOHost {
>EmitterIOHost : EmitterIOHost
>TypeScript.EmitterIOHost : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>EmitterIOHost : No type information available!

            private fileCollection = {};
>fileCollection : {}
>{} : {}

            /** create file gets the whole path to create, so this works as expected with the --out parameter */
            public createFile(s: string, useUTF8?: boolean): ITextWriter {
>createFile : (s: string, useUTF8?: boolean) => any
>s : string
>类型别名 :=> 文字
>useUTF8 : boolean
>类型别名 :=> 真假
>ITextWriter : No type information available!

                if (this.fileCollection[s]) {
>this.fileCollection[s] : any
>类型别名 :=> 任意
>this.fileCollection : {}
>this : this
>fileCollection : {}
>s : string
>类型别名 :=> 文字

                    return <ITextWriter>this.fileCollection[s];
><ITextWriter>this.fileCollection[s] : any
>类型别名 :=> 任意
>ITextWriter : No type information available!
>this.fileCollection[s] : any
>类型别名 :=> 任意
>this.fileCollection : {}
>this : this
>fileCollection : {}
>s : string
>类型别名 :=> 文字
                }

                var writer = new Harness.Compiler.WriterAggregator();
>writer : WriterAggregator
>new Harness.Compiler.WriterAggregator() : WriterAggregator
>Harness.Compiler.WriterAggregator : typeof WriterAggregator
>Harness.Compiler : typeof Compiler
>Harness : typeof Harness
>Compiler : typeof Compiler
>WriterAggregator : typeof WriterAggregator

                this.fileCollection[s] = writer;
>this.fileCollection[s] = writer : WriterAggregator
>this.fileCollection[s] : any
>类型别名 :=> 任意
>this.fileCollection : {}
>this : this
>fileCollection : {}
>s : string
>类型别名 :=> 文字
>writer : WriterAggregator

                return writer;
>writer : WriterAggregator
            }

            public directoryExists(s: string) { return false; }
>directoryExists : (s: string) => boolean
>s : string
>类型别名 :=> 文字
>false : false
>类型别名 :=> 为假

            public fileExists(s: string) { return typeof this.fileCollection[s] !== 'undefined'; }
>fileExists : (s: string) => boolean
>s : string
>类型别名 :=> 文字
>typeof this.fileCollection[s] !== 'undefined' : boolean
>类型别名 :=> 真假
>typeof this.fileCollection[s] : "string" | "number" | "boolean" | "symbol" | "undefined" | "object" | "function" | "文字" | "数字" | "真假" | "符号" | "未定" | "对象" | "函数"
>this.fileCollection[s] : any
>类型别名 :=> 任意
>this.fileCollection : {}
>this : this
>fileCollection : {}
>s : string
>类型别名 :=> 文字
>'undefined' : "undefined"

            public resolvePath(s: string) { return s; }
>resolvePath : (s: string) => string
>s : string
>类型别名 :=> 文字
>s : string
>类型别名 :=> 文字

            public reset() { this.fileCollection = {}; }
>reset : () => void
>this.fileCollection = {} : {}
>this.fileCollection : {}
>this : this
>fileCollection : {}
>{} : {}

            public toArray(): { filename: string; file: WriterAggregator; }[] {
>toArray : () => { filename: string; file: WriterAggregator; }[]
>filename : string
>类型别名 :=> 文字
>file : WriterAggregator
>WriterAggregator : WriterAggregator

                var result: { filename: string; file: WriterAggregator; }[] = [];
>result : { filename: string; file: WriterAggregator; }[]
>filename : string
>类型别名 :=> 文字
>file : WriterAggregator
>WriterAggregator : WriterAggregator
>[] : undefined[]

                for (var p in this.fileCollection) {
>p : string
>类型别名 :=> 文字
>this.fileCollection : {}
>this : this
>fileCollection : {}

                    if (this.fileCollection.hasOwnProperty(p)) {
>this.fileCollection.hasOwnProperty(p) : boolean
>类型别名 :=> 真假
>this.fileCollection.hasOwnProperty : (v: string) => boolean
>this.fileCollection : {}
>this : this
>fileCollection : {}
>hasOwnProperty : (v: string) => boolean
>p : string
>类型别名 :=> 文字

                        var current = <Harness.Compiler.WriterAggregator>this.fileCollection[p];
>current : WriterAggregator
><Harness.Compiler.WriterAggregator>this.fileCollection[p] : WriterAggregator
>Harness : any
>类型别名 :=> 任意
>Compiler : any
>类型别名 :=> 任意
>WriterAggregator : WriterAggregator
>this.fileCollection[p] : any
>类型别名 :=> 任意
>this.fileCollection : {}
>this : this
>fileCollection : {}
>p : string
>类型别名 :=> 文字

                        if (current.lines.length > 0) {
>current.lines.length > 0 : boolean
>类型别名 :=> 真假
>current.lines.length : number
>类型别名 :=> 数字
>current.lines : string[]
>current : WriterAggregator
>lines : string[]
>length : number
>类型别名 :=> 数字
>0 : 0

                            if (p !== '0.js') { current.lines.unshift('////[' + p + ']'); }
>p !== '0.js' : boolean
>类型别名 :=> 真假
>p : string
>类型别名 :=> 文字
>'0.js' : "0.js"
>current.lines.unshift('////[' + p + ']') : number
>类型别名 :=> 数字
>current.lines.unshift : (...items: string[]) => number
>current.lines : string[]
>current : WriterAggregator
>lines : string[]
>unshift : (...items: string[]) => number
>'////[' + p + ']' : string
>类型别名 :=> 文字
>'////[' + p : string
>类型别名 :=> 文字
>'////[' : "////["
>p : string
>类型别名 :=> 文字
>']' : "]"

                            result.push({ filename: p, file: this.fileCollection[p] });
>result.push({ filename: p, file: this.fileCollection[p] }) : number
>类型别名 :=> 数字
>result.push : (...items: { filename: string; file: WriterAggregator; }[]) => number
>result : { filename: string; file: WriterAggregator; }[]
>push : (...items: { filename: string; file: WriterAggregator; }[]) => number
>{ filename: p, file: this.fileCollection[p] } : { filename: string; file: any; }
>filename : string
>类型别名 :=> 文字
>p : string
>类型别名 :=> 文字
>file : any
>类型别名 :=> 任意
>this.fileCollection[p] : any
>类型别名 :=> 任意
>this.fileCollection : {}
>this : this
>fileCollection : {}
>p : string
>类型别名 :=> 文字
                        }
                    }
                }
                return result;
>result : { filename: string; file: WriterAggregator; }[]
            }
        }

        var libFolder: string = global['WScript'] ? TypeScript.filePath(global['WScript'].ScriptFullName) : (__dirname + '/');
>libFolder : string
>类型别名 :=> 文字
>global['WScript'] ? TypeScript.filePath(global['WScript'].ScriptFullName) : (__dirname + '/') : any
>类型别名 :=> 任意
>global['WScript'] : any
>类型别名 :=> 任意
>global : any
>类型别名 :=> 任意
>'WScript' : "WScript"
>TypeScript.filePath(global['WScript'].ScriptFullName) : any
>类型别名 :=> 任意
>TypeScript.filePath : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>filePath : any
>类型别名 :=> 任意
>global['WScript'].ScriptFullName : any
>类型别名 :=> 任意
>global['WScript'] : any
>类型别名 :=> 任意
>global : any
>类型别名 :=> 任意
>'WScript' : "WScript"
>ScriptFullName : any
>类型别名 :=> 任意
>(__dirname + '/') : string
>类型别名 :=> 文字
>__dirname + '/' : string
>类型别名 :=> 文字
>__dirname : any
>类型别名 :=> 任意
>'/' : "/"

        export var libText = IO ? IO.readFile(libFolder + "lib.d.ts") : '';
>libText : any
>类型别名 :=> 任意
>IO ? IO.readFile(libFolder + "lib.d.ts") : '' : any
>类型别名 :=> 任意
>IO : any
>类型别名 :=> 任意
>IO.readFile(libFolder + "lib.d.ts") : any
>类型别名 :=> 任意
>IO.readFile : any
>类型别名 :=> 任意
>IO : any
>类型别名 :=> 任意
>readFile : any
>类型别名 :=> 任意
>libFolder + "lib.d.ts" : string
>类型别名 :=> 文字
>libFolder : string
>类型别名 :=> 文字
>"lib.d.ts" : "lib.d.ts"
>'' : ""

        var stdout = new EmitterIOHost();
>stdout : EmitterIOHost
>new EmitterIOHost() : EmitterIOHost
>EmitterIOHost : typeof EmitterIOHost

        var stderr = new WriterAggregator();
>stderr : WriterAggregator
>new WriterAggregator() : WriterAggregator
>WriterAggregator : typeof WriterAggregator

        export function isDeclareFile(filename: string) {
>isDeclareFile : (filename: string) => boolean
>filename : string
>类型别名 :=> 文字

            return /\.d\.ts$/.test(filename);
>/\.d\.ts$/.test(filename) : boolean
>类型别名 :=> 真假
>/\.d\.ts$/.test : (string: string) => boolean
>/\.d\.ts$/ : RegExp
>test : (string: string) => boolean
>filename : string
>类型别名 :=> 文字
        }

        export function makeDefaultCompilerForTest(c?: TypeScript.TypeScriptCompiler) {
>makeDefaultCompilerForTest : (c?: any) => any
>c : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>TypeScriptCompiler : No type information available!

            var compiler = c || new TypeScript.TypeScriptCompiler(stderr);
>compiler : any
>类型别名 :=> 任意
>c || new TypeScript.TypeScriptCompiler(stderr) : any
>类型别名 :=> 任意
>c : any
>类型别名 :=> 任意
>new TypeScript.TypeScriptCompiler(stderr) : any
>类型别名 :=> 任意
>TypeScript.TypeScriptCompiler : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>TypeScriptCompiler : any
>类型别名 :=> 任意
>stderr : WriterAggregator

            compiler.parser.errorRecovery = true;
>compiler.parser.errorRecovery = true : true
>类型别名 :=> 为真
>compiler.parser.errorRecovery : any
>类型别名 :=> 任意
>compiler.parser : any
>类型别名 :=> 任意
>compiler : any
>类型别名 :=> 任意
>parser : any
>类型别名 :=> 任意
>errorRecovery : any
>类型别名 :=> 任意
>true : true
>类型别名 :=> 为真

            compiler.settings.codeGenTarget = TypeScript.CodeGenTarget.ES5;
>compiler.settings.codeGenTarget = TypeScript.CodeGenTarget.ES5 : any
>类型别名 :=> 任意
>compiler.settings.codeGenTarget : any
>类型别名 :=> 任意
>compiler.settings : any
>类型别名 :=> 任意
>compiler : any
>类型别名 :=> 任意
>settings : any
>类型别名 :=> 任意
>codeGenTarget : any
>类型别名 :=> 任意
>TypeScript.CodeGenTarget.ES5 : any
>类型别名 :=> 任意
>TypeScript.CodeGenTarget : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>CodeGenTarget : any
>类型别名 :=> 任意
>ES5 : any
>类型别名 :=> 任意

            compiler.settings.controlFlow = true;
>compiler.settings.controlFlow = true : true
>类型别名 :=> 为真
>compiler.settings.controlFlow : any
>类型别名 :=> 任意
>compiler.settings : any
>类型别名 :=> 任意
>compiler : any
>类型别名 :=> 任意
>settings : any
>类型别名 :=> 任意
>controlFlow : any
>类型别名 :=> 任意
>true : true
>类型别名 :=> 为真

            compiler.settings.controlFlowUseDef = true;
>compiler.settings.controlFlowUseDef = true : true
>类型别名 :=> 为真
>compiler.settings.controlFlowUseDef : any
>类型别名 :=> 任意
>compiler.settings : any
>类型别名 :=> 任意
>compiler : any
>类型别名 :=> 任意
>settings : any
>类型别名 :=> 任意
>controlFlowUseDef : any
>类型别名 :=> 任意
>true : true
>类型别名 :=> 为真

            if (Harness.usePull) {
>Harness.usePull : boolean
>类型别名 :=> 真假
>Harness : typeof Harness
>usePull : boolean
>类型别名 :=> 真假

                compiler.settings.usePull = true;
>compiler.settings.usePull = true : true
>类型别名 :=> 为真
>compiler.settings.usePull : any
>类型别名 :=> 任意
>compiler.settings : any
>类型别名 :=> 任意
>compiler : any
>类型别名 :=> 任意
>settings : any
>类型别名 :=> 任意
>usePull : any
>类型别名 :=> 任意
>true : true
>类型别名 :=> 为真

                compiler.settings.useFidelity = true;
>compiler.settings.useFidelity = true : true
>类型别名 :=> 为真
>compiler.settings.useFidelity : any
>类型别名 :=> 任意
>compiler.settings : any
>类型别名 :=> 任意
>compiler : any
>类型别名 :=> 任意
>settings : any
>类型别名 :=> 任意
>useFidelity : any
>类型别名 :=> 任意
>true : true
>类型别名 :=> 为真
            }

            compiler.parseEmitOption(stdout);
>compiler.parseEmitOption(stdout) : any
>类型别名 :=> 任意
>compiler.parseEmitOption : any
>类型别名 :=> 任意
>compiler : any
>类型别名 :=> 任意
>parseEmitOption : any
>类型别名 :=> 任意
>stdout : EmitterIOHost

            TypeScript.moduleGenTarget = TypeScript.ModuleGenTarget.Synchronous;
>TypeScript.moduleGenTarget = TypeScript.ModuleGenTarget.Synchronous : any
>类型别名 :=> 任意
>TypeScript.moduleGenTarget : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>moduleGenTarget : any
>类型别名 :=> 任意
>TypeScript.ModuleGenTarget.Synchronous : any
>类型别名 :=> 任意
>TypeScript.ModuleGenTarget : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>ModuleGenTarget : any
>类型别名 :=> 任意
>Synchronous : any
>类型别名 :=> 任意

            compiler.addUnit(Harness.Compiler.libText, "lib.d.ts", true);
>compiler.addUnit(Harness.Compiler.libText, "lib.d.ts", true) : any
>类型别名 :=> 任意
>compiler.addUnit : any
>类型别名 :=> 任意
>compiler : any
>类型别名 :=> 任意
>addUnit : any
>类型别名 :=> 任意
>Harness.Compiler.libText : any
>类型别名 :=> 任意
>Harness.Compiler : typeof Compiler
>Harness : typeof Harness
>Compiler : typeof Compiler
>libText : any
>类型别名 :=> 任意
>"lib.d.ts" : "lib.d.ts"
>true : true
>类型别名 :=> 为真

            return compiler;
>compiler : any
>类型别名 :=> 任意
        }

        var compiler: TypeScript.TypeScriptCompiler;
>compiler : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>TypeScriptCompiler : No type information available!

        recreate();
>recreate() : void
>类型别名 :=> 无值
>recreate : () => void

        // pullUpdateUnit is sufficient if an existing unit is updated, if a new unit is added we need to do a full typecheck
        var needsFullTypeCheck = true;
>needsFullTypeCheck : boolean
>类型别名 :=> 真假
>true : true
>类型别名 :=> 为真

        export function compile(code?: string, filename?: string) {
>compile : (code?: string, filename?: string) => void
>code : string
>类型别名 :=> 文字
>filename : string
>类型别名 :=> 文字

            if (usePull) {
>usePull : boolean
>类型别名 :=> 真假

                if (needsFullTypeCheck) {
>needsFullTypeCheck : boolean
>类型别名 :=> 真假

                    compiler.pullTypeCheck(true);
>compiler.pullTypeCheck(true) : any
>类型别名 :=> 任意
>compiler.pullTypeCheck : any
>类型别名 :=> 任意
>compiler : any
>类型别名 :=> 任意
>pullTypeCheck : any
>类型别名 :=> 任意
>true : true
>类型别名 :=> 为真

                    needsFullTypeCheck = false;
>needsFullTypeCheck = false : false
>类型别名 :=> 为假
>needsFullTypeCheck : boolean
>类型别名 :=> 真假
>false : false
>类型别名 :=> 为假
                }
                else {
                    // requires unit to already exist in the compiler
                    compiler.pullUpdateUnit(new TypeScript.StringSourceText(""), filename, true);
>compiler.pullUpdateUnit(new TypeScript.StringSourceText(""), filename, true) : any
>类型别名 :=> 任意
>compiler.pullUpdateUnit : any
>类型别名 :=> 任意
>compiler : any
>类型别名 :=> 任意
>pullUpdateUnit : any
>类型别名 :=> 任意
>new TypeScript.StringSourceText("") : any
>类型别名 :=> 任意
>TypeScript.StringSourceText : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>StringSourceText : any
>类型别名 :=> 任意
>"" : ""
>filename : string
>类型别名 :=> 文字
>true : true
>类型别名 :=> 为真

                    compiler.pullUpdateUnit(new TypeScript.StringSourceText(code), filename, true);
>compiler.pullUpdateUnit(new TypeScript.StringSourceText(code), filename, true) : any
>类型别名 :=> 任意
>compiler.pullUpdateUnit : any
>类型别名 :=> 任意
>compiler : any
>类型别名 :=> 任意
>pullUpdateUnit : any
>类型别名 :=> 任意
>new TypeScript.StringSourceText(code) : any
>类型别名 :=> 任意
>TypeScript.StringSourceText : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>StringSourceText : any
>类型别名 :=> 任意
>code : string
>类型别名 :=> 文字
>filename : string
>类型别名 :=> 文字
>true : true
>类型别名 :=> 为真
                }
            }
            else {
                compiler.reTypeCheck();
>compiler.reTypeCheck() : any
>类型别名 :=> 任意
>compiler.reTypeCheck : any
>类型别名 :=> 任意
>compiler : any
>类型别名 :=> 任意
>reTypeCheck : any
>类型别名 :=> 任意
            }
        }

        // Types
        export class Type {
>Type : Type

            constructor(public type, public code, public identifier) { }
>type : any
>类型别名 :=> 任意
>code : any
>类型别名 :=> 任意
>identifier : any
>类型别名 :=> 任意

            public normalizeToArray(arg: any) {
>normalizeToArray : (arg: any) => any[]
>arg : any
>类型别名 :=> 任意

                if ((Array.isArray && Array.isArray(arg)) || arg instanceof Array)
>(Array.isArray && Array.isArray(arg)) || arg instanceof Array : boolean
>类型别名 :=> 真假
>(Array.isArray && Array.isArray(arg)) : boolean
>类型别名 :=> 真假
>Array.isArray && Array.isArray(arg) : boolean
>类型别名 :=> 真假
>Array.isArray : (arg: any) => arg is any[]
>Array : ArrayConstructor
>isArray : (arg: any) => arg is any[]
>Array.isArray(arg) : boolean
>类型别名 :=> 真假
>Array.isArray : (arg: any) => arg is any[]
>Array : ArrayConstructor
>isArray : (arg: any) => arg is any[]
>arg : any
>类型别名 :=> 任意
>arg instanceof Array : boolean
>类型别名 :=> 真假
>arg : any
>类型别名 :=> 任意
>Array : ArrayConstructor

                    return arg;
>arg : any[]

                return [arg];
>[arg] : any[]
>arg : any
>类型别名 :=> 任意
            }

            public compilesOk(testCode): boolean {
>compilesOk : (testCode: any) => boolean
>testCode : any
>类型别名 :=> 任意

                var errors = null;
>errors : any
>类型别名 :=> 任意
>null : null
>类型别名 :=> 空值

                compileString(testCode, 'test.ts', function (compilerResult) {
>compileString(testCode, 'test.ts', function (compilerResult) {                    errors = compilerResult.errors;                }) : void
>类型别名 :=> 无值
>compileString : (code: string, unitName: string, callback: (res: CompilerResult) => void, context?: CompilationContext, references?: any[]) => void
>testCode : any
>类型别名 :=> 任意
>'test.ts' : "test.ts"
>function (compilerResult) {                    errors = compilerResult.errors;                } : (compilerResult: CompilerResult) => void
>compilerResult : CompilerResult

                    errors = compilerResult.errors;
>errors = compilerResult.errors : CompilerError[]
>errors : any
>类型别名 :=> 任意
>compilerResult.errors : CompilerError[]
>compilerResult : CompilerResult
>errors : CompilerError[]

                })

                return errors.length === 0;
>errors.length === 0 : boolean
>类型别名 :=> 真假
>errors.length : any
>类型别名 :=> 任意
>errors : any
>类型别名 :=> 任意
>length : any
>类型别名 :=> 任意
>0 : 0
            }

            public isSubtypeOf(other: Type) {
>isSubtypeOf : (other: Type) => boolean
>other : Type
>Type : Type

                var testCode = 'class __test1__ {\n';
>testCode : string
>类型别名 :=> 文字
>'class __test1__ {\n' : "class __test1__ {\n"

                testCode += '    public test() {\n';
>testCode += '    public test() {\n' : string
>类型别名 :=> 文字
>testCode : string
>类型别名 :=> 文字
>'    public test() {\n' : "    public test() {\n"

                testCode += '        ' + other.code + ';\n';
>testCode += '        ' + other.code + ';\n' : string
>类型别名 :=> 文字
>testCode : string
>类型别名 :=> 文字
>'        ' + other.code + ';\n' : string
>类型别名 :=> 文字
>'        ' + other.code : string
>类型别名 :=> 文字
>'        ' : "        "
>other.code : any
>类型别名 :=> 任意
>other : Type
>code : any
>类型别名 :=> 任意
>';\n' : ";\n"

                testCode += '        return ' + other.identifier + ';\n';
>testCode += '        return ' + other.identifier + ';\n' : string
>类型别名 :=> 文字
>testCode : string
>类型别名 :=> 文字
>'        return ' + other.identifier + ';\n' : string
>类型别名 :=> 文字
>'        return ' + other.identifier : string
>类型别名 :=> 文字
>'        return ' : "        return "
>other.identifier : any
>类型别名 :=> 任意
>other : Type
>identifier : any
>类型别名 :=> 任意
>';\n' : ";\n"

                testCode += '    }\n';
>testCode += '    }\n' : string
>类型别名 :=> 文字
>testCode : string
>类型别名 :=> 文字
>'    }\n' : "    }\n"

                testCode += '}\n';
>testCode += '}\n' : string
>类型别名 :=> 文字
>testCode : string
>类型别名 :=> 文字
>'}\n' : "}\n"

                testCode += 'class __test2__ extends __test1__ {\n';
>testCode += 'class __test2__ extends __test1__ {\n' : string
>类型别名 :=> 文字
>testCode : string
>类型别名 :=> 文字
>'class __test2__ extends __test1__ {\n' : "class __test2__ extends __test1__ {\n"

                testCode += '    public test() {\n';
>testCode += '    public test() {\n' : string
>类型别名 :=> 文字
>testCode : string
>类型别名 :=> 文字
>'    public test() {\n' : "    public test() {\n"

                testCode += '        ' + this.code + ';\n';
>testCode += '        ' + this.code + ';\n' : string
>类型别名 :=> 文字
>testCode : string
>类型别名 :=> 文字
>'        ' + this.code + ';\n' : string
>类型别名 :=> 文字
>'        ' + this.code : string
>类型别名 :=> 文字
>'        ' : "        "
>this.code : any
>类型别名 :=> 任意
>this : this
>code : any
>类型别名 :=> 任意
>';\n' : ";\n"

                testCode += '        return ' + other.identifier + ';\n';
>testCode += '        return ' + other.identifier + ';\n' : string
>类型别名 :=> 文字
>testCode : string
>类型别名 :=> 文字
>'        return ' + other.identifier + ';\n' : string
>类型别名 :=> 文字
>'        return ' + other.identifier : string
>类型别名 :=> 文字
>'        return ' : "        return "
>other.identifier : any
>类型别名 :=> 任意
>other : Type
>identifier : any
>类型别名 :=> 任意
>';\n' : ";\n"

                testCode += '    }\n';
>testCode += '    }\n' : string
>类型别名 :=> 文字
>testCode : string
>类型别名 :=> 文字
>'    }\n' : "    }\n"

                testCode += '}\n';
>testCode += '}\n' : string
>类型别名 :=> 文字
>testCode : string
>类型别名 :=> 文字
>'}\n' : "}\n"

                return this.compilesOk(testCode);
>this.compilesOk(testCode) : boolean
>类型别名 :=> 真假
>this.compilesOk : (testCode: any) => boolean
>this : this
>compilesOk : (testCode: any) => boolean
>testCode : string
>类型别名 :=> 文字
            }

            // TODO: Find an implementation of isIdenticalTo that works.
            //public isIdenticalTo(other: Type) {
            //    var testCode = 'module __test1__ {\n';
            //    testCode += '    ' + this.code + ';\n';
            //    testCode += '    export var __val__ = ' + this.identifier + ';\n';
            //    testCode += '}\n';
            //    testCode += 'var __test1__val__ = __test1__.__val__;\n';

            //    testCode += 'module __test2__ {\n';
            //    testCode += '    ' + other.code + ';\n';
            //    testCode += '    export var __val__ = ' + other.identifier + ';\n';
            //    testCode += '}\n';
            //    testCode += 'var __test2__val__ = __test2__.__val__;\n';

            //    testCode += 'function __test__function__() { if(true) { return __test1__val__ }; return __test2__val__; }';

            //    return this.compilesOk(testCode);
            //}

            public assertSubtypeOf(others: any) {
>assertSubtypeOf : (others: any) => void
>others : any
>类型别名 :=> 任意

                others = this.normalizeToArray(others);
>others = this.normalizeToArray(others) : any[]
>others : any
>类型别名 :=> 任意
>this.normalizeToArray(others) : any[]
>this.normalizeToArray : (arg: any) => any[]
>this : this
>normalizeToArray : (arg: any) => any[]
>others : any
>类型别名 :=> 任意

                for (var i = 0; i < others.length; i++) {
>i : number
>类型别名 :=> 数字
>0 : 0
>i < others.length : boolean
>类型别名 :=> 真假
>i : number
>类型别名 :=> 数字
>others.length : any
>类型别名 :=> 任意
>others : any
>类型别名 :=> 任意
>length : any
>类型别名 :=> 任意
>i++ : number
>类型别名 :=> 数字
>i : number
>类型别名 :=> 数字

                    if (!this.isSubtypeOf(others[i])) {
>!this.isSubtypeOf(others[i]) : boolean
>类型别名 :=> 真假
>this.isSubtypeOf(others[i]) : boolean
>类型别名 :=> 真假
>this.isSubtypeOf : (other: Type) => boolean
>this : this
>isSubtypeOf : (other: Type) => boolean
>others[i] : any
>类型别名 :=> 任意
>others : any
>类型别名 :=> 任意
>i : number
>类型别名 :=> 数字

                        throw new Error("Expected " + this.type + " to be a subtype of " + others[i].type);
>new Error("Expected " + this.type + " to be a subtype of " + others[i].type) : Error
>Error : ErrorConstructor
>"Expected " + this.type + " to be a subtype of " + others[i].type : string
>类型别名 :=> 文字
>"Expected " + this.type + " to be a subtype of " : string
>类型别名 :=> 文字
>"Expected " + this.type : string
>类型别名 :=> 文字
>"Expected " : "Expected "
>this.type : any
>类型别名 :=> 任意
>this : this
>type : any
>类型别名 :=> 任意
>" to be a subtype of " : " to be a subtype of "
>others[i].type : any
>类型别名 :=> 任意
>others[i] : any
>类型别名 :=> 任意
>others : any
>类型别名 :=> 任意
>i : number
>类型别名 :=> 数字
>type : any
>类型别名 :=> 任意
                    }
                }
            }

            public assertNotSubtypeOf(others: any) {
>assertNotSubtypeOf : (others: any) => void
>others : any
>类型别名 :=> 任意

                others = this.normalizeToArray(others);
>others = this.normalizeToArray(others) : any[]
>others : any
>类型别名 :=> 任意
>this.normalizeToArray(others) : any[]
>this.normalizeToArray : (arg: any) => any[]
>this : this
>normalizeToArray : (arg: any) => any[]
>others : any
>类型别名 :=> 任意

                for (var i = 0; i < others.length; i++) {
>i : number
>类型别名 :=> 数字
>0 : 0
>i < others.length : boolean
>类型别名 :=> 真假
>i : number
>类型别名 :=> 数字
>others.length : any
>类型别名 :=> 任意
>others : any
>类型别名 :=> 任意
>length : any
>类型别名 :=> 任意
>i++ : number
>类型别名 :=> 数字
>i : number
>类型别名 :=> 数字

                    if (this.isSubtypeOf(others[i])) {
>this.isSubtypeOf(others[i]) : boolean
>类型别名 :=> 真假
>this.isSubtypeOf : (other: Type) => boolean
>this : this
>isSubtypeOf : (other: Type) => boolean
>others[i] : any
>类型别名 :=> 任意
>others : any
>类型别名 :=> 任意
>i : number
>类型别名 :=> 数字

                        throw new Error("Expected " + this.type + " to be a subtype of " + others[i].type);
>new Error("Expected " + this.type + " to be a subtype of " + others[i].type) : Error
>Error : ErrorConstructor
>"Expected " + this.type + " to be a subtype of " + others[i].type : string
>类型别名 :=> 文字
>"Expected " + this.type + " to be a subtype of " : string
>类型别名 :=> 文字
>"Expected " + this.type : string
>类型别名 :=> 文字
>"Expected " : "Expected "
>this.type : any
>类型别名 :=> 任意
>this : this
>type : any
>类型别名 :=> 任意
>" to be a subtype of " : " to be a subtype of "
>others[i].type : any
>类型别名 :=> 任意
>others[i] : any
>类型别名 :=> 任意
>others : any
>类型别名 :=> 任意
>i : number
>类型别名 :=> 数字
>type : any
>类型别名 :=> 任意
                    }
                }
            }

            //public assertIdenticalTo(other: Type) {
            //    if (!this.isIdenticalTo(other)) {
            //        throw new Error("Expected " + this.type + " to be identical to " + other.type);
            //    }
            //}

            //public assertNotIdenticalTo(other: Type) {
            //    if (!this.isIdenticalTo(other)) {
            //        throw new Error("Expected " + this.type + " to not be identical to " + other.type);
            //    }
            //}

            public isAssignmentCompatibleWith(other: Type) {
>isAssignmentCompatibleWith : (other: Type) => boolean
>other : Type
>Type : Type

                var testCode = 'module __test1__ {\n';
>testCode : string
>类型别名 :=> 文字
>'module __test1__ {\n' : "module __test1__ {\n"

                testCode += '    ' + this.code + ';\n';
>testCode += '    ' + this.code + ';\n' : string
>类型别名 :=> 文字
>testCode : string
>类型别名 :=> 文字
>'    ' + this.code + ';\n' : string
>类型别名 :=> 文字
>'    ' + this.code : string
>类型别名 :=> 文字
>'    ' : "    "
>this.code : any
>类型别名 :=> 任意
>this : this
>code : any
>类型别名 :=> 任意
>';\n' : ";\n"

                testCode += '    export var __val__ = ' + this.identifier + ';\n';
>testCode += '    export var __val__ = ' + this.identifier + ';\n' : string
>类型别名 :=> 文字
>testCode : string
>类型别名 :=> 文字
>'    export var __val__ = ' + this.identifier + ';\n' : string
>类型别名 :=> 文字
>'    export var __val__ = ' + this.identifier : string
>类型别名 :=> 文字
>'    export var __val__ = ' : "    export var __val__ = "
>this.identifier : any
>类型别名 :=> 任意
>this : this
>identifier : any
>类型别名 :=> 任意
>';\n' : ";\n"

                testCode += '}\n';
>testCode += '}\n' : string
>类型别名 :=> 文字
>testCode : string
>类型别名 :=> 文字
>'}\n' : "}\n"

                testCode += 'var __test1__val__ = __test1__.__val__;\n';
>testCode += 'var __test1__val__ = __test1__.__val__;\n' : string
>类型别名 :=> 文字
>testCode : string
>类型别名 :=> 文字
>'var __test1__val__ = __test1__.__val__;\n' : "var __test1__val__ = __test1__.__val__;\n"

                testCode += 'module __test2__ {\n';
>testCode += 'module __test2__ {\n' : string
>类型别名 :=> 文字
>testCode : string
>类型别名 :=> 文字
>'module __test2__ {\n' : "module __test2__ {\n"

                testCode += '    export ' + other.code + ';\n';
>testCode += '    export ' + other.code + ';\n' : string
>类型别名 :=> 文字
>testCode : string
>类型别名 :=> 文字
>'    export ' + other.code + ';\n' : string
>类型别名 :=> 文字
>'    export ' + other.code : string
>类型别名 :=> 文字
>'    export ' : "    export "
>other.code : any
>类型别名 :=> 任意
>other : Type
>code : any
>类型别名 :=> 任意
>';\n' : ";\n"

                testCode += '    export var __val__ = ' + other.identifier + ';\n';
>testCode += '    export var __val__ = ' + other.identifier + ';\n' : string
>类型别名 :=> 文字
>testCode : string
>类型别名 :=> 文字
>'    export var __val__ = ' + other.identifier + ';\n' : string
>类型别名 :=> 文字
>'    export var __val__ = ' + other.identifier : string
>类型别名 :=> 文字
>'    export var __val__ = ' : "    export var __val__ = "
>other.identifier : any
>类型别名 :=> 任意
>other : Type
>identifier : any
>类型别名 :=> 任意
>';\n' : ";\n"

                testCode += '}\n';
>testCode += '}\n' : string
>类型别名 :=> 文字
>testCode : string
>类型别名 :=> 文字
>'}\n' : "}\n"

                testCode += 'var __test2__val__ = __test2__.__val__;\n';
>testCode += 'var __test2__val__ = __test2__.__val__;\n' : string
>类型别名 :=> 文字
>testCode : string
>类型别名 :=> 文字
>'var __test2__val__ = __test2__.__val__;\n' : "var __test2__val__ = __test2__.__val__;\n"

                testCode += '__test2__val__ = __test1__val__;';
>testCode += '__test2__val__ = __test1__val__;' : string
>类型别名 :=> 文字
>testCode : string
>类型别名 :=> 文字
>'__test2__val__ = __test1__val__;' : "__test2__val__ = __test1__val__;"

                return this.compilesOk(testCode);
>this.compilesOk(testCode) : boolean
>类型别名 :=> 真假
>this.compilesOk : (testCode: any) => boolean
>this : this
>compilesOk : (testCode: any) => boolean
>testCode : string
>类型别名 :=> 文字
            }

            public assertAssignmentCompatibleWith(others: any) {
>assertAssignmentCompatibleWith : (others: any) => void
>others : any
>类型别名 :=> 任意

                others = this.normalizeToArray(others);
>others = this.normalizeToArray(others) : any[]
>others : any
>类型别名 :=> 任意
>this.normalizeToArray(others) : any[]
>this.normalizeToArray : (arg: any) => any[]
>this : this
>normalizeToArray : (arg: any) => any[]
>others : any
>类型别名 :=> 任意

                for (var i = 0; i < others.length; i++) {
>i : number
>类型别名 :=> 数字
>0 : 0
>i < others.length : boolean
>类型别名 :=> 真假
>i : number
>类型别名 :=> 数字
>others.length : any
>类型别名 :=> 任意
>others : any
>类型别名 :=> 任意
>length : any
>类型别名 :=> 任意
>i++ : number
>类型别名 :=> 数字
>i : number
>类型别名 :=> 数字

                    var other = others[i];
>other : any
>类型别名 :=> 任意
>others[i] : any
>类型别名 :=> 任意
>others : any
>类型别名 :=> 任意
>i : number
>类型别名 :=> 数字

                    if (!this.isAssignmentCompatibleWith(other)) {
>!this.isAssignmentCompatibleWith(other) : boolean
>类型别名 :=> 真假
>this.isAssignmentCompatibleWith(other) : boolean
>类型别名 :=> 真假
>this.isAssignmentCompatibleWith : (other: Type) => boolean
>this : this
>isAssignmentCompatibleWith : (other: Type) => boolean
>other : any
>类型别名 :=> 任意

                        throw new Error("Expected " + this.type + " to be assignment compatible with " + other.type);
>new Error("Expected " + this.type + " to be assignment compatible with " + other.type) : Error
>Error : ErrorConstructor
>"Expected " + this.type + " to be assignment compatible with " + other.type : string
>类型别名 :=> 文字
>"Expected " + this.type + " to be assignment compatible with " : string
>类型别名 :=> 文字
>"Expected " + this.type : string
>类型别名 :=> 文字
>"Expected " : "Expected "
>this.type : any
>类型别名 :=> 任意
>this : this
>type : any
>类型别名 :=> 任意
>" to be assignment compatible with " : " to be assignment compatible with "
>other.type : any
>类型别名 :=> 任意
>other : any
>类型别名 :=> 任意
>type : any
>类型别名 :=> 任意
                    }
                }
            }

            public assertNotAssignmentCompatibleWith(others: any) {
>assertNotAssignmentCompatibleWith : (others: any) => void
>others : any
>类型别名 :=> 任意

                others = this.normalizeToArray(others);
>others = this.normalizeToArray(others) : any[]
>others : any
>类型别名 :=> 任意
>this.normalizeToArray(others) : any[]
>this.normalizeToArray : (arg: any) => any[]
>this : this
>normalizeToArray : (arg: any) => any[]
>others : any
>类型别名 :=> 任意

                for (var i = 0; i < others.length; i++) {
>i : number
>类型别名 :=> 数字
>0 : 0
>i < others.length : boolean
>类型别名 :=> 真假
>i : number
>类型别名 :=> 数字
>others.length : any
>类型别名 :=> 任意
>others : any
>类型别名 :=> 任意
>length : any
>类型别名 :=> 任意
>i++ : number
>类型别名 :=> 数字
>i : number
>类型别名 :=> 数字

                    var other = others[i];
>other : any
>类型别名 :=> 任意
>others[i] : any
>类型别名 :=> 任意
>others : any
>类型别名 :=> 任意
>i : number
>类型别名 :=> 数字

                    if (this.isAssignmentCompatibleWith(other)) {
>this.isAssignmentCompatibleWith(other) : boolean
>类型别名 :=> 真假
>this.isAssignmentCompatibleWith : (other: Type) => boolean
>this : this
>isAssignmentCompatibleWith : (other: Type) => boolean
>other : any
>类型别名 :=> 任意

                        throw new Error("Expected " + this.type + " to not be assignment compatible with " + other.type);
>new Error("Expected " + this.type + " to not be assignment compatible with " + other.type) : Error
>Error : ErrorConstructor
>"Expected " + this.type + " to not be assignment compatible with " + other.type : string
>类型别名 :=> 文字
>"Expected " + this.type + " to not be assignment compatible with " : string
>类型别名 :=> 文字
>"Expected " + this.type : string
>类型别名 :=> 文字
>"Expected " : "Expected "
>this.type : any
>类型别名 :=> 任意
>this : this
>type : any
>类型别名 :=> 任意
>" to not be assignment compatible with " : " to not be assignment compatible with "
>other.type : any
>类型别名 :=> 任意
>other : any
>类型别名 :=> 任意
>type : any
>类型别名 :=> 任意
                    }
                }
            }

            public assertThisCanBeAssignedTo(desc: string, these: any[], notThese: any[]) {
>assertThisCanBeAssignedTo : (desc: string, these: any[], notThese: any[]) => void
>desc : string
>类型别名 :=> 文字
>these : any[]
>notThese : any[]

                it(desc + " is assignable to ", () => {
>it(desc + " is assignable to ", () => {                    this.assertAssignmentCompatibleWith(these);                }) : void
>类型别名 :=> 无值
>it : (description: string, block: () => void) => void
>desc + " is assignable to " : string
>类型别名 :=> 文字
>desc : string
>类型别名 :=> 文字
>" is assignable to " : " is assignable to "
>() => {                    this.assertAssignmentCompatibleWith(these);                } : () => void

                    this.assertAssignmentCompatibleWith(these);
>this.assertAssignmentCompatibleWith(these) : void
>类型别名 :=> 无值
>this.assertAssignmentCompatibleWith : (others: any) => void
>this : this
>assertAssignmentCompatibleWith : (others: any) => void
>these : any[]

                });
        
                it(desc + " not assignable to ", () => {
>it(desc + " not assignable to ", () => {                    this.assertNotAssignmentCompatibleWith(notThese);                }) : void
>类型别名 :=> 无值
>it : (description: string, block: () => void) => void
>desc + " not assignable to " : string
>类型别名 :=> 文字
>desc : string
>类型别名 :=> 文字
>" not assignable to " : " not assignable to "
>() => {                    this.assertNotAssignmentCompatibleWith(notThese);                } : () => void

                    this.assertNotAssignmentCompatibleWith(notThese);
>this.assertNotAssignmentCompatibleWith(notThese) : void
>类型别名 :=> 无值
>this.assertNotAssignmentCompatibleWith : (others: any) => void
>this : this
>assertNotAssignmentCompatibleWith : (others: any) => void
>notThese : any[]

                });
            }

        }

        export class TypeFactory {
>TypeFactory : TypeFactory

            public any: Type;
>any : Type
>Type : Type

            public number: Type;
>number : Type
>Type : Type

            public string: Type;
>string : Type
>Type : Type

            public boolean: Type;
>boolean : Type
>Type : Type

            constructor() {
                this.any = this.get('var x : any', 'x');
>this.any = this.get('var x : any', 'x') : Type
>this.any : Type
>this : this
>any : Type
>this.get('var x : any', 'x') : Type
>this.get : (code: string, target: any) => Type
>this : this
>get : (code: string, target: any) => Type
>'var x : any' : "var x : any"
>'x' : "x"

                this.number = this.get('var x : number', 'x');
>this.number = this.get('var x : number', 'x') : Type
>this.number : Type
>this : this
>number : Type
>this.get('var x : number', 'x') : Type
>this.get : (code: string, target: any) => Type
>this : this
>get : (code: string, target: any) => Type
>'var x : number' : "var x : number"
>'x' : "x"

                this.string = this.get('var x : string', 'x');
>this.string = this.get('var x : string', 'x') : Type
>this.string : Type
>this : this
>string : Type
>this.get('var x : string', 'x') : Type
>this.get : (code: string, target: any) => Type
>this : this
>get : (code: string, target: any) => Type
>'var x : string' : "var x : string"
>'x' : "x"

                this.boolean = this.get('var x : boolean', 'x');
>this.boolean = this.get('var x : boolean', 'x') : Type
>this.boolean : Type
>this : this
>boolean : Type
>this.get('var x : boolean', 'x') : Type
>this.get : (code: string, target: any) => Type
>this : this
>get : (code: string, target: any) => Type
>'var x : boolean' : "var x : boolean"
>'x' : "x"
            }

            public get (code: string, target: any) {
>get : (code: string, target: any) => Type
>code : string
>类型别名 :=> 文字
>target : any
>类型别名 :=> 任意

                var targetIdentifier = '';
>targetIdentifier : string
>类型别名 :=> 文字
>'' : ""

                var targetPosition = -1;
>targetPosition : number
>类型别名 :=> 数字
>-1 : -1
>1 : 1

                if (typeof target === "string") {
>typeof target === "string" : boolean
>类型别名 :=> 真假
>typeof target : "string" | "number" | "boolean" | "symbol" | "undefined" | "object" | "function" | "文字" | "数字" | "真假" | "符号" | "未定" | "对象" | "函数"
>target : any
>类型别名 :=> 任意
>"string" : "string"

                    targetIdentifier = target;
>targetIdentifier = target : string
>类型别名 :=> 文字
>targetIdentifier : string
>类型别名 :=> 文字
>target : string
>类型别名 :=> 文字
                }
                else if (typeof target === "number") {
>typeof target === "number" : boolean
>类型别名 :=> 真假
>typeof target : "string" | "number" | "boolean" | "symbol" | "undefined" | "object" | "function" | "文字" | "数字" | "真假" | "符号" | "未定" | "对象" | "函数"
>target : any
>类型别名 :=> 任意
>"number" : "number"

                    targetPosition = target;
>targetPosition = target : number
>类型别名 :=> 数字
>targetPosition : number
>类型别名 :=> 数字
>target : number
>类型别名 :=> 数字
                }
                else {
                    throw new Error("Expected string or number not " + (typeof target));
>new Error("Expected string or number not " + (typeof target)) : Error
>Error : ErrorConstructor
>"Expected string or number not " + (typeof target) : string
>类型别名 :=> 文字
>"Expected string or number not " : "Expected string or number not "
>(typeof target) : "string" | "number" | "boolean" | "symbol" | "undefined" | "object" | "function" | "文字" | "数字" | "真假" | "符号" | "未定" | "对象" | "函数"
>typeof target : "string" | "number" | "boolean" | "symbol" | "undefined" | "object" | "function" | "文字" | "数字" | "真假" | "符号" | "未定" | "对象" | "函数"
>target : any
>类型别名 :=> 任意
                }

                var errors = null;
>errors : any
>类型别名 :=> 任意
>null : null
>类型别名 :=> 空值

                compileString(code, 'test.ts', function (compilerResult) {
>compileString(code, 'test.ts', function (compilerResult) {                    errors = compilerResult.errors;                }) : void
>类型别名 :=> 无值
>compileString : (code: string, unitName: string, callback: (res: CompilerResult) => void, context?: CompilationContext, references?: any[]) => void
>code : string
>类型别名 :=> 文字
>'test.ts' : "test.ts"
>function (compilerResult) {                    errors = compilerResult.errors;                } : (compilerResult: CompilerResult) => void
>compilerResult : CompilerResult

                    errors = compilerResult.errors;
>errors = compilerResult.errors : CompilerError[]
>errors : any
>类型别名 :=> 任意
>compilerResult.errors : CompilerError[]
>compilerResult : CompilerResult
>errors : CompilerError[]

                })

                if (errors.length > 0)
>errors.length > 0 : boolean
>类型别名 :=> 真假
>errors.length : any
>类型别名 :=> 任意
>errors : any
>类型别名 :=> 任意
>length : any
>类型别名 :=> 任意
>0 : 0

                    throw new Error("Type definition contains errors: " + errors.join(","));
>new Error("Type definition contains errors: " + errors.join(",")) : Error
>Error : ErrorConstructor
>"Type definition contains errors: " + errors.join(",") : string
>类型别名 :=> 文字
>"Type definition contains errors: " : "Type definition contains errors: "
>errors.join(",") : any
>类型别名 :=> 任意
>errors.join : any
>类型别名 :=> 任意
>errors : any
>类型别名 :=> 任意
>join : any
>类型别名 :=> 任意
>"," : ","

                var matchingIdentifiers: Type[] = [];
>matchingIdentifiers : Type[]
>Type : Type
>[] : undefined[]

                if (!usePull) {
>!usePull : boolean
>类型别名 :=> 真假
>usePull : boolean
>类型别名 :=> 真假

                    // This will find the requested identifier in the first script where it's present, a naive search of each member in each script,
                    // which means this won't play nicely if the same identifier is used in multiple units, but it will enable this to work on multi-file tests.
                    // m = 1 because the first script will always be lib.d.ts which we don't want to search.                                
                    for (var m = 1; m < compiler.scripts.members.length; m++) {
>m : number
>类型别名 :=> 数字
>1 : 1
>m < compiler.scripts.members.length : boolean
>类型别名 :=> 真假
>m : number
>类型别名 :=> 数字
>compiler.scripts.members.length : any
>类型别名 :=> 任意
>compiler.scripts.members : any
>类型别名 :=> 任意
>compiler.scripts : any
>类型别名 :=> 任意
>compiler : any
>类型别名 :=> 任意
>scripts : any
>类型别名 :=> 任意
>members : any
>类型别名 :=> 任意
>length : any
>类型别名 :=> 任意
>m++ : number
>类型别名 :=> 数字
>m : number
>类型别名 :=> 数字

                        var script = compiler.scripts.members[m];
>script : any
>类型别名 :=> 任意
>compiler.scripts.members[m] : any
>类型别名 :=> 任意
>compiler.scripts.members : any
>类型别名 :=> 任意
>compiler.scripts : any
>类型别名 :=> 任意
>compiler : any
>类型别名 :=> 任意
>scripts : any
>类型别名 :=> 任意
>members : any
>类型别名 :=> 任意
>m : number
>类型别名 :=> 数字

                        var enclosingScopeContext = TypeScript.findEnclosingScopeAt(new TypeScript.NullLogger(), <TypeScript.Script>script, new TypeScript.StringSourceText(code), 0, false);
>enclosingScopeContext : any
>类型别名 :=> 任意
>TypeScript.findEnclosingScopeAt(new TypeScript.NullLogger(), <TypeScript.Script>script, new TypeScript.StringSourceText(code), 0, false) : any
>类型别名 :=> 任意
>TypeScript.findEnclosingScopeAt : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>findEnclosingScopeAt : any
>类型别名 :=> 任意
>new TypeScript.NullLogger() : any
>类型别名 :=> 任意
>TypeScript.NullLogger : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>NullLogger : any
>类型别名 :=> 任意
><TypeScript.Script>script : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>Script : No type information available!
>script : any
>类型别名 :=> 任意
>new TypeScript.StringSourceText(code) : any
>类型别名 :=> 任意
>TypeScript.StringSourceText : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>StringSourceText : any
>类型别名 :=> 任意
>code : string
>类型别名 :=> 文字
>0 : 0
>false : false
>类型别名 :=> 为假

                        var entries = new TypeScript.ScopeTraversal(compiler).getScopeEntries(enclosingScopeContext);
>entries : any
>类型别名 :=> 任意
>new TypeScript.ScopeTraversal(compiler).getScopeEntries(enclosingScopeContext) : any
>类型别名 :=> 任意
>new TypeScript.ScopeTraversal(compiler).getScopeEntries : any
>类型别名 :=> 任意
>new TypeScript.ScopeTraversal(compiler) : any
>类型别名 :=> 任意
>TypeScript.ScopeTraversal : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>ScopeTraversal : any
>类型别名 :=> 任意
>compiler : any
>类型别名 :=> 任意
>getScopeEntries : any
>类型别名 :=> 任意
>enclosingScopeContext : any
>类型别名 :=> 任意

                        for (var i = 0; i < entries.length; i++) {
>i : number
>类型别名 :=> 数字
>0 : 0
>i < entries.length : boolean
>类型别名 :=> 真假
>i : number
>类型别名 :=> 数字
>entries.length : any
>类型别名 :=> 任意
>entries : any
>类型别名 :=> 任意
>length : any
>类型别名 :=> 任意
>i++ : number
>类型别名 :=> 数字
>i : number
>类型别名 :=> 数字

                            if (entries[i].name === targetIdentifier) {
>entries[i].name === targetIdentifier : boolean
>类型别名 :=> 真假
>entries[i].name : any
>类型别名 :=> 任意
>entries[i] : any
>类型别名 :=> 任意
>entries : any
>类型别名 :=> 任意
>i : number
>类型别名 :=> 数字
>name : any
>类型别名 :=> 任意
>targetIdentifier : string
>类型别名 :=> 文字

                                matchingIdentifiers.push(new Type(entries[i].type, code, targetIdentifier));
>matchingIdentifiers.push(new Type(entries[i].type, code, targetIdentifier)) : number
>类型别名 :=> 数字
>matchingIdentifiers.push : (...items: Type[]) => number
>matchingIdentifiers : Type[]
>push : (...items: Type[]) => number
>new Type(entries[i].type, code, targetIdentifier) : Type
>Type : typeof Type
>entries[i].type : any
>类型别名 :=> 任意
>entries[i] : any
>类型别名 :=> 任意
>entries : any
>类型别名 :=> 任意
>i : number
>类型别名 :=> 数字
>type : any
>类型别名 :=> 任意
>code : string
>类型别名 :=> 文字
>targetIdentifier : string
>类型别名 :=> 文字
                            }
                        }
                    }
                }
                else {
                    for (var m = 0; m < compiler.scripts.members.length; m++) {
>m : number
>类型别名 :=> 数字
>0 : 0
>m < compiler.scripts.members.length : boolean
>类型别名 :=> 真假
>m : number
>类型别名 :=> 数字
>compiler.scripts.members.length : any
>类型别名 :=> 任意
>compiler.scripts.members : any
>类型别名 :=> 任意
>compiler.scripts : any
>类型别名 :=> 任意
>compiler : any
>类型别名 :=> 任意
>scripts : any
>类型别名 :=> 任意
>members : any
>类型别名 :=> 任意
>length : any
>类型别名 :=> 任意
>m++ : number
>类型别名 :=> 数字
>m : number
>类型别名 :=> 数字

                        var script2 = <TypeScript.Script>compiler.scripts.members[m];
>script2 : any
>类型别名 :=> 任意
><TypeScript.Script>compiler.scripts.members[m] : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>Script : No type information available!
>compiler.scripts.members[m] : any
>类型别名 :=> 任意
>compiler.scripts.members : any
>类型别名 :=> 任意
>compiler.scripts : any
>类型别名 :=> 任意
>compiler : any
>类型别名 :=> 任意
>scripts : any
>类型别名 :=> 任意
>members : any
>类型别名 :=> 任意
>m : number
>类型别名 :=> 数字

                        if (script2.locationInfo.filename !== 'lib.d.ts') {
>script2.locationInfo.filename !== 'lib.d.ts' : boolean
>类型别名 :=> 真假
>script2.locationInfo.filename : any
>类型别名 :=> 任意
>script2.locationInfo : any
>类型别名 :=> 任意
>script2 : any
>类型别名 :=> 任意
>locationInfo : any
>类型别名 :=> 任意
>filename : any
>类型别名 :=> 任意
>'lib.d.ts' : "lib.d.ts"

                            if (targetPosition > -1) {
>targetPosition > -1 : boolean
>类型别名 :=> 真假
>targetPosition : number
>类型别名 :=> 数字
>-1 : -1
>1 : 1

                                var tyInfo = compiler.pullGetTypeInfoAtPosition(targetPosition, script2);
>tyInfo : any
>类型别名 :=> 任意
>compiler.pullGetTypeInfoAtPosition(targetPosition, script2) : any
>类型别名 :=> 任意
>compiler.pullGetTypeInfoAtPosition : any
>类型别名 :=> 任意
>compiler : any
>类型别名 :=> 任意
>pullGetTypeInfoAtPosition : any
>类型别名 :=> 任意
>targetPosition : number
>类型别名 :=> 数字
>script2 : any
>类型别名 :=> 任意

                                var name = this.getTypeInfoName(tyInfo.ast);
>name : string
>类型别名 :=> 文字
>this.getTypeInfoName(tyInfo.ast) : string
>类型别名 :=> 文字
>this.getTypeInfoName : (ast: any) => string
>this : this
>getTypeInfoName : (ast: any) => string
>tyInfo.ast : any
>类型别名 :=> 任意
>tyInfo : any
>类型别名 :=> 任意
>ast : any
>类型别名 :=> 任意

                                var foundValue = new Type(tyInfo.typeInfo, code, name);
>foundValue : Type
>new Type(tyInfo.typeInfo, code, name) : Type
>Type : typeof Type
>tyInfo.typeInfo : any
>类型别名 :=> 任意
>tyInfo : any
>类型别名 :=> 任意
>typeInfo : any
>类型别名 :=> 任意
>code : string
>类型别名 :=> 文字
>name : string
>类型别名 :=> 文字

                                if (!matchingIdentifiers.some(value => (value.identifier === foundValue.identifier) && (value.code === foundValue.code) && (value.type === foundValue.type))) {
>!matchingIdentifiers.some(value => (value.identifier === foundValue.identifier) && (value.code === foundValue.code) && (value.type === foundValue.type)) : boolean
>类型别名 :=> 真假
>matchingIdentifiers.some(value => (value.identifier === foundValue.identifier) && (value.code === foundValue.code) && (value.type === foundValue.type)) : boolean
>类型别名 :=> 真假
>matchingIdentifiers.some : (callbackfn: (value: Type, index: number, array: Type[]) => boolean, thisArg?: any) => boolean
>matchingIdentifiers : Type[]
>some : (callbackfn: (value: Type, index: number, array: Type[]) => boolean, thisArg?: any) => boolean
>value => (value.identifier === foundValue.identifier) && (value.code === foundValue.code) && (value.type === foundValue.type) : (value: Type) => boolean
>value : Type
>(value.identifier === foundValue.identifier) && (value.code === foundValue.code) && (value.type === foundValue.type) : boolean
>类型别名 :=> 真假
>(value.identifier === foundValue.identifier) && (value.code === foundValue.code) : boolean
>类型别名 :=> 真假
>(value.identifier === foundValue.identifier) : boolean
>类型别名 :=> 真假
>value.identifier === foundValue.identifier : boolean
>类型别名 :=> 真假
>value.identifier : any
>类型别名 :=> 任意
>value : Type
>identifier : any
>类型别名 :=> 任意
>foundValue.identifier : any
>类型别名 :=> 任意
>foundValue : Type
>identifier : any
>类型别名 :=> 任意
>(value.code === foundValue.code) : boolean
>类型别名 :=> 真假
>value.code === foundValue.code : boolean
>类型别名 :=> 真假
>value.code : any
>类型别名 :=> 任意
>value : Type
>code : any
>类型别名 :=> 任意
>foundValue.code : any
>类型别名 :=> 任意
>foundValue : Type
>code : any
>类型别名 :=> 任意
>(value.type === foundValue.type) : boolean
>类型别名 :=> 真假
>value.type === foundValue.type : boolean
>类型别名 :=> 真假
>value.type : any
>类型别名 :=> 任意
>value : Type
>type : any
>类型别名 :=> 任意
>foundValue.type : any
>类型别名 :=> 任意
>foundValue : Type
>type : any
>类型别名 :=> 任意

                                    matchingIdentifiers.push(foundValue);
>matchingIdentifiers.push(foundValue) : number
>类型别名 :=> 数字
>matchingIdentifiers.push : (...items: Type[]) => number
>matchingIdentifiers : Type[]
>push : (...items: Type[]) => number
>foundValue : Type
                                }
                            }
                            else {
                                for (var pos = 0; pos < code.length; pos++) {
>pos : number
>类型别名 :=> 数字
>0 : 0
>pos < code.length : boolean
>类型别名 :=> 真假
>pos : number
>类型别名 :=> 数字
>code.length : number
>类型别名 :=> 数字
>code : string
>类型别名 :=> 文字
>length : number
>类型别名 :=> 数字
>pos++ : number
>类型别名 :=> 数字
>pos : number
>类型别名 :=> 数字

                                    var tyInfo = compiler.pullGetTypeInfoAtPosition(pos, script2);
>tyInfo : any
>类型别名 :=> 任意
>compiler.pullGetTypeInfoAtPosition(pos, script2) : any
>类型别名 :=> 任意
>compiler.pullGetTypeInfoAtPosition : any
>类型别名 :=> 任意
>compiler : any
>类型别名 :=> 任意
>pullGetTypeInfoAtPosition : any
>类型别名 :=> 任意
>pos : number
>类型别名 :=> 数字
>script2 : any
>类型别名 :=> 任意

                                    var name = this.getTypeInfoName(tyInfo.ast);
>name : string
>类型别名 :=> 文字
>this.getTypeInfoName(tyInfo.ast) : string
>类型别名 :=> 文字
>this.getTypeInfoName : (ast: any) => string
>this : this
>getTypeInfoName : (ast: any) => string
>tyInfo.ast : any
>类型别名 :=> 任意
>tyInfo : any
>类型别名 :=> 任意
>ast : any
>类型别名 :=> 任意

                                    if (name === targetIdentifier) {
>name === targetIdentifier : boolean
>类型别名 :=> 真假
>name : string
>类型别名 :=> 文字
>targetIdentifier : string
>类型别名 :=> 文字

                                        var foundValue = new Type(tyInfo.typeInfo, code, targetIdentifier);
>foundValue : Type
>new Type(tyInfo.typeInfo, code, targetIdentifier) : Type
>Type : typeof Type
>tyInfo.typeInfo : any
>类型别名 :=> 任意
>tyInfo : any
>类型别名 :=> 任意
>typeInfo : any
>类型别名 :=> 任意
>code : string
>类型别名 :=> 文字
>targetIdentifier : string
>类型别名 :=> 文字

                                        if (!matchingIdentifiers.some(value => (value.identifier === foundValue.identifier) && (value.code === foundValue.code) && (value.type === foundValue.type))) {
>!matchingIdentifiers.some(value => (value.identifier === foundValue.identifier) && (value.code === foundValue.code) && (value.type === foundValue.type)) : boolean
>类型别名 :=> 真假
>matchingIdentifiers.some(value => (value.identifier === foundValue.identifier) && (value.code === foundValue.code) && (value.type === foundValue.type)) : boolean
>类型别名 :=> 真假
>matchingIdentifiers.some : (callbackfn: (value: Type, index: number, array: Type[]) => boolean, thisArg?: any) => boolean
>matchingIdentifiers : Type[]
>some : (callbackfn: (value: Type, index: number, array: Type[]) => boolean, thisArg?: any) => boolean
>value => (value.identifier === foundValue.identifier) && (value.code === foundValue.code) && (value.type === foundValue.type) : (value: Type) => boolean
>value : Type
>(value.identifier === foundValue.identifier) && (value.code === foundValue.code) && (value.type === foundValue.type) : boolean
>类型别名 :=> 真假
>(value.identifier === foundValue.identifier) && (value.code === foundValue.code) : boolean
>类型别名 :=> 真假
>(value.identifier === foundValue.identifier) : boolean
>类型别名 :=> 真假
>value.identifier === foundValue.identifier : boolean
>类型别名 :=> 真假
>value.identifier : any
>类型别名 :=> 任意
>value : Type
>identifier : any
>类型别名 :=> 任意
>foundValue.identifier : any
>类型别名 :=> 任意
>foundValue : Type
>identifier : any
>类型别名 :=> 任意
>(value.code === foundValue.code) : boolean
>类型别名 :=> 真假
>value.code === foundValue.code : boolean
>类型别名 :=> 真假
>value.code : any
>类型别名 :=> 任意
>value : Type
>code : any
>类型别名 :=> 任意
>foundValue.code : any
>类型别名 :=> 任意
>foundValue : Type
>code : any
>类型别名 :=> 任意
>(value.type === foundValue.type) : boolean
>类型别名 :=> 真假
>value.type === foundValue.type : boolean
>类型别名 :=> 真假
>value.type : any
>类型别名 :=> 任意
>value : Type
>type : any
>类型别名 :=> 任意
>foundValue.type : any
>类型别名 :=> 任意
>foundValue : Type
>type : any
>类型别名 :=> 任意

                                            matchingIdentifiers.push(foundValue);
>matchingIdentifiers.push(foundValue) : number
>类型别名 :=> 数字
>matchingIdentifiers.push : (...items: Type[]) => number
>matchingIdentifiers : Type[]
>push : (...items: Type[]) => number
>foundValue : Type
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                if (matchingIdentifiers.length === 0) {
>matchingIdentifiers.length === 0 : boolean
>类型别名 :=> 真假
>matchingIdentifiers.length : number
>类型别名 :=> 数字
>matchingIdentifiers : Type[]
>length : number
>类型别名 :=> 数字
>0 : 0

                    if (targetPosition > -1) {
>targetPosition > -1 : boolean
>类型别名 :=> 真假
>targetPosition : number
>类型别名 :=> 数字
>-1 : -1
>1 : 1

                        throw new Error("Could not find an identifier at position " + targetPosition);
>new Error("Could not find an identifier at position " + targetPosition) : Error
>Error : ErrorConstructor
>"Could not find an identifier at position " + targetPosition : string
>类型别名 :=> 文字
>"Could not find an identifier at position " : "Could not find an identifier at position "
>targetPosition : number
>类型别名 :=> 数字
                    }
                    else {
                        throw new Error("Could not find an identifier " + targetIdentifier + " in any known scopes");
>new Error("Could not find an identifier " + targetIdentifier + " in any known scopes") : Error
>Error : ErrorConstructor
>"Could not find an identifier " + targetIdentifier + " in any known scopes" : string
>类型别名 :=> 文字
>"Could not find an identifier " + targetIdentifier : string
>类型别名 :=> 文字
>"Could not find an identifier " : "Could not find an identifier "
>targetIdentifier : string
>类型别名 :=> 文字
>" in any known scopes" : " in any known scopes"
                    }
                }
                else if (matchingIdentifiers.length > 1) {
>matchingIdentifiers.length > 1 : boolean
>类型别名 :=> 真假
>matchingIdentifiers.length : number
>类型别名 :=> 数字
>matchingIdentifiers : Type[]
>length : number
>类型别名 :=> 数字
>1 : 1

                    throw new Error("Found multiple matching identifiers for " + target);
>new Error("Found multiple matching identifiers for " + target) : Error
>Error : ErrorConstructor
>"Found multiple matching identifiers for " + target : string
>类型别名 :=> 文字
>"Found multiple matching identifiers for " : "Found multiple matching identifiers for "
>target : string | number
                }
                else {
                    return matchingIdentifiers[0];
>matchingIdentifiers[0] : Type
>matchingIdentifiers : Type[]
>0 : 0
                }
            }

            private getTypeInfoName(ast : TypeScript.AST) {
>getTypeInfoName : (ast: any) => string
>ast : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>AST : No type information available!

                var name = '';
>name : string
>类型别名 :=> 文字
>'' : ""

                switch (ast.nodeType) {
>ast.nodeType : any
>类型别名 :=> 任意
>ast : any
>类型别名 :=> 任意
>nodeType : any
>类型别名 :=> 任意

                    case TypeScript.NodeType.Name: // Type Name?
>TypeScript.NodeType.Name : any
>类型别名 :=> 任意
>TypeScript.NodeType : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>NodeType : any
>类型别名 :=> 任意
>Name : any
>类型别名 :=> 任意

                    case TypeScript.NodeType.Null:
>TypeScript.NodeType.Null : any
>类型别名 :=> 任意
>TypeScript.NodeType : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>NodeType : any
>类型别名 :=> 任意
>Null : any
>类型别名 :=> 任意

                    case TypeScript.NodeType.List:
>TypeScript.NodeType.List : any
>类型别名 :=> 任意
>TypeScript.NodeType : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>NodeType : any
>类型别名 :=> 任意
>List : any
>类型别名 :=> 任意

                    case TypeScript.NodeType.Empty:
>TypeScript.NodeType.Empty : any
>类型别名 :=> 任意
>TypeScript.NodeType : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>NodeType : any
>类型别名 :=> 任意
>Empty : any
>类型别名 :=> 任意

                    case TypeScript.NodeType.EmptyExpr:
>TypeScript.NodeType.EmptyExpr : any
>类型别名 :=> 任意
>TypeScript.NodeType : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>NodeType : any
>类型别名 :=> 任意
>EmptyExpr : any
>类型别名 :=> 任意

                    case TypeScript.NodeType.Asg:
>TypeScript.NodeType.Asg : any
>类型别名 :=> 任意
>TypeScript.NodeType : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>NodeType : any
>类型别名 :=> 任意
>Asg : any
>类型别名 :=> 任意

                    case TypeScript.NodeType.True:
>TypeScript.NodeType.True : any
>类型别名 :=> 任意
>TypeScript.NodeType : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>NodeType : any
>类型别名 :=> 任意
>True : any
>类型别名 :=> 任意

                    case TypeScript.NodeType.False:
>TypeScript.NodeType.False : any
>类型别名 :=> 任意
>TypeScript.NodeType : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>NodeType : any
>类型别名 :=> 任意
>False : any
>类型别名 :=> 任意

                    case TypeScript.NodeType.ArrayLit:
>TypeScript.NodeType.ArrayLit : any
>类型别名 :=> 任意
>TypeScript.NodeType : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>NodeType : any
>类型别名 :=> 任意
>ArrayLit : any
>类型别名 :=> 任意

                    case TypeScript.NodeType.TypeRef:
>TypeScript.NodeType.TypeRef : any
>类型别名 :=> 任意
>TypeScript.NodeType : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>NodeType : any
>类型别名 :=> 任意
>TypeRef : any
>类型别名 :=> 任意

                        break;
                    case TypeScript.NodeType.Super:
>TypeScript.NodeType.Super : any
>类型别名 :=> 任意
>TypeScript.NodeType : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>NodeType : any
>类型别名 :=> 任意
>Super : any
>类型别名 :=> 任意

                        name = (<any>ast).text;
>name = (<any>ast).text : any
>类型别名 :=> 任意
>name : string
>类型别名 :=> 文字
>(<any>ast).text : any
>类型别名 :=> 任意
>(<any>ast) : any
>类型别名 :=> 任意
><any>ast : any
>类型别名 :=> 任意
>ast : any
>类型别名 :=> 任意
>text : any
>类型别名 :=> 任意

                        break;
                    case TypeScript.NodeType.Regex:
>TypeScript.NodeType.Regex : any
>类型别名 :=> 任意
>TypeScript.NodeType : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>NodeType : any
>类型别名 :=> 任意
>Regex : any
>类型别名 :=> 任意

                        name = (<TypeScript.RegexLiteral>ast).text;
>name = (<TypeScript.RegexLiteral>ast).text : any
>类型别名 :=> 任意
>name : string
>类型别名 :=> 文字
>(<TypeScript.RegexLiteral>ast).text : any
>类型别名 :=> 任意
>(<TypeScript.RegexLiteral>ast) : any
>类型别名 :=> 任意
><TypeScript.RegexLiteral>ast : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>RegexLiteral : No type information available!
>ast : any
>类型别名 :=> 任意
>text : any
>类型别名 :=> 任意

                        break;
                    case TypeScript.NodeType.QString:
>TypeScript.NodeType.QString : any
>类型别名 :=> 任意
>TypeScript.NodeType : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>NodeType : any
>类型别名 :=> 任意
>QString : any
>类型别名 :=> 任意

                        name = (<any>ast).text;
>name = (<any>ast).text : any
>类型别名 :=> 任意
>name : string
>类型别名 :=> 文字
>(<any>ast).text : any
>类型别名 :=> 任意
>(<any>ast) : any
>类型别名 :=> 任意
><any>ast : any
>类型别名 :=> 任意
>ast : any
>类型别名 :=> 任意
>text : any
>类型别名 :=> 任意

                        break;
                    case TypeScript.NodeType.NumberLit:
>TypeScript.NodeType.NumberLit : any
>类型别名 :=> 任意
>TypeScript.NodeType : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>NodeType : any
>类型别名 :=> 任意
>NumberLit : any
>类型别名 :=> 任意

                        name = (<TypeScript.NumberLiteral>ast).text;
>name = (<TypeScript.NumberLiteral>ast).text : any
>类型别名 :=> 任意
>name : string
>类型别名 :=> 文字
>(<TypeScript.NumberLiteral>ast).text : any
>类型别名 :=> 任意
>(<TypeScript.NumberLiteral>ast) : any
>类型别名 :=> 任意
><TypeScript.NumberLiteral>ast : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>NumberLiteral : No type information available!
>ast : any
>类型别名 :=> 任意
>text : any
>类型别名 :=> 任意

                        break;
                    case TypeScript.NodeType.Return:
>TypeScript.NodeType.Return : any
>类型别名 :=> 任意
>TypeScript.NodeType : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>NodeType : any
>类型别名 :=> 任意
>Return : any
>类型别名 :=> 任意

                        //name = (<TypeScript.ReturnStatement>tyInfo.ast).returnExpression.actualText; // why is this complaining?
                        break;
                    case TypeScript.NodeType.InterfaceDeclaration:
>TypeScript.NodeType.InterfaceDeclaration : any
>类型别名 :=> 任意
>TypeScript.NodeType : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>NodeType : any
>类型别名 :=> 任意
>InterfaceDeclaration : any
>类型别名 :=> 任意

                        name = (<TypeScript.InterfaceDeclaration>ast).name.actualText;
>name = (<TypeScript.InterfaceDeclaration>ast).name.actualText : any
>类型别名 :=> 任意
>name : string
>类型别名 :=> 文字
>(<TypeScript.InterfaceDeclaration>ast).name.actualText : any
>类型别名 :=> 任意
>(<TypeScript.InterfaceDeclaration>ast).name : any
>类型别名 :=> 任意
>(<TypeScript.InterfaceDeclaration>ast) : any
>类型别名 :=> 任意
><TypeScript.InterfaceDeclaration>ast : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>InterfaceDeclaration : No type information available!
>ast : any
>类型别名 :=> 任意
>name : any
>类型别名 :=> 任意
>actualText : any
>类型别名 :=> 任意

                        break;
                    case TypeScript.NodeType.ModuleDeclaration:
>TypeScript.NodeType.ModuleDeclaration : any
>类型别名 :=> 任意
>TypeScript.NodeType : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>NodeType : any
>类型别名 :=> 任意
>ModuleDeclaration : any
>类型别名 :=> 任意

                        name = (<TypeScript.ModuleDeclaration>ast).name.actualText;
>name = (<TypeScript.ModuleDeclaration>ast).name.actualText : any
>类型别名 :=> 任意
>name : string
>类型别名 :=> 文字
>(<TypeScript.ModuleDeclaration>ast).name.actualText : any
>类型别名 :=> 任意
>(<TypeScript.ModuleDeclaration>ast).name : any
>类型别名 :=> 任意
>(<TypeScript.ModuleDeclaration>ast) : any
>类型别名 :=> 任意
><TypeScript.ModuleDeclaration>ast : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>ModuleDeclaration : No type information available!
>ast : any
>类型别名 :=> 任意
>name : any
>类型别名 :=> 任意
>actualText : any
>类型别名 :=> 任意

                        break;
                    case TypeScript.NodeType.ClassDeclaration:
>TypeScript.NodeType.ClassDeclaration : any
>类型别名 :=> 任意
>TypeScript.NodeType : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>NodeType : any
>类型别名 :=> 任意
>ClassDeclaration : any
>类型别名 :=> 任意

                        name = (<TypeScript.ClassDeclaration>ast).name.actualText;
>name = (<TypeScript.ClassDeclaration>ast).name.actualText : any
>类型别名 :=> 任意
>name : string
>类型别名 :=> 文字
>(<TypeScript.ClassDeclaration>ast).name.actualText : any
>类型别名 :=> 任意
>(<TypeScript.ClassDeclaration>ast).name : any
>类型别名 :=> 任意
>(<TypeScript.ClassDeclaration>ast) : any
>类型别名 :=> 任意
><TypeScript.ClassDeclaration>ast : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>ClassDeclaration : No type information available!
>ast : any
>类型别名 :=> 任意
>name : any
>类型别名 :=> 任意
>actualText : any
>类型别名 :=> 任意

                        break;
                    case TypeScript.NodeType.FuncDecl:
>TypeScript.NodeType.FuncDecl : any
>类型别名 :=> 任意
>TypeScript.NodeType : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>NodeType : any
>类型别名 :=> 任意
>FuncDecl : any
>类型别名 :=> 任意

                        name = !(<TypeScript.FuncDecl>ast).name ? "" : (<TypeScript.FuncDecl>ast).name.actualText; // name == null for lambdas
>name = !(<TypeScript.FuncDecl>ast).name ? "" : (<TypeScript.FuncDecl>ast).name.actualText : any
>类型别名 :=> 任意
>name : string
>类型别名 :=> 文字
>!(<TypeScript.FuncDecl>ast).name ? "" : (<TypeScript.FuncDecl>ast).name.actualText : any
>类型别名 :=> 任意
>!(<TypeScript.FuncDecl>ast).name : boolean
>类型别名 :=> 真假
>(<TypeScript.FuncDecl>ast).name : any
>类型别名 :=> 任意
>(<TypeScript.FuncDecl>ast) : any
>类型别名 :=> 任意
><TypeScript.FuncDecl>ast : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>FuncDecl : No type information available!
>ast : any
>类型别名 :=> 任意
>name : any
>类型别名 :=> 任意
>"" : ""
>(<TypeScript.FuncDecl>ast).name.actualText : any
>类型别名 :=> 任意
>(<TypeScript.FuncDecl>ast).name : any
>类型别名 :=> 任意
>(<TypeScript.FuncDecl>ast) : any
>类型别名 :=> 任意
><TypeScript.FuncDecl>ast : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>FuncDecl : No type information available!
>ast : any
>类型别名 :=> 任意
>name : any
>类型别名 :=> 任意
>actualText : any
>类型别名 :=> 任意

                        break;
                    default:
                        // TODO: is there a reason to mess with all the special cases above and not just do this (ie take whatever property is there and works?)
                        var a = <any>ast;
>a : any
>类型别名 :=> 任意
><any>ast : any
>类型别名 :=> 任意
>ast : any
>类型别名 :=> 任意

                        name = (a.id) ? (a.id.actualText) : (a.name) ? a.name.actualText : (a.text) ? a.text : '';
>name = (a.id) ? (a.id.actualText) : (a.name) ? a.name.actualText : (a.text) ? a.text : '' : any
>类型别名 :=> 任意
>name : string
>类型别名 :=> 文字
>(a.id) ? (a.id.actualText) : (a.name) ? a.name.actualText : (a.text) ? a.text : '' : any
>类型别名 :=> 任意
>(a.id) : any
>类型别名 :=> 任意
>a.id : any
>类型别名 :=> 任意
>a : any
>类型别名 :=> 任意
>id : any
>类型别名 :=> 任意
>(a.id.actualText) : any
>类型别名 :=> 任意
>a.id.actualText : any
>类型别名 :=> 任意
>a.id : any
>类型别名 :=> 任意
>a : any
>类型别名 :=> 任意
>id : any
>类型别名 :=> 任意
>actualText : any
>类型别名 :=> 任意
>(a.name) ? a.name.actualText : (a.text) ? a.text : '' : any
>类型别名 :=> 任意
>(a.name) : any
>类型别名 :=> 任意
>a.name : any
>类型别名 :=> 任意
>a : any
>类型别名 :=> 任意
>name : any
>类型别名 :=> 任意
>a.name.actualText : any
>类型别名 :=> 任意
>a.name : any
>类型别名 :=> 任意
>a : any
>类型别名 :=> 任意
>name : any
>类型别名 :=> 任意
>actualText : any
>类型别名 :=> 任意
>(a.text) ? a.text : '' : any
>类型别名 :=> 任意
>(a.text) : any
>类型别名 :=> 任意
>a.text : any
>类型别名 :=> 任意
>a : any
>类型别名 :=> 任意
>text : any
>类型别名 :=> 任意
>a.text : any
>类型别名 :=> 任意
>a : any
>类型别名 :=> 任意
>text : any
>类型别名 :=> 任意
>'' : ""

                        break;
                }

                return name;
>name : string
>类型别名 :=> 文字
            }

            public isOfType(expr: string, expectedType: string) {
>isOfType : (expr: string, expectedType: string) => void
>expr : string
>类型别名 :=> 文字
>expectedType : string
>类型别名 :=> 文字

                var actualType = this.get('var _v_a_r_ = ' + expr, '_v_a_r_');
>actualType : Type
>this.get('var _v_a_r_ = ' + expr, '_v_a_r_') : Type
>this.get : (code: string, target: any) => Type
>this : this
>get : (code: string, target: any) => Type
>'var _v_a_r_ = ' + expr : string
>类型别名 :=> 文字
>'var _v_a_r_ = ' : "var _v_a_r_ = "
>expr : string
>类型别名 :=> 文字
>'_v_a_r_' : "_v_a_r_"

                it('Expression "' + expr + '" is of type "' + expectedType + '"', function () {
>it('Expression "' + expr + '" is of type "' + expectedType + '"', function () {                    assert.equal(actualType.type, expectedType);                }) : void
>类型别名 :=> 无值
>it : (description: string, block: () => void) => void
>'Expression "' + expr + '" is of type "' + expectedType + '"' : string
>类型别名 :=> 文字
>'Expression "' + expr + '" is of type "' + expectedType : string
>类型别名 :=> 文字
>'Expression "' + expr + '" is of type "' : string
>类型别名 :=> 文字
>'Expression "' + expr : string
>类型别名 :=> 文字
>'Expression "' : "Expression \""
>expr : string
>类型别名 :=> 文字
>'" is of type "' : "\" is of type \""
>expectedType : string
>类型别名 :=> 文字
>'"' : "\""
>function () {                    assert.equal(actualType.type, expectedType);                } : () => void

                    assert.equal(actualType.type, expectedType);
>assert.equal(actualType.type, expectedType) : any
>类型别名 :=> 任意
>assert.equal : any
>类型别名 :=> 任意
>assert : any
>类型别名 :=> 任意
>equal : any
>类型别名 :=> 任意
>actualType.type : any
>类型别名 :=> 任意
>actualType : Type
>type : any
>类型别名 :=> 任意
>expectedType : string
>类型别名 :=> 文字

                });
            }
        }

        /** Generates a .d.ts file for the given code
          * @param verifyNoDeclFile pass true when the given code should generate no decl file, false otherwise
          * @param unitName add the given code under thie name, else use '0.ts'
          * @param compilationContext a set of functions to be run before and after compiling this code for doing things like adding dependencies first
          * @param references the set of referenced files used by the given code
          */
        export function generateDeclFile(code: string, verifyNoDeclFile: boolean, unitName?: string, compilationContext?: Harness.Compiler.CompilationContext, references?: TypeScript.IFileReference[]): string {
>generateDeclFile : (code: string, verifyNoDeclFile: boolean, unitName?: string, compilationContext?: CompilationContext, references?: any[]) => string
>code : string
>类型别名 :=> 文字
>verifyNoDeclFile : boolean
>类型别名 :=> 真假
>unitName : string
>类型别名 :=> 文字
>compilationContext : CompilationContext
>Harness : any
>类型别名 :=> 任意
>Compiler : any
>类型别名 :=> 任意
>CompilationContext : CompilationContext
>references : any[]
>TypeScript : any
>类型别名 :=> 任意
>IFileReference : No type information available!

            reset();
>reset() : void
>类型别名 :=> 无值
>reset : () => void

            compiler.settings.generateDeclarationFiles = true;
>compiler.settings.generateDeclarationFiles = true : true
>类型别名 :=> 为真
>compiler.settings.generateDeclarationFiles : any
>类型别名 :=> 任意
>compiler.settings : any
>类型别名 :=> 任意
>compiler : any
>类型别名 :=> 任意
>settings : any
>类型别名 :=> 任意
>generateDeclarationFiles : any
>类型别名 :=> 任意
>true : true
>类型别名 :=> 为真

            var oldOutputOption = compiler.settings.outputOption;
>oldOutputOption : any
>类型别名 :=> 任意
>compiler.settings.outputOption : any
>类型别名 :=> 任意
>compiler.settings : any
>类型别名 :=> 任意
>compiler : any
>类型别名 :=> 任意
>settings : any
>类型别名 :=> 任意
>outputOption : any
>类型别名 :=> 任意

            var oldEmitterIOHost = compiler.emitSettings.ioHost;
>oldEmitterIOHost : any
>类型别名 :=> 任意
>compiler.emitSettings.ioHost : any
>类型别名 :=> 任意
>compiler.emitSettings : any
>类型别名 :=> 任意
>compiler : any
>类型别名 :=> 任意
>emitSettings : any
>类型别名 :=> 任意
>ioHost : any
>类型别名 :=> 任意

            try {
                if (compilationContext && compilationContext.preCompile) {
>compilationContext && compilationContext.preCompile : () => void
>compilationContext : CompilationContext
>compilationContext.preCompile : () => void
>compilationContext : CompilationContext
>preCompile : () => void

                    compilationContext.preCompile();
>compilationContext.preCompile() : void
>类型别名 :=> 无值
>compilationContext.preCompile : () => void
>compilationContext : CompilationContext
>preCompile : () => void
                }

                addUnit(code, unitName, false, false, references);
>addUnit(code, unitName, false, false, references) : any
>类型别名 :=> 任意
>addUnit : (code: string, unitName?: string, isResident?: boolean, isDeclareFile?: boolean, references?: any[]) => any
>code : string
>类型别名 :=> 文字
>unitName : string
>类型别名 :=> 文字
>false : false
>类型别名 :=> 为假
>false : false
>类型别名 :=> 为假
>references : any[]

                compiler.reTypeCheck();
>compiler.reTypeCheck() : any
>类型别名 :=> 任意
>compiler.reTypeCheck : any
>类型别名 :=> 任意
>compiler : any
>类型别名 :=> 任意
>reTypeCheck : any
>类型别名 :=> 任意

                var outputs = {};
>outputs : {}
>{} : {}

                compiler.settings.outputOption = "";
>compiler.settings.outputOption = "" : ""
>compiler.settings.outputOption : any
>类型别名 :=> 任意
>compiler.settings : any
>类型别名 :=> 任意
>compiler : any
>类型别名 :=> 任意
>settings : any
>类型别名 :=> 任意
>outputOption : any
>类型别名 :=> 任意
>"" : ""

                compiler.parseEmitOption(
>compiler.parseEmitOption(                    {                        createFile: (fn: string) => {                            outputs[fn] = new Harness.Compiler.WriterAggregator();                            return outputs[fn];                        },                        directoryExists: (path: string) => true,                        fileExists: (path: string) => true,                        resolvePath: (path: string) => path                    }) : any
>类型别名 :=> 任意
>compiler.parseEmitOption : any
>类型别名 :=> 任意
>compiler : any
>类型别名 :=> 任意
>parseEmitOption : any
>类型别名 :=> 任意
                    {
>{                        createFile: (fn: string) => {                            outputs[fn] = new Harness.Compiler.WriterAggregator();                            return outputs[fn];                        },                        directoryExists: (path: string) => true,                        fileExists: (path: string) => true,                        resolvePath: (path: string) => path                    } : { createFile: (fn: string) => any; directoryExists: (path: string) => boolean; fileExists: (path: string) => boolean; resolvePath: (path: string) => string; }

                        createFile: (fn: string) => {
>createFile : (fn: string) => any
>(fn: string) => {                            outputs[fn] = new Harness.Compiler.WriterAggregator();                            return outputs[fn];                        } : (fn: string) => any
>fn : string
>类型别名 :=> 文字

                            outputs[fn] = new Harness.Compiler.WriterAggregator();
>outputs[fn] = new Harness.Compiler.WriterAggregator() : WriterAggregator
>outputs[fn] : any
>类型别名 :=> 任意
>outputs : {}
>fn : string
>类型别名 :=> 文字
>new Harness.Compiler.WriterAggregator() : WriterAggregator
>Harness.Compiler.WriterAggregator : typeof WriterAggregator
>Harness.Compiler : typeof Compiler
>Harness : typeof Harness
>Compiler : typeof Compiler
>WriterAggregator : typeof WriterAggregator

                            return outputs[fn];
>outputs[fn] : any
>类型别名 :=> 任意
>outputs : {}
>fn : string
>类型别名 :=> 文字

                        },
                        directoryExists: (path: string) => true,
>directoryExists : (path: string) => boolean
>(path: string) => true : (path: string) => boolean
>path : string
>类型别名 :=> 文字
>true : true
>类型别名 :=> 为真

                        fileExists: (path: string) => true,
>fileExists : (path: string) => boolean
>(path: string) => true : (path: string) => boolean
>path : string
>类型别名 :=> 文字
>true : true
>类型别名 :=> 为真

                        resolvePath: (path: string) => path
>resolvePath : (path: string) => string
>(path: string) => path : (path: string) => string
>path : string
>类型别名 :=> 文字
>path : string
>类型别名 :=> 文字

                    });
                compiler.emitDeclarations();
>compiler.emitDeclarations() : any
>类型别名 :=> 任意
>compiler.emitDeclarations : any
>类型别名 :=> 任意
>compiler : any
>类型别名 :=> 任意
>emitDeclarations : any
>类型别名 :=> 任意

                var results: string = null;
>results : string
>类型别名 :=> 文字
>null : null
>类型别名 :=> 空值

                for (var fn in outputs) {
>fn : string
>类型别名 :=> 文字
>outputs : {}

                    if (fn.indexOf('.d.ts') >= 0) {
>fn.indexOf('.d.ts') >= 0 : boolean
>类型别名 :=> 真假
>fn.indexOf('.d.ts') : number
>类型别名 :=> 数字
>fn.indexOf : (searchString: string, position?: number) => number
>fn : string
>类型别名 :=> 文字
>indexOf : (searchString: string, position?: number) => number
>'.d.ts' : ".d.ts"
>0 : 0

                        var writer = <Harness.Compiler.WriterAggregator>outputs[fn];
>writer : WriterAggregator
><Harness.Compiler.WriterAggregator>outputs[fn] : WriterAggregator
>Harness : any
>类型别名 :=> 任意
>Compiler : any
>类型别名 :=> 任意
>WriterAggregator : WriterAggregator
>outputs[fn] : any
>类型别名 :=> 任意
>outputs : {}
>fn : string
>类型别名 :=> 文字

                        writer.Close();
>writer.Close() : void
>类型别名 :=> 无值
>writer.Close : () => void
>writer : WriterAggregator
>Close : () => void

                        results = writer.lines.join('\n');
>results = writer.lines.join('\n') : string
>类型别名 :=> 文字
>results : string
>类型别名 :=> 文字
>writer.lines.join('\n') : string
>类型别名 :=> 文字
>writer.lines.join : (separator?: string) => string
>writer.lines : string[]
>writer : WriterAggregator
>lines : string[]
>join : (separator?: string) => string
>'\n' : "\n"

                        if (verifyNoDeclFile && results != "") {
>verifyNoDeclFile && results != "" : boolean
>类型别名 :=> 真假
>verifyNoDeclFile : boolean
>类型别名 :=> 真假
>results != "" : boolean
>类型别名 :=> 真假
>results : string
>类型别名 :=> 文字
>"" : ""

                            throw new Error('Compilation should not produce ' + fn);
>new Error('Compilation should not produce ' + fn) : Error
>Error : ErrorConstructor
>'Compilation should not produce ' + fn : string
>类型别名 :=> 文字
>'Compilation should not produce ' : "Compilation should not produce "
>fn : string
>类型别名 :=> 文字
                        }
                    }
                }

                if (results) {
>results : string
>类型别名 :=> 文字

                    return results;
>results : string
>类型别名 :=> 文字
                }

                if (!verifyNoDeclFile) {
>!verifyNoDeclFile : boolean
>类型别名 :=> 真假
>verifyNoDeclFile : boolean
>类型别名 :=> 真假

                    throw new Error('Compilation did not produce .d.ts files');
>new Error('Compilation did not produce .d.ts files') : Error
>Error : ErrorConstructor
>'Compilation did not produce .d.ts files' : "Compilation did not produce .d.ts files"
                }
            } finally {
                compiler.settings.generateDeclarationFiles = false;
>compiler.settings.generateDeclarationFiles = false : false
>类型别名 :=> 为假
>compiler.settings.generateDeclarationFiles : any
>类型别名 :=> 任意
>compiler.settings : any
>类型别名 :=> 任意
>compiler : any
>类型别名 :=> 任意
>settings : any
>类型别名 :=> 任意
>generateDeclarationFiles : any
>类型别名 :=> 任意
>false : false
>类型别名 :=> 为假

                compiler.settings.outputOption = oldOutputOption;
>compiler.settings.outputOption = oldOutputOption : any
>类型别名 :=> 任意
>compiler.settings.outputOption : any
>类型别名 :=> 任意
>compiler.settings : any
>类型别名 :=> 任意
>compiler : any
>类型别名 :=> 任意
>settings : any
>类型别名 :=> 任意
>outputOption : any
>类型别名 :=> 任意
>oldOutputOption : any
>类型别名 :=> 任意

                compiler.parseEmitOption(oldEmitterIOHost);
>compiler.parseEmitOption(oldEmitterIOHost) : any
>类型别名 :=> 任意
>compiler.parseEmitOption : any
>类型别名 :=> 任意
>compiler : any
>类型别名 :=> 任意
>parseEmitOption : any
>类型别名 :=> 任意
>oldEmitterIOHost : any
>类型别名 :=> 任意

                if (compilationContext && compilationContext.postCompile) {
>compilationContext && compilationContext.postCompile : () => void
>compilationContext : CompilationContext
>compilationContext.postCompile : () => void
>compilationContext : CompilationContext
>postCompile : () => void

                    compilationContext.postCompile();
>compilationContext.postCompile() : void
>类型别名 :=> 无值
>compilationContext.postCompile : () => void
>compilationContext : CompilationContext
>postCompile : () => void
                }

                var uName = unitName || '0.ts';
>uName : string
>类型别名 :=> 文字
>unitName || '0.ts' : string
>类型别名 :=> 文字
>unitName : string
>类型别名 :=> 文字
>'0.ts' : "0.ts"

                updateUnit('', uName);
>updateUnit('', uName) : void
>类型别名 :=> 无值
>updateUnit : (code: string, unitName: string, setRecovery?: boolean) => void
>'' : ""
>uName : string
>类型别名 :=> 文字
            }

            return '';
>'' : ""
        }

        /** Contains the code and errors of a compilation and some helper methods to check its status. */
        export class CompilerResult {
>CompilerResult : CompilerResult

            public code: string;
>code : string
>类型别名 :=> 文字

            public errors: CompilerError[];
>errors : CompilerError[]
>CompilerError : CompilerError

            /** @param fileResults an array of strings for the filename and an ITextWriter with its code */
            constructor(public fileResults: { filename: string; file: WriterAggregator; }[], errorLines: string[], public scripts: TypeScript.Script[]) {
>fileResults : { filename: string; file: WriterAggregator; }[]
>filename : string
>类型别名 :=> 文字
>file : WriterAggregator
>WriterAggregator : WriterAggregator
>errorLines : string[]
>scripts : any[]
>TypeScript : any
>类型别名 :=> 任意
>Script : No type information available!

                var lines = [];
>lines : any[]
>[] : undefined[]

                fileResults.forEach(v => lines = lines.concat(v.file.lines));
>fileResults.forEach(v => lines = lines.concat(v.file.lines)) : void
>类型别名 :=> 无值
>fileResults.forEach : (callbackfn: (value: { filename: string; file: WriterAggregator; }, index: number, array: { filename: string; file: WriterAggregator; }[]) => void, thisArg?: any) => void
>fileResults : { filename: string; file: WriterAggregator; }[]
>forEach : (callbackfn: (value: { filename: string; file: WriterAggregator; }, index: number, array: { filename: string; file: WriterAggregator; }[]) => void, thisArg?: any) => void
>v => lines = lines.concat(v.file.lines) : (v: { filename: string; file: WriterAggregator; }) => any[]
>v : { filename: string; file: WriterAggregator; }
>lines = lines.concat(v.file.lines) : any[]
>lines : any[]
>lines.concat(v.file.lines) : any[]
>lines.concat : { (...items: ReadonlyArray<any>[]): any[]; (...items: any[]): any[]; }
>lines : any[]
>concat : { (...items: ReadonlyArray<any>[]): any[]; (...items: any[]): any[]; }
>v.file.lines : string[]
>v.file : WriterAggregator
>v : { filename: string; file: WriterAggregator; }
>file : WriterAggregator
>lines : string[]

                this.code = lines.join("\n")
>this.code = lines.join("\n") : string
>类型别名 :=> 文字
>this.code : string
>类型别名 :=> 文字
>this : this
>code : string
>类型别名 :=> 文字
>lines.join("\n") : string
>类型别名 :=> 文字
>lines.join : (separator?: string) => string
>lines : any[]
>join : (separator?: string) => string
>"\n" : "\n"

                this.errors = [];
>this.errors = [] : undefined[]
>this.errors : CompilerError[]
>this : this
>errors : CompilerError[]
>[] : undefined[]

                for (var i = 0; i < errorLines.length; i++) {
>i : number
>类型别名 :=> 数字
>0 : 0
>i < errorLines.length : boolean
>类型别名 :=> 真假
>i : number
>类型别名 :=> 数字
>errorLines.length : number
>类型别名 :=> 数字
>errorLines : string[]
>length : number
>类型别名 :=> 数字
>i++ : number
>类型别名 :=> 数字
>i : number
>类型别名 :=> 数字

                    if (Harness.usePull) {
>Harness.usePull : boolean
>类型别名 :=> 真假
>Harness : typeof Harness
>usePull : boolean
>类型别名 :=> 真假

                        var err = <any>errorLines[i]; // TypeScript.PullError
>err : any
>类型别名 :=> 任意
><any>errorLines[i] : any
>类型别名 :=> 任意
>errorLines[i] : string
>类型别名 :=> 文字
>errorLines : string[]
>i : number
>类型别名 :=> 数字

                        this.errors.push(new CompilerError(err.filename, 0, 0, err.message));
>this.errors.push(new CompilerError(err.filename, 0, 0, err.message)) : number
>类型别名 :=> 数字
>this.errors.push : (...items: CompilerError[]) => number
>this.errors : CompilerError[]
>this : this
>errors : CompilerError[]
>push : (...items: CompilerError[]) => number
>new CompilerError(err.filename, 0, 0, err.message) : CompilerError
>CompilerError : typeof CompilerError
>err.filename : any
>类型别名 :=> 任意
>err : any
>类型别名 :=> 任意
>filename : any
>类型别名 :=> 任意
>0 : 0
>0 : 0
>err.message : any
>类型别名 :=> 任意
>err : any
>类型别名 :=> 任意
>message : any
>类型别名 :=> 任意

                    } else {
                        var match = errorLines[i].match(/([^\(]*)\((\d+),(\d+)\):\s+((.*[\s\r\n]*.*)+)\s*$/);
>match : RegExpMatchArray
>errorLines[i].match(/([^\(]*)\((\d+),(\d+)\):\s+((.*[\s\r\n]*.*)+)\s*$/) : RegExpMatchArray
>errorLines[i].match : (regexp: string | RegExp) => RegExpMatchArray
>errorLines[i] : string
>类型别名 :=> 文字
>errorLines : string[]
>i : number
>类型别名 :=> 数字
>match : (regexp: string | RegExp) => RegExpMatchArray
>/([^\(]*)\((\d+),(\d+)\):\s+((.*[\s\r\n]*.*)+)\s*$/ : RegExp

                        if (match) {
>match : RegExpMatchArray

                            this.errors.push(new CompilerError(match[1], parseFloat(match[2]), parseFloat(match[3]), match[4]));
>this.errors.push(new CompilerError(match[1], parseFloat(match[2]), parseFloat(match[3]), match[4])) : number
>类型别名 :=> 数字
>this.errors.push : (...items: CompilerError[]) => number
>this.errors : CompilerError[]
>this : this
>errors : CompilerError[]
>push : (...items: CompilerError[]) => number
>new CompilerError(match[1], parseFloat(match[2]), parseFloat(match[3]), match[4]) : CompilerError
>CompilerError : typeof CompilerError
>match[1] : string
>类型别名 :=> 文字
>match : RegExpMatchArray
>1 : 1
>parseFloat(match[2]) : number
>类型别名 :=> 数字
>parseFloat : (string: string) => number
>match[2] : string
>类型别名 :=> 文字
>match : RegExpMatchArray
>2 : 2
>parseFloat(match[3]) : number
>类型别名 :=> 数字
>parseFloat : (string: string) => number
>match[3] : string
>类型别名 :=> 文字
>match : RegExpMatchArray
>3 : 3
>match[4] : string
>类型别名 :=> 文字
>match : RegExpMatchArray
>4 : 4
                        }
                        else {
                            WScript.Echo("non-match on: " + errorLines[i]);
>WScript.Echo("non-match on: " + errorLines[i]) : any
>类型别名 :=> 任意
>WScript.Echo : any
>类型别名 :=> 任意
>WScript : any
>类型别名 :=> 任意
>Echo : any
>类型别名 :=> 任意
>"non-match on: " + errorLines[i] : string
>类型别名 :=> 文字
>"non-match on: " : "non-match on: "
>errorLines[i] : string
>类型别名 :=> 文字
>errorLines : string[]
>i : number
>类型别名 :=> 数字
                        }
                    }
                }
            }

            public isErrorAt(line: number, column: number, message: string) {
>isErrorAt : (line: number, column: number, message: string) => boolean
>line : number
>类型别名 :=> 数字
>column : number
>类型别名 :=> 数字
>message : string
>类型别名 :=> 文字

                for (var i = 0; i < this.errors.length; i++) {
>i : number
>类型别名 :=> 数字
>0 : 0
>i < this.errors.length : boolean
>类型别名 :=> 真假
>i : number
>类型别名 :=> 数字
>this.errors.length : number
>类型别名 :=> 数字
>this.errors : CompilerError[]
>this : this
>errors : CompilerError[]
>length : number
>类型别名 :=> 数字
>i++ : number
>类型别名 :=> 数字
>i : number
>类型别名 :=> 数字

                    if (this.errors[i].line === line && this.errors[i].column === column && this.errors[i].message === message)
>this.errors[i].line === line && this.errors[i].column === column && this.errors[i].message === message : boolean
>类型别名 :=> 真假
>this.errors[i].line === line && this.errors[i].column === column : boolean
>类型别名 :=> 真假
>this.errors[i].line === line : boolean
>类型别名 :=> 真假
>this.errors[i].line : number
>类型别名 :=> 数字
>this.errors[i] : CompilerError
>this.errors : CompilerError[]
>this : this
>errors : CompilerError[]
>i : number
>类型别名 :=> 数字
>line : number
>类型别名 :=> 数字
>line : number
>类型别名 :=> 数字
>this.errors[i].column === column : boolean
>类型别名 :=> 真假
>this.errors[i].column : number
>类型别名 :=> 数字
>this.errors[i] : CompilerError
>this.errors : CompilerError[]
>this : this
>errors : CompilerError[]
>i : number
>类型别名 :=> 数字
>column : number
>类型别名 :=> 数字
>column : number
>类型别名 :=> 数字
>this.errors[i].message === message : boolean
>类型别名 :=> 真假
>this.errors[i].message : string
>类型别名 :=> 文字
>this.errors[i] : CompilerError
>this.errors : CompilerError[]
>this : this
>errors : CompilerError[]
>i : number
>类型别名 :=> 数字
>message : string
>类型别名 :=> 文字
>message : string
>类型别名 :=> 文字

                        return true;
>true : true
>类型别名 :=> 为真
                }

                return false;
>false : false
>类型别名 :=> 为假
            }
        }

        // Compiler Error.
        export class CompilerError {
>CompilerError : CompilerError

            constructor(public file: string,
>file : string
>类型别名 :=> 文字

                    public line: number,
>line : number
>类型别名 :=> 数字

                    public column: number,
>column : number
>类型别名 :=> 数字

                    public message: string) { }
>message : string
>类型别名 :=> 文字

            public toString() {
>toString : () => string

                return this.file + "(" + this.line + "," + this.column + "): " + this.message;
>this.file + "(" + this.line + "," + this.column + "): " + this.message : string
>类型别名 :=> 文字
>this.file + "(" + this.line + "," + this.column + "): " : string
>类型别名 :=> 文字
>this.file + "(" + this.line + "," + this.column : string
>类型别名 :=> 文字
>this.file + "(" + this.line + "," : string
>类型别名 :=> 文字
>this.file + "(" + this.line : string
>类型别名 :=> 文字
>this.file + "(" : string
>类型别名 :=> 文字
>this.file : string
>类型别名 :=> 文字
>this : this
>file : string
>类型别名 :=> 文字
>"(" : "("
>this.line : number
>类型别名 :=> 数字
>this : this
>line : number
>类型别名 :=> 数字
>"," : ","
>this.column : number
>类型别名 :=> 数字
>this : this
>column : number
>类型别名 :=> 数字
>"): " : "): "
>this.message : string
>类型别名 :=> 文字
>this : this
>message : string
>类型别名 :=> 文字
            }
        }

        /** Create a new instance of the compiler with default settings and lib.d.ts, then typecheck */
        export function recreate() {
>recreate : () => void

            compiler = makeDefaultCompilerForTest();
>compiler = makeDefaultCompilerForTest() : any
>类型别名 :=> 任意
>compiler : any
>类型别名 :=> 任意
>makeDefaultCompilerForTest() : any
>类型别名 :=> 任意
>makeDefaultCompilerForTest : (c?: any) => any

            if (usePull) {
>usePull : boolean
>类型别名 :=> 真假

                compiler.pullTypeCheck(true);
>compiler.pullTypeCheck(true) : any
>类型别名 :=> 任意
>compiler.pullTypeCheck : any
>类型别名 :=> 任意
>compiler : any
>类型别名 :=> 任意
>pullTypeCheck : any
>类型别名 :=> 任意
>true : true
>类型别名 :=> 为真
            }
            else {
                compiler.typeCheck();
>compiler.typeCheck() : any
>类型别名 :=> 任意
>compiler.typeCheck : any
>类型别名 :=> 任意
>compiler : any
>类型别名 :=> 任意
>typeCheck : any
>类型别名 :=> 任意
            }
        }

        export function reset() {
>reset : () => void

            stdout.reset();
>stdout.reset() : void
>类型别名 :=> 无值
>stdout.reset : () => void
>stdout : EmitterIOHost
>reset : () => void

            stderr.reset();
>stderr.reset() : void
>类型别名 :=> 无值
>stderr.reset : () => void
>stderr : WriterAggregator
>reset : () => void

            var files = compiler.units.map((value) => value.filename);
>files : any
>类型别名 :=> 任意
>compiler.units.map((value) => value.filename) : any
>类型别名 :=> 任意
>compiler.units.map : any
>类型别名 :=> 任意
>compiler.units : any
>类型别名 :=> 任意
>compiler : any
>类型别名 :=> 任意
>units : any
>类型别名 :=> 任意
>map : any
>类型别名 :=> 任意
>(value) => value.filename : (value: any) => any
>value : any
>类型别名 :=> 任意
>value.filename : any
>类型别名 :=> 任意
>value : any
>类型别名 :=> 任意
>filename : any
>类型别名 :=> 任意

            for (var i = 0; i < files.length; i++) {
>i : number
>类型别名 :=> 数字
>0 : 0
>i < files.length : boolean
>类型别名 :=> 真假
>i : number
>类型别名 :=> 数字
>files.length : any
>类型别名 :=> 任意
>files : any
>类型别名 :=> 任意
>length : any
>类型别名 :=> 任意
>i++ : number
>类型别名 :=> 数字
>i : number
>类型别名 :=> 数字

                var fname = files[i];
>fname : any
>类型别名 :=> 任意
>files[i] : any
>类型别名 :=> 任意
>files : any
>类型别名 :=> 任意
>i : number
>类型别名 :=> 数字

                if(fname !== 'lib.d.ts') {
>fname !== 'lib.d.ts' : boolean
>类型别名 :=> 真假
>fname : any
>类型别名 :=> 任意
>'lib.d.ts' : "lib.d.ts"

                    updateUnit('', fname);
>updateUnit('', fname) : void
>类型别名 :=> 无值
>updateUnit : (code: string, unitName: string, setRecovery?: boolean) => void
>'' : ""
>fname : any
>类型别名 :=> 任意
                    }
            }

            compiler.errorReporter.hasErrors = false;
>compiler.errorReporter.hasErrors = false : false
>类型别名 :=> 为假
>compiler.errorReporter.hasErrors : any
>类型别名 :=> 任意
>compiler.errorReporter : any
>类型别名 :=> 任意
>compiler : any
>类型别名 :=> 任意
>errorReporter : any
>类型别名 :=> 任意
>hasErrors : any
>类型别名 :=> 任意
>false : false
>类型别名 :=> 为假
        }

        // Defines functions to invoke before compiling a piece of code and a post compile action intended to clean up the
        // effects of preCompile, preferably with something lighter weight than a full recreate()
        export interface CompilationContext {
>CompilationContext : CompilationContext

            filename: string;
>filename : string
>类型别名 :=> 文字

            preCompile: () => void;
>preCompile : () => void

            postCompile: () => void;
>postCompile : () => void
        }

        export function addUnit(code: string, unitName?: string, isResident?: boolean, isDeclareFile?: boolean, references?: TypeScript.IFileReference[]) {
>addUnit : (code: string, unitName?: string, isResident?: boolean, isDeclareFile?: boolean, references?: any[]) => any
>code : string
>类型别名 :=> 文字
>unitName : string
>类型别名 :=> 文字
>isResident : boolean
>类型别名 :=> 真假
>isDeclareFile : boolean
>类型别名 :=> 真假
>references : any[]
>TypeScript : any
>类型别名 :=> 任意
>IFileReference : No type information available!

            var script: TypeScript.Script = null;
>script : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>Script : No type information available!
>null : null
>类型别名 :=> 空值

            var uName = unitName || '0' + (isDeclareFile ? '.d.ts' : '.ts');
>uName : string
>类型别名 :=> 文字
>unitName || '0' + (isDeclareFile ? '.d.ts' : '.ts') : string
>类型别名 :=> 文字
>unitName : string
>类型别名 :=> 文字
>'0' + (isDeclareFile ? '.d.ts' : '.ts') : string
>类型别名 :=> 文字
>'0' : "0"
>(isDeclareFile ? '.d.ts' : '.ts') : ".d.ts" | ".ts"
>isDeclareFile ? '.d.ts' : '.ts' : ".d.ts" | ".ts"
>isDeclareFile : boolean
>类型别名 :=> 真假
>'.d.ts' : ".d.ts"
>'.ts' : ".ts"

            for (var i = 0; i < compiler.units.length; i++) {
>i : number
>类型别名 :=> 数字
>0 : 0
>i < compiler.units.length : boolean
>类型别名 :=> 真假
>i : number
>类型别名 :=> 数字
>compiler.units.length : any
>类型别名 :=> 任意
>compiler.units : any
>类型别名 :=> 任意
>compiler : any
>类型别名 :=> 任意
>units : any
>类型别名 :=> 任意
>length : any
>类型别名 :=> 任意
>i++ : number
>类型别名 :=> 数字
>i : number
>类型别名 :=> 数字

                if (compiler.units[i].filename === uName) {
>compiler.units[i].filename === uName : boolean
>类型别名 :=> 真假
>compiler.units[i].filename : any
>类型别名 :=> 任意
>compiler.units[i] : any
>类型别名 :=> 任意
>compiler.units : any
>类型别名 :=> 任意
>compiler : any
>类型别名 :=> 任意
>units : any
>类型别名 :=> 任意
>i : number
>类型别名 :=> 数字
>filename : any
>类型别名 :=> 任意
>uName : string
>类型别名 :=> 文字

                    updateUnit(code, uName);
>updateUnit(code, uName) : void
>类型别名 :=> 无值
>updateUnit : (code: string, unitName: string, setRecovery?: boolean) => void
>code : string
>类型别名 :=> 文字
>uName : string
>类型别名 :=> 文字

                    script = <TypeScript.Script>compiler.scripts.members[i];
>script = <TypeScript.Script>compiler.scripts.members[i] : any
>类型别名 :=> 任意
>script : any
>类型别名 :=> 任意
><TypeScript.Script>compiler.scripts.members[i] : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>Script : No type information available!
>compiler.scripts.members[i] : any
>类型别名 :=> 任意
>compiler.scripts.members : any
>类型别名 :=> 任意
>compiler.scripts : any
>类型别名 :=> 任意
>compiler : any
>类型别名 :=> 任意
>scripts : any
>类型别名 :=> 任意
>members : any
>类型别名 :=> 任意
>i : number
>类型别名 :=> 数字
                }
            }
            if (!script) {
>!script : boolean
>类型别名 :=> 真假
>script : any
>类型别名 :=> 任意

                // TODO: make this toggleable, shouldn't be necessary once typecheck bugs are cleaned up
                // but without it subsequent tests are treated as edits, making for somewhat useful stress testing
                // of persistent typecheck state
                //compiler.addUnit("", uName, isResident, references); // equivalent to compiler.deleteUnit(...)
                script = compiler.addUnit(code, uName, isResident, references);
>script = compiler.addUnit(code, uName, isResident, references) : any
>类型别名 :=> 任意
>script : any
>类型别名 :=> 任意
>compiler.addUnit(code, uName, isResident, references) : any
>类型别名 :=> 任意
>compiler.addUnit : any
>类型别名 :=> 任意
>compiler : any
>类型别名 :=> 任意
>addUnit : any
>类型别名 :=> 任意
>code : string
>类型别名 :=> 文字
>uName : string
>类型别名 :=> 文字
>isResident : boolean
>类型别名 :=> 真假
>references : any[]

                needsFullTypeCheck = true;
>needsFullTypeCheck = true : true
>类型别名 :=> 为真
>needsFullTypeCheck : boolean
>类型别名 :=> 真假
>true : true
>类型别名 :=> 为真
            }

            return script;
>script : any
>类型别名 :=> 任意
        }

        export function updateUnit(code: string, unitName: string, setRecovery?: boolean) {
>updateUnit : (code: string, unitName: string, setRecovery?: boolean) => void
>code : string
>类型别名 :=> 文字
>unitName : string
>类型别名 :=> 文字
>setRecovery : boolean
>类型别名 :=> 真假

            if (Harness.usePull) {
>Harness.usePull : boolean
>类型别名 :=> 真假
>Harness : typeof Harness
>usePull : boolean
>类型别名 :=> 真假

                compiler.pullUpdateUnit(new TypeScript.StringSourceText(code), unitName, setRecovery);
>compiler.pullUpdateUnit(new TypeScript.StringSourceText(code), unitName, setRecovery) : any
>类型别名 :=> 任意
>compiler.pullUpdateUnit : any
>类型别名 :=> 任意
>compiler : any
>类型别名 :=> 任意
>pullUpdateUnit : any
>类型别名 :=> 任意
>new TypeScript.StringSourceText(code) : any
>类型别名 :=> 任意
>TypeScript.StringSourceText : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>StringSourceText : any
>类型别名 :=> 任意
>code : string
>类型别名 :=> 文字
>unitName : string
>类型别名 :=> 文字
>setRecovery : boolean
>类型别名 :=> 真假

            } else {
                compiler.updateUnit(code, unitName, setRecovery);
>compiler.updateUnit(code, unitName, setRecovery) : any
>类型别名 :=> 任意
>compiler.updateUnit : any
>类型别名 :=> 任意
>compiler : any
>类型别名 :=> 任意
>updateUnit : any
>类型别名 :=> 任意
>code : string
>类型别名 :=> 文字
>unitName : string
>类型别名 :=> 文字
>setRecovery : boolean
>类型别名 :=> 真假
            }
        }

        export function compileFile(path: string, callback: (res: CompilerResult) => void , settingsCallback?: (settings?: TypeScript.CompilationSettings) => void , context?: CompilationContext, references?: TypeScript.IFileReference[]) {
>compileFile : (path: string, callback: (res: CompilerResult) => void, settingsCallback?: (settings?: any) => void, context?: CompilationContext, references?: any[]) => void
>path : string
>类型别名 :=> 文字
>callback : (res: CompilerResult) => void
>res : CompilerResult
>CompilerResult : CompilerResult
>settingsCallback : (settings?: any) => void
>settings : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>CompilationSettings : No type information available!
>context : CompilationContext
>CompilationContext : CompilationContext
>references : any[]
>TypeScript : any
>类型别名 :=> 任意
>IFileReference : No type information available!

            path = switchToForwardSlashes(path);
>path = switchToForwardSlashes(path) : string
>类型别名 :=> 文字
>path : string
>类型别名 :=> 文字
>switchToForwardSlashes(path) : string
>类型别名 :=> 文字
>switchToForwardSlashes : (path: string) => string
>path : string
>类型别名 :=> 文字

            var filename = path.match(/[^\/]*$/)[0];
>filename : string
>类型别名 :=> 文字
>path.match(/[^\/]*$/)[0] : string
>类型别名 :=> 文字
>path.match(/[^\/]*$/) : RegExpMatchArray
>path.match : (regexp: string | RegExp) => RegExpMatchArray
>path : string
>类型别名 :=> 文字
>match : (regexp: string | RegExp) => RegExpMatchArray
>/[^\/]*$/ : RegExp
>0 : 0

            var code = readFile(path);
>code : any
>类型别名 :=> 任意
>readFile(path) : any
>类型别名 :=> 任意
>readFile : (path: string) => any
>path : string
>类型别名 :=> 文字

            compileUnit(code, filename, callback, settingsCallback, context, references);
>compileUnit(code, filename, callback, settingsCallback, context, references) : void
>类型别名 :=> 无值
>compileUnit : (code: string, filename: string, callback: (res: CompilerResult) => void, settingsCallback?: (settings?: any) => void, context?: CompilationContext, references?: any[]) => void
>code : any
>类型别名 :=> 任意
>filename : string
>类型别名 :=> 文字
>callback : (res: CompilerResult) => void
>settingsCallback : (settings?: any) => void
>context : CompilationContext
>references : any[]
        }

        export function compileUnit(code: string, filename: string, callback: (res: CompilerResult) => void , settingsCallback?: (settings?: TypeScript.CompilationSettings) => void , context?: CompilationContext, references?: TypeScript.IFileReference[]) {
>compileUnit : (code: string, filename: string, callback: (res: CompilerResult) => void, settingsCallback?: (settings?: any) => void, context?: CompilationContext, references?: any[]) => void
>code : string
>类型别名 :=> 文字
>filename : string
>类型别名 :=> 文字
>callback : (res: CompilerResult) => void
>res : CompilerResult
>CompilerResult : CompilerResult
>settingsCallback : (settings?: any) => void
>settings : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>CompilationSettings : No type information available!
>context : CompilationContext
>CompilationContext : CompilationContext
>references : any[]
>TypeScript : any
>类型别名 :=> 任意
>IFileReference : No type information available!

            // not recursive
            function clone/* <T> */(source: any, target: any) {
>clone : (source: any, target: any) => void
>source : any
>类型别名 :=> 任意
>target : any
>类型别名 :=> 任意

                for (var prop in source) {
>prop : string
>类型别名 :=> 文字
>source : any
>类型别名 :=> 任意

                    target[prop] = source[prop];
>target[prop] = source[prop] : any
>类型别名 :=> 任意
>target[prop] : any
>类型别名 :=> 任意
>target : any
>类型别名 :=> 任意
>prop : string
>类型别名 :=> 文字
>source[prop] : any
>类型别名 :=> 任意
>source : any
>类型别名 :=> 任意
>prop : string
>类型别名 :=> 文字
                }
            }

            var oldCompilerSettings = new TypeScript.CompilationSettings();
>oldCompilerSettings : any
>类型别名 :=> 任意
>new TypeScript.CompilationSettings() : any
>类型别名 :=> 任意
>TypeScript.CompilationSettings : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>CompilationSettings : any
>类型别名 :=> 任意

            clone(compiler.settings, oldCompilerSettings);
>clone(compiler.settings, oldCompilerSettings) : void
>类型别名 :=> 无值
>clone : (source: any, target: any) => void
>compiler.settings : any
>类型别名 :=> 任意
>compiler : any
>类型别名 :=> 任意
>settings : any
>类型别名 :=> 任意
>oldCompilerSettings : any
>类型别名 :=> 任意

            var oldEmitSettings = new TypeScript.EmitOptions(compiler.settings);
>oldEmitSettings : any
>类型别名 :=> 任意
>new TypeScript.EmitOptions(compiler.settings) : any
>类型别名 :=> 任意
>TypeScript.EmitOptions : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>EmitOptions : any
>类型别名 :=> 任意
>compiler.settings : any
>类型别名 :=> 任意
>compiler : any
>类型别名 :=> 任意
>settings : any
>类型别名 :=> 任意

            clone(compiler.emitSettings, oldEmitSettings);
>clone(compiler.emitSettings, oldEmitSettings) : void
>类型别名 :=> 无值
>clone : (source: any, target: any) => void
>compiler.emitSettings : any
>类型别名 :=> 任意
>compiler : any
>类型别名 :=> 任意
>emitSettings : any
>类型别名 :=> 任意
>oldEmitSettings : any
>类型别名 :=> 任意

            var oldModuleGenTarget = TypeScript.moduleGenTarget;
>oldModuleGenTarget : any
>类型别名 :=> 任意
>TypeScript.moduleGenTarget : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>moduleGenTarget : any
>类型别名 :=> 任意

            if (settingsCallback) {
>settingsCallback : (settings?: any) => void

                settingsCallback(compiler.settings);
>settingsCallback(compiler.settings) : void
>类型别名 :=> 无值
>settingsCallback : (settings?: any) => void
>compiler.settings : any
>类型别名 :=> 任意
>compiler : any
>类型别名 :=> 任意
>settings : any
>类型别名 :=> 任意

                compiler.emitSettings = new TypeScript.EmitOptions(compiler.settings);
>compiler.emitSettings = new TypeScript.EmitOptions(compiler.settings) : any
>类型别名 :=> 任意
>compiler.emitSettings : any
>类型别名 :=> 任意
>compiler : any
>类型别名 :=> 任意
>emitSettings : any
>类型别名 :=> 任意
>new TypeScript.EmitOptions(compiler.settings) : any
>类型别名 :=> 任意
>TypeScript.EmitOptions : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>EmitOptions : any
>类型别名 :=> 任意
>compiler.settings : any
>类型别名 :=> 任意
>compiler : any
>类型别名 :=> 任意
>settings : any
>类型别名 :=> 任意
            }
            try {
                compileString(code, filename, callback, context, references);
>compileString(code, filename, callback, context, references) : void
>类型别名 :=> 无值
>compileString : (code: string, unitName: string, callback: (res: CompilerResult) => void, context?: CompilationContext, references?: any[]) => void
>code : string
>类型别名 :=> 文字
>filename : string
>类型别名 :=> 文字
>callback : (res: CompilerResult) => void
>context : CompilationContext
>references : any[]

            } finally {
                // If settingsCallback exists, assume that it modified the global compiler instance's settings in some way.
                // So that a test doesn't have side effects for tests run after it, restore the compiler settings to their previous state.
                if (settingsCallback) {
>settingsCallback : (settings?: any) => void

                    compiler.settings = oldCompilerSettings;
>compiler.settings = oldCompilerSettings : any
>类型别名 :=> 任意
>compiler.settings : any
>类型别名 :=> 任意
>compiler : any
>类型别名 :=> 任意
>settings : any
>类型别名 :=> 任意
>oldCompilerSettings : any
>类型别名 :=> 任意

                    compiler.emitSettings = oldEmitSettings;
>compiler.emitSettings = oldEmitSettings : any
>类型别名 :=> 任意
>compiler.emitSettings : any
>类型别名 :=> 任意
>compiler : any
>类型别名 :=> 任意
>emitSettings : any
>类型别名 :=> 任意
>oldEmitSettings : any
>类型别名 :=> 任意

                    TypeScript.moduleGenTarget = oldModuleGenTarget;
>TypeScript.moduleGenTarget = oldModuleGenTarget : any
>类型别名 :=> 任意
>TypeScript.moduleGenTarget : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>moduleGenTarget : any
>类型别名 :=> 任意
>oldModuleGenTarget : any
>类型别名 :=> 任意
                }
            }
        }

        export function compileUnits(units: TestCaseParser.TestUnitData[], callback: (res: Compiler.CompilerResult) => void , settingsCallback?: () => void ) {
>compileUnits : (units: TestCaseParser.TestUnitData[], callback: (res: CompilerResult) => void, settingsCallback?: () => void) => void
>units : TestCaseParser.TestUnitData[]
>TestCaseParser : any
>类型别名 :=> 任意
>TestUnitData : TestCaseParser.TestUnitData
>callback : (res: CompilerResult) => void
>res : CompilerResult
>Compiler : any
>类型别名 :=> 任意
>CompilerResult : CompilerResult
>settingsCallback : () => void

            var lastUnit = units[units.length - 1];
>lastUnit : TestCaseParser.TestUnitData
>units[units.length - 1] : TestCaseParser.TestUnitData
>units : TestCaseParser.TestUnitData[]
>units.length - 1 : number
>类型别名 :=> 数字
>units.length : number
>类型别名 :=> 数字
>units : TestCaseParser.TestUnitData[]
>length : number
>类型别名 :=> 数字
>1 : 1

            var unitName = switchToForwardSlashes(lastUnit.name).match(/[^\/]*$/)[0];
>unitName : string
>类型别名 :=> 文字
>switchToForwardSlashes(lastUnit.name).match(/[^\/]*$/)[0] : string
>类型别名 :=> 文字
>switchToForwardSlashes(lastUnit.name).match(/[^\/]*$/) : RegExpMatchArray
>switchToForwardSlashes(lastUnit.name).match : (regexp: string | RegExp) => RegExpMatchArray
>switchToForwardSlashes(lastUnit.name) : string
>类型别名 :=> 文字
>switchToForwardSlashes : (path: string) => string
>lastUnit.name : string
>类型别名 :=> 文字
>lastUnit : TestCaseParser.TestUnitData
>name : string
>类型别名 :=> 文字
>match : (regexp: string | RegExp) => RegExpMatchArray
>/[^\/]*$/ : RegExp
>0 : 0

            var dependencies = units.slice(0, units.length - 1);
>dependencies : TestCaseParser.TestUnitData[]
>units.slice(0, units.length - 1) : TestCaseParser.TestUnitData[]
>units.slice : (start?: number, end?: number) => TestCaseParser.TestUnitData[]
>units : TestCaseParser.TestUnitData[]
>slice : (start?: number, end?: number) => TestCaseParser.TestUnitData[]
>0 : 0
>units.length - 1 : number
>类型别名 :=> 数字
>units.length : number
>类型别名 :=> 数字
>units : TestCaseParser.TestUnitData[]
>length : number
>类型别名 :=> 数字
>1 : 1

            var compilationContext = Harness.Compiler.defineCompilationContextForTest(unitName, dependencies);
>compilationContext : CompilationContext
>Harness.Compiler.defineCompilationContextForTest(unitName, dependencies) : CompilationContext
>Harness.Compiler.defineCompilationContextForTest : (filename: string, dependencies: TestCaseParser.TestUnitData[]) => CompilationContext
>Harness.Compiler : typeof Compiler
>Harness : typeof Harness
>Compiler : typeof Compiler
>defineCompilationContextForTest : (filename: string, dependencies: TestCaseParser.TestUnitData[]) => CompilationContext
>unitName : string
>类型别名 :=> 文字
>dependencies : TestCaseParser.TestUnitData[]

            compileUnit(lastUnit.content, unitName, callback, settingsCallback, compilationContext, lastUnit.references);
>compileUnit(lastUnit.content, unitName, callback, settingsCallback, compilationContext, lastUnit.references) : void
>类型别名 :=> 无值
>compileUnit : (code: string, filename: string, callback: (res: CompilerResult) => void, settingsCallback?: (settings?: any) => void, context?: CompilationContext, references?: any[]) => void
>lastUnit.content : string
>类型别名 :=> 文字
>lastUnit : TestCaseParser.TestUnitData
>content : string
>类型别名 :=> 文字
>unitName : string
>类型别名 :=> 文字
>callback : (res: CompilerResult) => void
>settingsCallback : () => void
>compilationContext : CompilationContext
>lastUnit.references : any[]
>lastUnit : TestCaseParser.TestUnitData
>references : any[]
        }

        export function emitToOutfile(outfile: WriterAggregator) {
>emitToOutfile : (outfile: WriterAggregator) => void
>outfile : WriterAggregator
>WriterAggregator : WriterAggregator

            compiler.emitToOutfile(outfile);
>compiler.emitToOutfile(outfile) : any
>类型别名 :=> 任意
>compiler.emitToOutfile : any
>类型别名 :=> 任意
>compiler : any
>类型别名 :=> 任意
>emitToOutfile : any
>类型别名 :=> 任意
>outfile : WriterAggregator
        }

        export function emit(ioHost: TypeScript.EmitterIOHost, usePullEmitter?: boolean) {
>emit : (ioHost: any, usePullEmitter?: boolean) => void
>ioHost : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>EmitterIOHost : No type information available!
>usePullEmitter : boolean
>类型别名 :=> 真假

            compiler.emit(ioHost, usePullEmitter);
>compiler.emit(ioHost, usePullEmitter) : any
>类型别名 :=> 任意
>compiler.emit : any
>类型别名 :=> 任意
>compiler : any
>类型别名 :=> 任意
>emit : any
>类型别名 :=> 任意
>ioHost : any
>类型别名 :=> 任意
>usePullEmitter : boolean
>类型别名 :=> 真假
        }

        export function compileString(code: string, unitName: string, callback: (res: Compiler.CompilerResult) => void , context?: CompilationContext, references?: TypeScript.IFileReference[]) {
>compileString : (code: string, unitName: string, callback: (res: CompilerResult) => void, context?: CompilationContext, references?: any[]) => void
>code : string
>类型别名 :=> 文字
>unitName : string
>类型别名 :=> 文字
>callback : (res: CompilerResult) => void
>res : CompilerResult
>Compiler : any
>类型别名 :=> 任意
>CompilerResult : CompilerResult
>context : CompilationContext
>CompilationContext : CompilationContext
>references : any[]
>TypeScript : any
>类型别名 :=> 任意
>IFileReference : No type information available!

            var scripts: TypeScript.Script[] = [];
>scripts : any[]
>TypeScript : any
>类型别名 :=> 任意
>Script : No type information available!
>[] : undefined[]

            reset();
>reset() : void
>类型别名 :=> 无值
>reset : () => void

            if (context) {
>context : CompilationContext

                context.preCompile();
>context.preCompile() : void
>类型别名 :=> 无值
>context.preCompile : () => void
>context : CompilationContext
>preCompile : () => void
            }

            var isDeclareFile = Harness.Compiler.isDeclareFile(unitName);
>isDeclareFile : boolean
>类型别名 :=> 真假
>Harness.Compiler.isDeclareFile(unitName) : boolean
>类型别名 :=> 真假
>Harness.Compiler.isDeclareFile : (filename: string) => boolean
>Harness.Compiler : typeof Compiler
>Harness : typeof Harness
>Compiler : typeof Compiler
>isDeclareFile : (filename: string) => boolean
>unitName : string
>类型别名 :=> 文字

            // for single file tests just add them as using the old '0.ts' naming scheme
            var uName = context ? unitName : ((isDeclareFile) ? '0.d.ts' : '0.ts');
>uName : string
>类型别名 :=> 文字
>context ? unitName : ((isDeclareFile) ? '0.d.ts' : '0.ts') : string
>类型别名 :=> 文字
>context : CompilationContext
>unitName : string
>类型别名 :=> 文字
>((isDeclareFile) ? '0.d.ts' : '0.ts') : "0.ts" | "0.d.ts"
>(isDeclareFile) ? '0.d.ts' : '0.ts' : "0.ts" | "0.d.ts"
>(isDeclareFile) : boolean
>类型别名 :=> 真假
>isDeclareFile : boolean
>类型别名 :=> 真假
>'0.d.ts' : "0.d.ts"
>'0.ts' : "0.ts"

            scripts.push(addUnit(code, uName, false, isDeclareFile, references));
>scripts.push(addUnit(code, uName, false, isDeclareFile, references)) : number
>类型别名 :=> 数字
>scripts.push : (...items: any[]) => number
>scripts : any[]
>push : (...items: any[]) => number
>addUnit(code, uName, false, isDeclareFile, references) : any
>类型别名 :=> 任意
>addUnit : (code: string, unitName?: string, isResident?: boolean, isDeclareFile?: boolean, references?: any[]) => any
>code : string
>类型别名 :=> 文字
>uName : string
>类型别名 :=> 文字
>false : false
>类型别名 :=> 为假
>isDeclareFile : boolean
>类型别名 :=> 真假
>references : any[]

            compile(code, uName);
>compile(code, uName) : void
>类型别名 :=> 无值
>compile : (code?: string, filename?: string) => void
>code : string
>类型别名 :=> 文字
>uName : string
>类型别名 :=> 文字

            var errors;
>errors : any
>类型别名 :=> 任意

            if (usePull) {
>usePull : boolean
>类型别名 :=> 真假

                // TODO: no emit support with pull yet
                errors = compiler.pullGetErrorsForFile(uName);
>errors = compiler.pullGetErrorsForFile(uName) : any
>类型别名 :=> 任意
>errors : any
>类型别名 :=> 任意
>compiler.pullGetErrorsForFile(uName) : any
>类型别名 :=> 任意
>compiler.pullGetErrorsForFile : any
>类型别名 :=> 任意
>compiler : any
>类型别名 :=> 任意
>pullGetErrorsForFile : any
>类型别名 :=> 任意
>uName : string
>类型别名 :=> 文字

                emit(stdout, true);
>emit(stdout, true) : void
>类型别名 :=> 无值
>emit : (ioHost: any, usePullEmitter?: boolean) => void
>stdout : EmitterIOHost
>true : true
>类型别名 :=> 为真
            }
            else {
                errors = stderr.lines;
>errors = stderr.lines : string[]
>errors : any
>类型别名 :=> 任意
>stderr.lines : string[]
>stderr : WriterAggregator
>lines : string[]

                emit(stdout, false);
>emit(stdout, false) : void
>类型别名 :=> 无值
>emit : (ioHost: any, usePullEmitter?: boolean) => void
>stdout : EmitterIOHost
>false : false
>类型别名 :=> 为假

                //output decl file
                compiler.emitDeclarations();
>compiler.emitDeclarations() : any
>类型别名 :=> 任意
>compiler.emitDeclarations : any
>类型别名 :=> 任意
>compiler : any
>类型别名 :=> 任意
>emitDeclarations : any
>类型别名 :=> 任意
            }

            if (context) {
>context : CompilationContext

                context.postCompile();
>context.postCompile() : void
>类型别名 :=> 无值
>context.postCompile : () => void
>context : CompilationContext
>postCompile : () => void
            }

            callback(new CompilerResult(stdout.toArray(), errors, scripts));
>callback(new CompilerResult(stdout.toArray(), errors, scripts)) : void
>类型别名 :=> 无值
>callback : (res: CompilerResult) => void
>new CompilerResult(stdout.toArray(), errors, scripts) : CompilerResult
>CompilerResult : typeof CompilerResult
>stdout.toArray() : { filename: string; file: WriterAggregator; }[]
>stdout.toArray : () => { filename: string; file: WriterAggregator; }[]
>stdout : EmitterIOHost
>toArray : () => { filename: string; file: WriterAggregator; }[]
>errors : any
>类型别名 :=> 任意
>scripts : any[]
        }

        /** Returns a set of functions which can be later executed to add and remove given dependencies to the compiler so that
         *  a file can be successfully compiled. These functions will add/remove named units and code to the compiler for each dependency. 
         */
        export function defineCompilationContextForTest(filename: string, dependencies: TestCaseParser.TestUnitData[]): CompilationContext {
>defineCompilationContextForTest : (filename: string, dependencies: TestCaseParser.TestUnitData[]) => CompilationContext
>filename : string
>类型别名 :=> 文字
>dependencies : TestCaseParser.TestUnitData[]
>TestCaseParser : any
>类型别名 :=> 任意
>TestUnitData : TestCaseParser.TestUnitData
>CompilationContext : CompilationContext

            // if the given file has no dependencies, there is no context to return, it can be compiled without additional work
            if (dependencies.length == 0) {
>dependencies.length == 0 : boolean
>类型别名 :=> 真假
>dependencies.length : number
>类型别名 :=> 数字
>dependencies : TestCaseParser.TestUnitData[]
>length : number
>类型别名 :=> 数字
>0 : 0

                return null;
>null : null
>类型别名 :=> 空值

            } else {
                var addedFiles = [];
>addedFiles : any[]
>[] : undefined[]

                var precompile = () => {
>precompile : () => void
>() => {                    // REVIEW: if any dependency has a triple slash reference then does postCompile potentially have to do a recreate since we can't update references with updateUnit?                    // easy enough to do if so, prefer to avoid the recreate cost until it proves to be an issue                    dependencies.forEach(dep => {                        addUnit(dep.content, dep.name, false, Harness.Compiler.isDeclareFile(dep.name));                        addedFiles.push(dep.name);                    });                } : () => void

                    // REVIEW: if any dependency has a triple slash reference then does postCompile potentially have to do a recreate since we can't update references with updateUnit?
                    // easy enough to do if so, prefer to avoid the recreate cost until it proves to be an issue
                    dependencies.forEach(dep => {
>dependencies.forEach(dep => {                        addUnit(dep.content, dep.name, false, Harness.Compiler.isDeclareFile(dep.name));                        addedFiles.push(dep.name);                    }) : void
>类型别名 :=> 无值
>dependencies.forEach : (callbackfn: (value: TestCaseParser.TestUnitData, index: number, array: TestCaseParser.TestUnitData[]) => void, thisArg?: any) => void
>dependencies : TestCaseParser.TestUnitData[]
>forEach : (callbackfn: (value: TestCaseParser.TestUnitData, index: number, array: TestCaseParser.TestUnitData[]) => void, thisArg?: any) => void
>dep => {                        addUnit(dep.content, dep.name, false, Harness.Compiler.isDeclareFile(dep.name));                        addedFiles.push(dep.name);                    } : (dep: TestCaseParser.TestUnitData) => void
>dep : TestCaseParser.TestUnitData

                        addUnit(dep.content, dep.name, false, Harness.Compiler.isDeclareFile(dep.name));
>addUnit(dep.content, dep.name, false, Harness.Compiler.isDeclareFile(dep.name)) : any
>类型别名 :=> 任意
>addUnit : (code: string, unitName?: string, isResident?: boolean, isDeclareFile?: boolean, references?: any[]) => any
>dep.content : string
>类型别名 :=> 文字
>dep : TestCaseParser.TestUnitData
>content : string
>类型别名 :=> 文字
>dep.name : string
>类型别名 :=> 文字
>dep : TestCaseParser.TestUnitData
>name : string
>类型别名 :=> 文字
>false : false
>类型别名 :=> 为假
>Harness.Compiler.isDeclareFile(dep.name) : boolean
>类型别名 :=> 真假
>Harness.Compiler.isDeclareFile : (filename: string) => boolean
>Harness.Compiler : typeof Compiler
>Harness : typeof Harness
>Compiler : typeof Compiler
>isDeclareFile : (filename: string) => boolean
>dep.name : string
>类型别名 :=> 文字
>dep : TestCaseParser.TestUnitData
>name : string
>类型别名 :=> 文字

                        addedFiles.push(dep.name);
>addedFiles.push(dep.name) : number
>类型别名 :=> 数字
>addedFiles.push : (...items: any[]) => number
>addedFiles : any[]
>push : (...items: any[]) => number
>dep.name : string
>类型别名 :=> 文字
>dep : TestCaseParser.TestUnitData
>name : string
>类型别名 :=> 文字

                    });
                };
                var postcompile = () => {
>postcompile : () => void
>() => {                    addedFiles.forEach(file => {                        updateUnit('', file);                    });                } : () => void

                    addedFiles.forEach(file => {
>addedFiles.forEach(file => {                        updateUnit('', file);                    }) : void
>类型别名 :=> 无值
>addedFiles.forEach : (callbackfn: (value: any, index: number, array: any[]) => void, thisArg?: any) => void
>addedFiles : any[]
>forEach : (callbackfn: (value: any, index: number, array: any[]) => void, thisArg?: any) => void
>file => {                        updateUnit('', file);                    } : (file: any) => void
>file : any
>类型别名 :=> 任意

                        updateUnit('', file);
>updateUnit('', file) : void
>类型别名 :=> 无值
>updateUnit : (code: string, unitName: string, setRecovery?: boolean) => void
>'' : ""
>file : any
>类型别名 :=> 任意

                    });
                };
                var context = {
>context : { filename: string; preCompile: () => void; postCompile: () => void; }
>{                    filename: filename,                    preCompile: precompile,                    postCompile: postcompile                } : { filename: string; preCompile: () => void; postCompile: () => void; }

                    filename: filename,
>filename : string
>类型别名 :=> 文字
>filename : string
>类型别名 :=> 文字

                    preCompile: precompile,
>preCompile : () => void
>precompile : () => void

                    postCompile: postcompile
>postCompile : () => void
>postcompile : () => void

                };
                return context;
>context : { filename: string; preCompile: () => void; postCompile: () => void; }
            }
        }
    }

    /** Parses the test cases files 
     *  extracts options and individual files in a multifile test
     */
    export module TestCaseParser {
>TestCaseParser : typeof TestCaseParser

        /** all the necesarry information to set the right compiler settings */
        export interface CompilerSetting {
>CompilerSetting : CompilerSetting

            flag: string;
>flag : string
>类型别名 :=> 文字

            value: string;
>value : string
>类型别名 :=> 文字
        }

        /** All the necessary information to turn a multi file test into useful units for later compilation */
        export interface TestUnitData {
>TestUnitData : TestUnitData

            content: string;
>content : string
>类型别名 :=> 文字

            name: string;
>name : string
>类型别名 :=> 文字

            originalFilePath: string;
>originalFilePath : string
>类型别名 :=> 文字

            references: TypeScript.IFileReference[];
>references : any[]
>TypeScript : any
>类型别名 :=> 任意
>IFileReference : No type information available!
        }

        // Regex for parsing options in the format "@Alpha: Value of any sort"
        private optionRegex = /^[\/]{2}\s*@(\w+):\s*(\S*)/gm;  // multiple matches on multiple lines
>optionRegex = /^[\/]{2}\s*@(\w+):\s*(\S*)/gm : RegExp
>optionRegex : any
>类型别名 :=> 任意
>/^[\/]{2}\s*@(\w+):\s*(\S*)/gm : RegExp

        // List of allowed metadata names
        var fileMetadataNames = ["filename", "comments", "declaration", "module", "nolib", "sourcemap", "target", "out"];
>fileMetadataNames : string[]
>["filename", "comments", "declaration", "module", "nolib", "sourcemap", "target", "out"] : string[]
>"filename" : "filename"
>"comments" : "comments"
>"declaration" : "declaration"
>"module" : "module"
>"nolib" : "nolib"
>"sourcemap" : "sourcemap"
>"target" : "target"
>"out" : "out"

        function extractCompilerSettings(content: string): CompilerSetting[] {
>extractCompilerSettings : (content: string) => CompilerSetting[]
>content : string
>类型别名 :=> 文字
>CompilerSetting : CompilerSetting

            var opts = [];
>opts : any[]
>[] : undefined[]

            var match;
>match : any
>类型别名 :=> 任意

            while ((match = optionRegex.exec(content)) != null) {
>(match = optionRegex.exec(content)) != null : boolean
>类型别名 :=> 真假
>(match = optionRegex.exec(content)) : any
>类型别名 :=> 任意
>match = optionRegex.exec(content) : any
>类型别名 :=> 任意
>match : any
>类型别名 :=> 任意
>optionRegex.exec(content) : any
>类型别名 :=> 任意
>optionRegex.exec : any
>类型别名 :=> 任意
>optionRegex : any
>类型别名 :=> 任意
>exec : any
>类型别名 :=> 任意
>content : string
>类型别名 :=> 文字
>null : null
>类型别名 :=> 空值

                opts.push({ flag: match[1], value: match[2] });
>opts.push({ flag: match[1], value: match[2] }) : number
>类型别名 :=> 数字
>opts.push : (...items: any[]) => number
>opts : any[]
>push : (...items: any[]) => number
>{ flag: match[1], value: match[2] } : { flag: any; value: any; }
>flag : any
>类型别名 :=> 任意
>match[1] : any
>类型别名 :=> 任意
>match : any
>类型别名 :=> 任意
>1 : 1
>value : any
>类型别名 :=> 任意
>match[2] : any
>类型别名 :=> 任意
>match : any
>类型别名 :=> 任意
>2 : 2
            }

            return opts;
>opts : any[]
        }

        /** Given a test file containing // @Filename directives, return an array of named units of code to be added to an existing compiler instance */
        export function makeUnitsFromTest(code: string, filename: string): { settings: CompilerSetting[]; testUnitData: TestUnitData[]; } {
>makeUnitsFromTest : (code: string, filename: string) => { settings: CompilerSetting[]; testUnitData: TestUnitData[]; }
>code : string
>类型别名 :=> 文字
>filename : string
>类型别名 :=> 文字
>settings : CompilerSetting[]
>CompilerSetting : CompilerSetting
>testUnitData : TestUnitData[]
>TestUnitData : TestUnitData

            var settings = extractCompilerSettings(code);
>settings : CompilerSetting[]
>extractCompilerSettings(code) : CompilerSetting[]
>extractCompilerSettings : (content: string) => CompilerSetting[]
>code : string
>类型别名 :=> 文字

            // List of all the subfiles we've parsed out
            var files: TestUnitData[] = [];
>files : TestUnitData[]
>TestUnitData : TestUnitData
>[] : undefined[]

            var lines = splitContentByNewlines(code);
>lines : string[]
>splitContentByNewlines(code) : string[]
>splitContentByNewlines : (content: string) => string[]
>code : string
>类型别名 :=> 文字

            // Stuff related to the subfile we're parsing
            var currentFileContent: string = null;
>currentFileContent : string
>类型别名 :=> 文字
>null : null
>类型别名 :=> 空值

            var currentFileOptions = {};
>currentFileOptions : {}
>{} : {}

            var currentFileName = null;
>currentFileName : any
>类型别名 :=> 任意
>null : null
>类型别名 :=> 空值

            var refs: TypeScript.IFileReference[] = [];
>refs : any[]
>TypeScript : any
>类型别名 :=> 任意
>IFileReference : No type information available!
>[] : undefined[]

            for (var i = 0; i < lines.length; i++) {
>i : number
>类型别名 :=> 数字
>0 : 0
>i < lines.length : boolean
>类型别名 :=> 真假
>i : number
>类型别名 :=> 数字
>lines.length : number
>类型别名 :=> 数字
>lines : string[]
>length : number
>类型别名 :=> 数字
>i++ : number
>类型别名 :=> 数字
>i : number
>类型别名 :=> 数字

                var line = lines[i];
>line : string
>类型别名 :=> 文字
>lines[i] : string
>类型别名 :=> 文字
>lines : string[]
>i : number
>类型别名 :=> 数字

                var isTripleSlashReference = /[\/]{3}\s*<reference path/.test(line);
>isTripleSlashReference : boolean
>类型别名 :=> 真假
>/[\/]{3}\s*<reference path/.test(line) : boolean
>类型别名 :=> 真假
>/[\/]{3}\s*<reference path/.test : (string: string) => boolean
>/[\/]{3}\s*<reference path/ : RegExp
>test : (string: string) => boolean
>line : string
>类型别名 :=> 文字

                var testMetaData = optionRegex.exec(line);
>testMetaData : any
>类型别名 :=> 任意
>optionRegex.exec(line) : any
>类型别名 :=> 任意
>optionRegex.exec : any
>类型别名 :=> 任意
>optionRegex : any
>类型别名 :=> 任意
>exec : any
>类型别名 :=> 任意
>line : string
>类型别名 :=> 文字

                // Triple slash references need to be tracked as they are added to the compiler as an additional parameter to addUnit
                if (isTripleSlashReference) {
>isTripleSlashReference : boolean
>类型别名 :=> 真假

                    var isRef = line.match(/reference\spath='(\w*_?\w*\.?d?\.ts)'/);
>isRef : RegExpMatchArray
>line.match(/reference\spath='(\w*_?\w*\.?d?\.ts)'/) : RegExpMatchArray
>line.match : (regexp: string | RegExp) => RegExpMatchArray
>line : string
>类型别名 :=> 文字
>match : (regexp: string | RegExp) => RegExpMatchArray
>/reference\spath='(\w*_?\w*\.?d?\.ts)'/ : RegExp

                    if (isRef) {
>isRef : RegExpMatchArray

                        var ref = {
>ref : { minChar: number; limChar: number; startLine: number; startCol: number; path: string; isResident: boolean; }
>{                            minChar: 0,                            limChar: 0,                            startLine:0,                            startCol:0,                            path: isRef[1],                            isResident: false                        } : { minChar: number; limChar: number; startLine: number; startCol: number; path: string; isResident: boolean; }

                            minChar: 0,
>minChar : number
>类型别名 :=> 数字
>0 : 0

                            limChar: 0,
>limChar : number
>类型别名 :=> 数字
>0 : 0

                            startLine:0,
>startLine : number
>类型别名 :=> 数字
>0 : 0

                            startCol:0,
>startCol : number
>类型别名 :=> 数字
>0 : 0

                            path: isRef[1],
>path : string
>类型别名 :=> 文字
>isRef[1] : string
>类型别名 :=> 文字
>isRef : RegExpMatchArray
>1 : 1

                            isResident: false
>isResident : boolean
>类型别名 :=> 真假
>false : false
>类型别名 :=> 为假

                        };

                        refs.push(ref);
>refs.push(ref) : number
>类型别名 :=> 数字
>refs.push : (...items: any[]) => number
>refs : any[]
>push : (...items: any[]) => number
>ref : { minChar: number; limChar: number; startLine: number; startCol: number; path: string; isResident: boolean; }
                    }
                } else if (testMetaData) {
>testMetaData : any
>类型别名 :=> 任意

                    // Comment line, check for global/file @options and record them
                    optionRegex.lastIndex = 0;
>optionRegex.lastIndex = 0 : 0
>optionRegex.lastIndex : any
>类型别名 :=> 任意
>optionRegex : any
>类型别名 :=> 任意
>lastIndex : any
>类型别名 :=> 任意
>0 : 0

                    var fileNameIndex = fileMetadataNames.indexOf(testMetaData[1].toLowerCase());
>fileNameIndex : number
>类型别名 :=> 数字
>fileMetadataNames.indexOf(testMetaData[1].toLowerCase()) : number
>类型别名 :=> 数字
>fileMetadataNames.indexOf : (searchElement: string, fromIndex?: number) => number
>fileMetadataNames : string[]
>indexOf : (searchElement: string, fromIndex?: number) => number
>testMetaData[1].toLowerCase() : any
>类型别名 :=> 任意
>testMetaData[1].toLowerCase : any
>类型别名 :=> 任意
>testMetaData[1] : any
>类型别名 :=> 任意
>testMetaData : any
>类型别名 :=> 任意
>1 : 1
>toLowerCase : any
>类型别名 :=> 任意

                    if (fileNameIndex == -1) {
>fileNameIndex == -1 : boolean
>类型别名 :=> 真假
>fileNameIndex : number
>类型别名 :=> 数字
>-1 : -1
>1 : 1

                        throw new Error('Unrecognized metadata name "' + testMetaData[1] + '". Available file metadata names are: ' + fileMetadataNames.join(', '));
>new Error('Unrecognized metadata name "' + testMetaData[1] + '". Available file metadata names are: ' + fileMetadataNames.join(', ')) : Error
>Error : ErrorConstructor
>'Unrecognized metadata name "' + testMetaData[1] + '". Available file metadata names are: ' + fileMetadataNames.join(', ') : string
>类型别名 :=> 文字
>'Unrecognized metadata name "' + testMetaData[1] + '". Available file metadata names are: ' : string
>类型别名 :=> 文字
>'Unrecognized metadata name "' + testMetaData[1] : string
>类型别名 :=> 文字
>'Unrecognized metadata name "' : "Unrecognized metadata name \""
>testMetaData[1] : any
>类型别名 :=> 任意
>testMetaData : any
>类型别名 :=> 任意
>1 : 1
>'". Available file metadata names are: ' : "\". Available file metadata names are: "
>fileMetadataNames.join(', ') : string
>类型别名 :=> 文字
>fileMetadataNames.join : (separator?: string) => string
>fileMetadataNames : string[]
>join : (separator?: string) => string
>', ' : ", "

                    } else if (fileNameIndex == 0) {
>fileNameIndex == 0 : boolean
>类型别名 :=> 真假
>fileNameIndex : number
>类型别名 :=> 数字
>0 : 0

                        currentFileOptions[testMetaData[1]] = testMetaData[2];
>currentFileOptions[testMetaData[1]] = testMetaData[2] : any
>类型别名 :=> 任意
>currentFileOptions[testMetaData[1]] : any
>类型别名 :=> 任意
>currentFileOptions : {}
>testMetaData[1] : any
>类型别名 :=> 任意
>testMetaData : any
>类型别名 :=> 任意
>1 : 1
>testMetaData[2] : any
>类型别名 :=> 任意
>testMetaData : any
>类型别名 :=> 任意
>2 : 2

                    } else {
                        continue;
                    }

                    // New metadata statement after having collected some code to go with the previous metadata
                    if (currentFileName) {
>currentFileName : any
>类型别名 :=> 任意

                        // Store result file
                        var newTestFile =
>newTestFile : { content: string; name: any; fileOptions: {}; originalFilePath: string; references: any[]; }
                            {
>{                                content: currentFileContent,                                name: currentFileName,                                fileOptions: currentFileOptions,                                originalFilePath: filename,                                references: refs                            } : { content: string; name: any; fileOptions: {}; originalFilePath: string; references: any[]; }

                                content: currentFileContent,
>content : string
>类型别名 :=> 文字
>currentFileContent : string
>类型别名 :=> 文字

                                name: currentFileName,
>name : any
>类型别名 :=> 任意
>currentFileName : any
>类型别名 :=> 任意

                                fileOptions: currentFileOptions,
>fileOptions : {}
>currentFileOptions : {}

                                originalFilePath: filename,
>originalFilePath : string
>类型别名 :=> 文字
>filename : string
>类型别名 :=> 文字

                                references: refs
>references : any[]
>refs : any[]

                            };
                        files.push(newTestFile);
>files.push(newTestFile) : number
>类型别名 :=> 数字
>files.push : (...items: TestUnitData[]) => number
>files : TestUnitData[]
>push : (...items: TestUnitData[]) => number
>newTestFile : { content: string; name: any; fileOptions: {}; originalFilePath: string; references: any[]; }

                        // Reset local data
                        currentFileContent = null;
>currentFileContent = null : null
>类型别名 :=> 空值
>currentFileContent : string
>类型别名 :=> 文字
>null : null
>类型别名 :=> 空值

                        currentFileOptions = {};
>currentFileOptions = {} : {}
>currentFileOptions : {}
>{} : {}

                        currentFileName = testMetaData[2];
>currentFileName = testMetaData[2] : any
>类型别名 :=> 任意
>currentFileName : any
>类型别名 :=> 任意
>testMetaData[2] : any
>类型别名 :=> 任意
>testMetaData : any
>类型别名 :=> 任意
>2 : 2

                        refs = [];
>refs = [] : undefined[]
>refs : any[]
>[] : undefined[]

                    } else {
                        // First metadata marker in the file
                        currentFileName = testMetaData[2];
>currentFileName = testMetaData[2] : any
>类型别名 :=> 任意
>currentFileName : any
>类型别名 :=> 任意
>testMetaData[2] : any
>类型别名 :=> 任意
>testMetaData : any
>类型别名 :=> 任意
>2 : 2
                    }
                } else {
                    // Subfile content line
                    // Append to the current subfile content, inserting a newline needed
                    if (currentFileContent === null) {
>currentFileContent === null : boolean
>类型别名 :=> 真假
>currentFileContent : string
>类型别名 :=> 文字
>null : null
>类型别名 :=> 空值

                        currentFileContent = '';
>currentFileContent = '' : ""
>currentFileContent : string
>类型别名 :=> 文字
>'' : ""

                    } else {
                        // End-of-line
                        currentFileContent = currentFileContent + '\n';
>currentFileContent = currentFileContent + '\n' : string
>类型别名 :=> 文字
>currentFileContent : string
>类型别名 :=> 文字
>currentFileContent + '\n' : string
>类型别名 :=> 文字
>currentFileContent : string
>类型别名 :=> 文字
>'\n' : "\n"
                    }
                    currentFileContent = currentFileContent + line;
>currentFileContent = currentFileContent + line : string
>类型别名 :=> 文字
>currentFileContent : string
>类型别名 :=> 文字
>currentFileContent + line : string
>类型别名 :=> 文字
>currentFileContent : string
>类型别名 :=> 文字
>line : string
>类型别名 :=> 文字
                }
            }

            // normalize the filename for the single file case
            currentFileName = files.length > 0 ? currentFileName : '0.ts';
>currentFileName = files.length > 0 ? currentFileName : '0.ts' : any
>类型别名 :=> 任意
>currentFileName : any
>类型别名 :=> 任意
>files.length > 0 ? currentFileName : '0.ts' : any
>类型别名 :=> 任意
>files.length > 0 : boolean
>类型别名 :=> 真假
>files.length : number
>类型别名 :=> 数字
>files : TestUnitData[]
>length : number
>类型别名 :=> 数字
>0 : 0
>currentFileName : any
>类型别名 :=> 任意
>'0.ts' : "0.ts"

            // EOF, push whatever remains
            var newTestFile = {
>newTestFile : { content: string; name: any; fileOptions: {}; originalFilePath: string; references: any[]; }
>{                content: currentFileContent || '',                name: currentFileName,                fileOptions: currentFileOptions,                originalFilePath: filename,                references: refs            } : { content: string; name: any; fileOptions: {}; originalFilePath: string; references: any[]; }

                content: currentFileContent || '',
>content : string
>类型别名 :=> 文字
>currentFileContent || '' : string
>类型别名 :=> 文字
>currentFileContent : string
>类型别名 :=> 文字
>'' : ""

                name: currentFileName,
>name : any
>类型别名 :=> 任意
>currentFileName : any
>类型别名 :=> 任意

                fileOptions: currentFileOptions,
>fileOptions : {}
>currentFileOptions : {}

                originalFilePath: filename,
>originalFilePath : string
>类型别名 :=> 文字
>filename : string
>类型别名 :=> 文字

                references: refs
>references : any[]
>refs : any[]

            };
            files.push(newTestFile);
>files.push(newTestFile) : number
>类型别名 :=> 数字
>files.push : (...items: TestUnitData[]) => number
>files : TestUnitData[]
>push : (...items: TestUnitData[]) => number
>newTestFile : { content: string; name: any; fileOptions: {}; originalFilePath: string; references: any[]; }

            return { settings: settings, testUnitData: files };
>{ settings: settings, testUnitData: files } : { settings: CompilerSetting[]; testUnitData: TestUnitData[]; }
>settings : CompilerSetting[]
>settings : CompilerSetting[]
>testUnitData : TestUnitData[]
>files : TestUnitData[]
        }
    }

    export class ScriptInfo {
>ScriptInfo : ScriptInfo

        public version: number;
>version : number
>类型别名 :=> 数字

        public editRanges: { length: number; editRange: TypeScript.ScriptEditRange; }[] = [];
>editRanges : { length: number; editRange: any; }[]
>length : number
>类型别名 :=> 数字
>editRange : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>ScriptEditRange : No type information available!
>[] : undefined[]

        constructor(public name: string, public content: string, public isResident: boolean, public maxScriptVersions: number) {
>name : string
>类型别名 :=> 文字
>content : string
>类型别名 :=> 文字
>isResident : boolean
>类型别名 :=> 真假
>maxScriptVersions : number
>类型别名 :=> 数字

            this.version = 1;
>this.version = 1 : 1
>this.version : number
>类型别名 :=> 数字
>this : this
>version : number
>类型别名 :=> 数字
>1 : 1
        }

        public updateContent(content: string, isResident: boolean) {
>updateContent : (content: string, isResident: boolean) => void
>content : string
>类型别名 :=> 文字
>isResident : boolean
>类型别名 :=> 真假

            this.editRanges = [];
>this.editRanges = [] : undefined[]
>this.editRanges : { length: number; editRange: any; }[]
>this : this
>editRanges : { length: number; editRange: any; }[]
>[] : undefined[]

            this.content = content;
>this.content = content : string
>类型别名 :=> 文字
>this.content : string
>类型别名 :=> 文字
>this : this
>content : string
>类型别名 :=> 文字
>content : string
>类型别名 :=> 文字

            this.isResident = isResident;
>this.isResident = isResident : boolean
>类型别名 :=> 真假
>this.isResident : boolean
>类型别名 :=> 真假
>this : this
>isResident : boolean
>类型别名 :=> 真假
>isResident : boolean
>类型别名 :=> 真假

            this.version++;
>this.version++ : number
>类型别名 :=> 数字
>this.version : number
>类型别名 :=> 数字
>this : this
>version : number
>类型别名 :=> 数字
        }

        public editContent(minChar: number, limChar: number, newText: string) {
>editContent : (minChar: number, limChar: number, newText: string) => void
>minChar : number
>类型别名 :=> 数字
>limChar : number
>类型别名 :=> 数字
>newText : string
>类型别名 :=> 文字

            // Apply edits
            var prefix = this.content.substring(0, minChar);
>prefix : string
>类型别名 :=> 文字
>this.content.substring(0, minChar) : string
>类型别名 :=> 文字
>this.content.substring : (start: number, end?: number) => string
>this.content : string
>类型别名 :=> 文字
>this : this
>content : string
>类型别名 :=> 文字
>substring : (start: number, end?: number) => string
>0 : 0
>minChar : number
>类型别名 :=> 数字

            var middle = newText;
>middle : string
>类型别名 :=> 文字
>newText : string
>类型别名 :=> 文字

            var suffix = this.content.substring(limChar);
>suffix : string
>类型别名 :=> 文字
>this.content.substring(limChar) : string
>类型别名 :=> 文字
>this.content.substring : (start: number, end?: number) => string
>this.content : string
>类型别名 :=> 文字
>this : this
>content : string
>类型别名 :=> 文字
>substring : (start: number, end?: number) => string
>limChar : number
>类型别名 :=> 数字

            this.content = prefix + middle + suffix;
>this.content = prefix + middle + suffix : string
>类型别名 :=> 文字
>this.content : string
>类型别名 :=> 文字
>this : this
>content : string
>类型别名 :=> 文字
>prefix + middle + suffix : string
>类型别名 :=> 文字
>prefix + middle : string
>类型别名 :=> 文字
>prefix : string
>类型别名 :=> 文字
>middle : string
>类型别名 :=> 文字
>suffix : string
>类型别名 :=> 文字

            // Store edit range + new length of script
            this.editRanges.push({
>this.editRanges.push({                length: this.content.length,                editRange: new TypeScript.ScriptEditRange(minChar, limChar, (limChar - minChar) + newText.length)            }) : number
>类型别名 :=> 数字
>this.editRanges.push : (...items: { length: number; editRange: any; }[]) => number
>this.editRanges : { length: number; editRange: any; }[]
>this : this
>editRanges : { length: number; editRange: any; }[]
>push : (...items: { length: number; editRange: any; }[]) => number
>{                length: this.content.length,                editRange: new TypeScript.ScriptEditRange(minChar, limChar, (limChar - minChar) + newText.length)            } : { length: number; editRange: any; }

                length: this.content.length,
>length : number
>类型别名 :=> 数字
>this.content.length : number
>类型别名 :=> 数字
>this.content : string
>类型别名 :=> 文字
>this : this
>content : string
>类型别名 :=> 文字
>length : number
>类型别名 :=> 数字

                editRange: new TypeScript.ScriptEditRange(minChar, limChar, (limChar - minChar) + newText.length)
>editRange : any
>类型别名 :=> 任意
>new TypeScript.ScriptEditRange(minChar, limChar, (limChar - minChar) + newText.length) : any
>类型别名 :=> 任意
>TypeScript.ScriptEditRange : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>ScriptEditRange : any
>类型别名 :=> 任意
>minChar : number
>类型别名 :=> 数字
>limChar : number
>类型别名 :=> 数字
>(limChar - minChar) + newText.length : number
>类型别名 :=> 数字
>(limChar - minChar) : number
>类型别名 :=> 数字
>limChar - minChar : number
>类型别名 :=> 数字
>limChar : number
>类型别名 :=> 数字
>minChar : number
>类型别名 :=> 数字
>newText.length : number
>类型别名 :=> 数字
>newText : string
>类型别名 :=> 文字
>length : number
>类型别名 :=> 数字

            });

            if (this.editRanges.length > this.maxScriptVersions) {
>this.editRanges.length > this.maxScriptVersions : boolean
>类型别名 :=> 真假
>this.editRanges.length : number
>类型别名 :=> 数字
>this.editRanges : { length: number; editRange: any; }[]
>this : this
>editRanges : { length: number; editRange: any; }[]
>length : number
>类型别名 :=> 数字
>this.maxScriptVersions : number
>类型别名 :=> 数字
>this : this
>maxScriptVersions : number
>类型别名 :=> 数字

                this.editRanges.splice(0, this.maxScriptVersions - this.editRanges.length);
>this.editRanges.splice(0, this.maxScriptVersions - this.editRanges.length) : { length: number; editRange: any; }[]
>this.editRanges.splice : { (start: number, deleteCount?: number): { length: number; editRange: any; }[]; (start: number, deleteCount: number, ...items: { length: number; editRange: any; }[]): { length: number; editRange: any; }[]; }
>this.editRanges : { length: number; editRange: any; }[]
>this : this
>editRanges : { length: number; editRange: any; }[]
>splice : { (start: number, deleteCount?: number): { length: number; editRange: any; }[]; (start: number, deleteCount: number, ...items: { length: number; editRange: any; }[]): { length: number; editRange: any; }[]; }
>0 : 0
>this.maxScriptVersions - this.editRanges.length : number
>类型别名 :=> 数字
>this.maxScriptVersions : number
>类型别名 :=> 数字
>this : this
>maxScriptVersions : number
>类型别名 :=> 数字
>this.editRanges.length : number
>类型别名 :=> 数字
>this.editRanges : { length: number; editRange: any; }[]
>this : this
>editRanges : { length: number; editRange: any; }[]
>length : number
>类型别名 :=> 数字
            }

            // Update version #
            this.version++;
>this.version++ : number
>类型别名 :=> 数字
>this.version : number
>类型别名 :=> 数字
>this : this
>version : number
>类型别名 :=> 数字
        }

        public getEditRangeSinceVersion(version: number): TypeScript.ScriptEditRange {
>getEditRangeSinceVersion : (version: number) => any
>version : number
>类型别名 :=> 数字
>TypeScript : any
>类型别名 :=> 任意
>ScriptEditRange : No type information available!

            if (this.version == version) {
>this.version == version : boolean
>类型别名 :=> 真假
>this.version : number
>类型别名 :=> 数字
>this : this
>version : number
>类型别名 :=> 数字
>version : number
>类型别名 :=> 数字

                // No edits!
                return null;
>null : null
>类型别名 :=> 空值
            }

            var initialEditRangeIndex = this.editRanges.length - (this.version - version);
>initialEditRangeIndex : number
>类型别名 :=> 数字
>this.editRanges.length - (this.version - version) : number
>类型别名 :=> 数字
>this.editRanges.length : number
>类型别名 :=> 数字
>this.editRanges : { length: number; editRange: any; }[]
>this : this
>editRanges : { length: number; editRange: any; }[]
>length : number
>类型别名 :=> 数字
>(this.version - version) : number
>类型别名 :=> 数字
>this.version - version : number
>类型别名 :=> 数字
>this.version : number
>类型别名 :=> 数字
>this : this
>version : number
>类型别名 :=> 数字
>version : number
>类型别名 :=> 数字

            if (initialEditRangeIndex < 0 || initialEditRangeIndex >= this.editRanges.length) {
>initialEditRangeIndex < 0 || initialEditRangeIndex >= this.editRanges.length : boolean
>类型别名 :=> 真假
>initialEditRangeIndex < 0 : boolean
>类型别名 :=> 真假
>initialEditRangeIndex : number
>类型别名 :=> 数字
>0 : 0
>initialEditRangeIndex >= this.editRanges.length : boolean
>类型别名 :=> 真假
>initialEditRangeIndex : number
>类型别名 :=> 数字
>this.editRanges.length : number
>类型别名 :=> 数字
>this.editRanges : { length: number; editRange: any; }[]
>this : this
>editRanges : { length: number; editRange: any; }[]
>length : number
>类型别名 :=> 数字

                // Too far away from what we know
                return TypeScript.ScriptEditRange.unknown();
>TypeScript.ScriptEditRange.unknown() : any
>类型别名 :=> 任意
>TypeScript.ScriptEditRange.unknown : any
>类型别名 :=> 任意
>TypeScript.ScriptEditRange : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>ScriptEditRange : any
>类型别名 :=> 任意
>unknown : any
>类型别名 :=> 任意
            }

            var entries = this.editRanges.slice(initialEditRangeIndex);
>entries : { length: number; editRange: any; }[]
>this.editRanges.slice(initialEditRangeIndex) : { length: number; editRange: any; }[]
>this.editRanges.slice : (start?: number, end?: number) => { length: number; editRange: any; }[]
>this.editRanges : { length: number; editRange: any; }[]
>this : this
>editRanges : { length: number; editRange: any; }[]
>slice : (start?: number, end?: number) => { length: number; editRange: any; }[]
>initialEditRangeIndex : number
>类型别名 :=> 数字

            var minDistFromStart = entries.map(x => x.editRange.minChar).reduce((prev, current) => Math.min(prev, current));
>minDistFromStart : any
>类型别名 :=> 任意
>entries.map(x => x.editRange.minChar).reduce((prev, current) => Math.min(prev, current)) : any
>类型别名 :=> 任意
>entries.map(x => x.editRange.minChar).reduce : { (callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: any[]) => any): any; (callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: any[]) => any, initialValue: any): any; <U>(callbackfn: (previousValue: U, currentValue: any, currentIndex: number, array: any[]) => U, initialValue: U): U; }
>entries.map(x => x.editRange.minChar) : any[]
>entries.map : <U>(callbackfn: (value: { length: number; editRange: any; }, index: number, array: { length: number; editRange: any; }[]) => U, thisArg?: any) => U[]
>entries : { length: number; editRange: any; }[]
>map : <U>(callbackfn: (value: { length: number; editRange: any; }, index: number, array: { length: number; editRange: any; }[]) => U, thisArg?: any) => U[]
>x => x.editRange.minChar : (x: { length: number; editRange: any; }) => any
>x : { length: number; editRange: any; }
>x.editRange.minChar : any
>类型别名 :=> 任意
>x.editRange : any
>类型别名 :=> 任意
>x : { length: number; editRange: any; }
>editRange : any
>类型别名 :=> 任意
>minChar : any
>类型别名 :=> 任意
>reduce : { (callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: any[]) => any): any; (callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: any[]) => any, initialValue: any): any; <U>(callbackfn: (previousValue: U, currentValue: any, currentIndex: number, array: any[]) => U, initialValue: U): U; }
>(prev, current) => Math.min(prev, current) : (prev: any, current: any) => number
>prev : any
>类型别名 :=> 任意
>current : any
>类型别名 :=> 任意
>Math.min(prev, current) : number
>类型别名 :=> 数字
>Math.min : (...values: number[]) => number
>Math : Math
>min : (...values: number[]) => number
>prev : any
>类型别名 :=> 任意
>current : any
>类型别名 :=> 任意

            var minDistFromEnd = entries.map(x => x.length - x.editRange.limChar).reduce((prev, current) => Math.min(prev, current));
>minDistFromEnd : number
>类型别名 :=> 数字
>entries.map(x => x.length - x.editRange.limChar).reduce((prev, current) => Math.min(prev, current)) : number
>类型别名 :=> 数字
>entries.map(x => x.length - x.editRange.limChar).reduce : { (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: number[]) => number): number; (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: number[]) => number, initialValue: number): number; <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: number[]) => U, initialValue: U): U; }
>entries.map(x => x.length - x.editRange.limChar) : number[]
>entries.map : <U>(callbackfn: (value: { length: number; editRange: any; }, index: number, array: { length: number; editRange: any; }[]) => U, thisArg?: any) => U[]
>entries : { length: number; editRange: any; }[]
>map : <U>(callbackfn: (value: { length: number; editRange: any; }, index: number, array: { length: number; editRange: any; }[]) => U, thisArg?: any) => U[]
>x => x.length - x.editRange.limChar : (x: { length: number; editRange: any; }) => number
>x : { length: number; editRange: any; }
>x.length - x.editRange.limChar : number
>类型别名 :=> 数字
>x.length : number
>类型别名 :=> 数字
>x : { length: number; editRange: any; }
>length : number
>类型别名 :=> 数字
>x.editRange.limChar : any
>类型别名 :=> 任意
>x.editRange : any
>类型别名 :=> 任意
>x : { length: number; editRange: any; }
>editRange : any
>类型别名 :=> 任意
>limChar : any
>类型别名 :=> 任意
>reduce : { (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: number[]) => number): number; (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: number[]) => number, initialValue: number): number; <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: number[]) => U, initialValue: U): U; }
>(prev, current) => Math.min(prev, current) : (prev: number, current: number) => number
>prev : number
>类型别名 :=> 数字
>current : number
>类型别名 :=> 数字
>Math.min(prev, current) : number
>类型别名 :=> 数字
>Math.min : (...values: number[]) => number
>Math : Math
>min : (...values: number[]) => number
>prev : number
>类型别名 :=> 数字
>current : number
>类型别名 :=> 数字

            var aggDelta = entries.map(x => x.editRange.delta).reduce((prev, current) => prev + current);
>aggDelta : any
>类型别名 :=> 任意
>entries.map(x => x.editRange.delta).reduce((prev, current) => prev + current) : any
>类型别名 :=> 任意
>entries.map(x => x.editRange.delta).reduce : { (callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: any[]) => any): any; (callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: any[]) => any, initialValue: any): any; <U>(callbackfn: (previousValue: U, currentValue: any, currentIndex: number, array: any[]) => U, initialValue: U): U; }
>entries.map(x => x.editRange.delta) : any[]
>entries.map : <U>(callbackfn: (value: { length: number; editRange: any; }, index: number, array: { length: number; editRange: any; }[]) => U, thisArg?: any) => U[]
>entries : { length: number; editRange: any; }[]
>map : <U>(callbackfn: (value: { length: number; editRange: any; }, index: number, array: { length: number; editRange: any; }[]) => U, thisArg?: any) => U[]
>x => x.editRange.delta : (x: { length: number; editRange: any; }) => any
>x : { length: number; editRange: any; }
>x.editRange.delta : any
>类型别名 :=> 任意
>x.editRange : any
>类型别名 :=> 任意
>x : { length: number; editRange: any; }
>editRange : any
>类型别名 :=> 任意
>delta : any
>类型别名 :=> 任意
>reduce : { (callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: any[]) => any): any; (callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: any[]) => any, initialValue: any): any; <U>(callbackfn: (previousValue: U, currentValue: any, currentIndex: number, array: any[]) => U, initialValue: U): U; }
>(prev, current) => prev + current : (prev: any, current: any) => any
>prev : any
>类型别名 :=> 任意
>current : any
>类型别名 :=> 任意
>prev + current : any
>类型别名 :=> 任意
>prev : any
>类型别名 :=> 任意
>current : any
>类型别名 :=> 任意

            return new TypeScript.ScriptEditRange(minDistFromStart, entries[0].length - minDistFromEnd, aggDelta);
>new TypeScript.ScriptEditRange(minDistFromStart, entries[0].length - minDistFromEnd, aggDelta) : any
>类型别名 :=> 任意
>TypeScript.ScriptEditRange : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>ScriptEditRange : any
>类型别名 :=> 任意
>minDistFromStart : any
>类型别名 :=> 任意
>entries[0].length - minDistFromEnd : number
>类型别名 :=> 数字
>entries[0].length : number
>类型别名 :=> 数字
>entries[0] : { length: number; editRange: any; }
>entries : { length: number; editRange: any; }[]
>0 : 0
>length : number
>类型别名 :=> 数字
>minDistFromEnd : number
>类型别名 :=> 数字
>aggDelta : any
>类型别名 :=> 任意
        }
    }

    export class TypeScriptLS implements Services.ILanguageServiceShimHost {
>TypeScriptLS : TypeScriptLS
>Services.ILanguageServiceShimHost : any
>类型别名 :=> 任意
>Services : any
>类型别名 :=> 任意
>ILanguageServiceShimHost : No type information available!

        private ls: Services.ILanguageServiceShim = null;
>ls : any
>类型别名 :=> 任意
>Services : any
>类型别名 :=> 任意
>ILanguageServiceShim : No type information available!
>null : null
>类型别名 :=> 空值

        public scripts: ScriptInfo[] = [];
>scripts : ScriptInfo[]
>ScriptInfo : ScriptInfo
>[] : undefined[]

        public maxScriptVersions = 100;
>maxScriptVersions : number
>类型别名 :=> 数字
>100 : 100

        public addDefaultLibrary() {
>addDefaultLibrary : () => void

            this.addScript("lib.d.ts", Harness.Compiler.libText, true);
>this.addScript("lib.d.ts", Harness.Compiler.libText, true) : void
>类型别名 :=> 无值
>this.addScript : (name: string, content: string, isResident?: boolean) => void
>this : this
>addScript : (name: string, content: string, isResident?: boolean) => void
>"lib.d.ts" : "lib.d.ts"
>Harness.Compiler.libText : any
>类型别名 :=> 任意
>Harness.Compiler : typeof Compiler
>Harness : typeof Harness
>Compiler : typeof Compiler
>libText : any
>类型别名 :=> 任意
>true : true
>类型别名 :=> 为真
        }

        public addFile(name: string, isResident = false) {
>addFile : (name: string, isResident?: boolean) => void
>name : string
>类型别名 :=> 文字
>isResident : boolean
>类型别名 :=> 真假
>false : false
>类型别名 :=> 为假

            var code: string = readFile(name);
>code : string
>类型别名 :=> 文字
>readFile(name) : any
>类型别名 :=> 任意
>readFile : (path: string) => any
>name : string
>类型别名 :=> 文字

            this.addScript(name, code, isResident);
>this.addScript(name, code, isResident) : void
>类型别名 :=> 无值
>this.addScript : (name: string, content: string, isResident?: boolean) => void
>this : this
>addScript : (name: string, content: string, isResident?: boolean) => void
>name : string
>类型别名 :=> 文字
>code : string
>类型别名 :=> 文字
>isResident : boolean
>类型别名 :=> 真假
        }

        public addScript(name: string, content: string, isResident = false) {
>addScript : (name: string, content: string, isResident?: boolean) => void
>name : string
>类型别名 :=> 文字
>content : string
>类型别名 :=> 文字
>isResident : boolean
>类型别名 :=> 真假
>false : false
>类型别名 :=> 为假

            var script = new ScriptInfo(name, content, isResident, this.maxScriptVersions);
>script : ScriptInfo
>new ScriptInfo(name, content, isResident, this.maxScriptVersions) : ScriptInfo
>ScriptInfo : typeof ScriptInfo
>name : string
>类型别名 :=> 文字
>content : string
>类型别名 :=> 文字
>isResident : boolean
>类型别名 :=> 真假
>this.maxScriptVersions : number
>类型别名 :=> 数字
>this : this
>maxScriptVersions : number
>类型别名 :=> 数字

            this.scripts.push(script);
>this.scripts.push(script) : number
>类型别名 :=> 数字
>this.scripts.push : (...items: ScriptInfo[]) => number
>this.scripts : ScriptInfo[]
>this : this
>scripts : ScriptInfo[]
>push : (...items: ScriptInfo[]) => number
>script : ScriptInfo
        }

        public updateScript(name: string, content: string, isResident = false) {
>updateScript : (name: string, content: string, isResident?: boolean) => void
>name : string
>类型别名 :=> 文字
>content : string
>类型别名 :=> 文字
>isResident : boolean
>类型别名 :=> 真假
>false : false
>类型别名 :=> 为假

            for (var i = 0; i < this.scripts.length; i++) {
>i : number
>类型别名 :=> 数字
>0 : 0
>i < this.scripts.length : boolean
>类型别名 :=> 真假
>i : number
>类型别名 :=> 数字
>this.scripts.length : number
>类型别名 :=> 数字
>this.scripts : ScriptInfo[]
>this : this
>scripts : ScriptInfo[]
>length : number
>类型别名 :=> 数字
>i++ : number
>类型别名 :=> 数字
>i : number
>类型别名 :=> 数字

                if (this.scripts[i].name == name) {
>this.scripts[i].name == name : boolean
>类型别名 :=> 真假
>this.scripts[i].name : string
>类型别名 :=> 文字
>this.scripts[i] : ScriptInfo
>this.scripts : ScriptInfo[]
>this : this
>scripts : ScriptInfo[]
>i : number
>类型别名 :=> 数字
>name : string
>类型别名 :=> 文字
>name : string
>类型别名 :=> 文字

                    this.scripts[i].updateContent(content, isResident);
>this.scripts[i].updateContent(content, isResident) : void
>类型别名 :=> 无值
>this.scripts[i].updateContent : (content: string, isResident: boolean) => void
>this.scripts[i] : ScriptInfo
>this.scripts : ScriptInfo[]
>this : this
>scripts : ScriptInfo[]
>i : number
>类型别名 :=> 数字
>updateContent : (content: string, isResident: boolean) => void
>content : string
>类型别名 :=> 文字
>isResident : boolean
>类型别名 :=> 真假

                    return;
                }
            }

            this.addScript(name, content, isResident);
>this.addScript(name, content, isResident) : void
>类型别名 :=> 无值
>this.addScript : (name: string, content: string, isResident?: boolean) => void
>this : this
>addScript : (name: string, content: string, isResident?: boolean) => void
>name : string
>类型别名 :=> 文字
>content : string
>类型别名 :=> 文字
>isResident : boolean
>类型别名 :=> 真假
        }

        public editScript(name: string, minChar: number, limChar: number, newText: string) {
>editScript : (name: string, minChar: number, limChar: number, newText: string) => void
>name : string
>类型别名 :=> 文字
>minChar : number
>类型别名 :=> 数字
>limChar : number
>类型别名 :=> 数字
>newText : string
>类型别名 :=> 文字

            for (var i = 0; i < this.scripts.length; i++) {
>i : number
>类型别名 :=> 数字
>0 : 0
>i < this.scripts.length : boolean
>类型别名 :=> 真假
>i : number
>类型别名 :=> 数字
>this.scripts.length : number
>类型别名 :=> 数字
>this.scripts : ScriptInfo[]
>this : this
>scripts : ScriptInfo[]
>length : number
>类型别名 :=> 数字
>i++ : number
>类型别名 :=> 数字
>i : number
>类型别名 :=> 数字

                if (this.scripts[i].name == name) {
>this.scripts[i].name == name : boolean
>类型别名 :=> 真假
>this.scripts[i].name : string
>类型别名 :=> 文字
>this.scripts[i] : ScriptInfo
>this.scripts : ScriptInfo[]
>this : this
>scripts : ScriptInfo[]
>i : number
>类型别名 :=> 数字
>name : string
>类型别名 :=> 文字
>name : string
>类型别名 :=> 文字

                    this.scripts[i].editContent(minChar, limChar, newText);
>this.scripts[i].editContent(minChar, limChar, newText) : void
>类型别名 :=> 无值
>this.scripts[i].editContent : (minChar: number, limChar: number, newText: string) => void
>this.scripts[i] : ScriptInfo
>this.scripts : ScriptInfo[]
>this : this
>scripts : ScriptInfo[]
>i : number
>类型别名 :=> 数字
>editContent : (minChar: number, limChar: number, newText: string) => void
>minChar : number
>类型别名 :=> 数字
>limChar : number
>类型别名 :=> 数字
>newText : string
>类型别名 :=> 文字

                    return;
                }
            }

            throw new Error("No script with name '" + name + "'");
>new Error("No script with name '" + name + "'") : Error
>Error : ErrorConstructor
>"No script with name '" + name + "'" : string
>类型别名 :=> 文字
>"No script with name '" + name : string
>类型别名 :=> 文字
>"No script with name '" : "No script with name '"
>name : string
>类型别名 :=> 文字
>"'" : "'"
        }

        public getScriptContent(scriptIndex: number): string {
>getScriptContent : (scriptIndex: number) => string
>scriptIndex : number
>类型别名 :=> 数字

            return this.scripts[scriptIndex].content;
>this.scripts[scriptIndex].content : string
>类型别名 :=> 文字
>this.scripts[scriptIndex] : ScriptInfo
>this.scripts : ScriptInfo[]
>this : this
>scripts : ScriptInfo[]
>scriptIndex : number
>类型别名 :=> 数字
>content : string
>类型别名 :=> 文字
        }

        //////////////////////////////////////////////////////////////////////
        // ILogger implementation
        //
        public information(): boolean { return false; }
>information : () => boolean
>false : false
>类型别名 :=> 为假

        public debug(): boolean { return true; }
>debug : () => boolean
>true : true
>类型别名 :=> 为真

        public warning(): boolean { return true; }
>warning : () => boolean
>true : true
>类型别名 :=> 为真

        public error(): boolean { return true; }
>error : () => boolean
>true : true
>类型别名 :=> 为真

        public fatal(): boolean { return true; }
>fatal : () => boolean
>true : true
>类型别名 :=> 为真

        public log(s: string): void {
>log : (s: string) => void
>s : string
>类型别名 :=> 文字

            // For debugging...
            //IO.printLine("TypeScriptLS:" + s);
        }

        //////////////////////////////////////////////////////////////////////
        // ILanguageServiceShimHost implementation
        //

        public getCompilationSettings(): string/*json for Tools.CompilationSettings*/ {
>getCompilationSettings : () => string

            return ""; // i.e. default settings
>"" : ""
        }

        public getScriptCount(): number {
>getScriptCount : () => number

            return this.scripts.length;
>this.scripts.length : number
>类型别名 :=> 数字
>this.scripts : ScriptInfo[]
>this : this
>scripts : ScriptInfo[]
>length : number
>类型别名 :=> 数字
        }

        public getScriptSourceText(scriptIndex: number, start: number, end: number): string {
>getScriptSourceText : (scriptIndex: number, start: number, end: number) => string
>scriptIndex : number
>类型别名 :=> 数字
>start : number
>类型别名 :=> 数字
>end : number
>类型别名 :=> 数字

            return this.scripts[scriptIndex].content.substring(start, end);
>this.scripts[scriptIndex].content.substring(start, end) : string
>类型别名 :=> 文字
>this.scripts[scriptIndex].content.substring : (start: number, end?: number) => string
>this.scripts[scriptIndex].content : string
>类型别名 :=> 文字
>this.scripts[scriptIndex] : ScriptInfo
>this.scripts : ScriptInfo[]
>this : this
>scripts : ScriptInfo[]
>scriptIndex : number
>类型别名 :=> 数字
>content : string
>类型别名 :=> 文字
>substring : (start: number, end?: number) => string
>start : number
>类型别名 :=> 数字
>end : number
>类型别名 :=> 数字
        }

        public getScriptSourceLength(scriptIndex: number): number {
>getScriptSourceLength : (scriptIndex: number) => number
>scriptIndex : number
>类型别名 :=> 数字

            return this.scripts[scriptIndex].content.length;
>this.scripts[scriptIndex].content.length : number
>类型别名 :=> 数字
>this.scripts[scriptIndex].content : string
>类型别名 :=> 文字
>this.scripts[scriptIndex] : ScriptInfo
>this.scripts : ScriptInfo[]
>this : this
>scripts : ScriptInfo[]
>scriptIndex : number
>类型别名 :=> 数字
>content : string
>类型别名 :=> 文字
>length : number
>类型别名 :=> 数字
        }

        public getScriptId(scriptIndex: number): string {
>getScriptId : (scriptIndex: number) => string
>scriptIndex : number
>类型别名 :=> 数字

            return this.scripts[scriptIndex].name;
>this.scripts[scriptIndex].name : string
>类型别名 :=> 文字
>this.scripts[scriptIndex] : ScriptInfo
>this.scripts : ScriptInfo[]
>this : this
>scripts : ScriptInfo[]
>scriptIndex : number
>类型别名 :=> 数字
>name : string
>类型别名 :=> 文字
        }

        public getScriptIsResident(scriptIndex: number): boolean {
>getScriptIsResident : (scriptIndex: number) => boolean
>scriptIndex : number
>类型别名 :=> 数字

            return this.scripts[scriptIndex].isResident;
>this.scripts[scriptIndex].isResident : boolean
>类型别名 :=> 真假
>this.scripts[scriptIndex] : ScriptInfo
>this.scripts : ScriptInfo[]
>this : this
>scripts : ScriptInfo[]
>scriptIndex : number
>类型别名 :=> 数字
>isResident : boolean
>类型别名 :=> 真假
        }

        public getScriptVersion(scriptIndex: number): number {
>getScriptVersion : (scriptIndex: number) => number
>scriptIndex : number
>类型别名 :=> 数字

            return this.scripts[scriptIndex].version;
>this.scripts[scriptIndex].version : number
>类型别名 :=> 数字
>this.scripts[scriptIndex] : ScriptInfo
>this.scripts : ScriptInfo[]
>this : this
>scripts : ScriptInfo[]
>scriptIndex : number
>类型别名 :=> 数字
>version : number
>类型别名 :=> 数字
        }

        public getScriptEditRangeSinceVersion(scriptIndex: number, scriptVersion: number): string {
>getScriptEditRangeSinceVersion : (scriptIndex: number, scriptVersion: number) => string
>scriptIndex : number
>类型别名 :=> 数字
>scriptVersion : number
>类型别名 :=> 数字

            var range = this.scripts[scriptIndex].getEditRangeSinceVersion(scriptVersion);
>range : any
>类型别名 :=> 任意
>this.scripts[scriptIndex].getEditRangeSinceVersion(scriptVersion) : any
>类型别名 :=> 任意
>this.scripts[scriptIndex].getEditRangeSinceVersion : (version: number) => any
>this.scripts[scriptIndex] : ScriptInfo
>this.scripts : ScriptInfo[]
>this : this
>scripts : ScriptInfo[]
>scriptIndex : number
>类型别名 :=> 数字
>getEditRangeSinceVersion : (version: number) => any
>scriptVersion : number
>类型别名 :=> 数字

            var result = (range.minChar + "," + range.limChar + "," + range.delta);
>result : string
>类型别名 :=> 文字
>(range.minChar + "," + range.limChar + "," + range.delta) : string
>类型别名 :=> 文字
>range.minChar + "," + range.limChar + "," + range.delta : string
>类型别名 :=> 文字
>range.minChar + "," + range.limChar + "," : string
>类型别名 :=> 文字
>range.minChar + "," + range.limChar : string
>类型别名 :=> 文字
>range.minChar + "," : string
>类型别名 :=> 文字
>range.minChar : any
>类型别名 :=> 任意
>range : any
>类型别名 :=> 任意
>minChar : any
>类型别名 :=> 任意
>"," : ","
>range.limChar : any
>类型别名 :=> 任意
>range : any
>类型别名 :=> 任意
>limChar : any
>类型别名 :=> 任意
>"," : ","
>range.delta : any
>类型别名 :=> 任意
>range : any
>类型别名 :=> 任意
>delta : any
>类型别名 :=> 任意

            return result;
>result : string
>类型别名 :=> 文字
        }

        /** Return a new instance of the language service shim, up-to-date wrt to typecheck.
         *  To access the non-shim (i.e. actual) language service, use the "ls.languageService" property.
         */
        public getLanguageService(): Services.ILanguageServiceShim {
>getLanguageService : () => any
>Services : any
>类型别名 :=> 任意
>ILanguageServiceShim : No type information available!

            var ls = new Services.TypeScriptServicesFactory().createLanguageServiceShim(this);
>ls : any
>类型别名 :=> 任意
>new Services.TypeScriptServicesFactory().createLanguageServiceShim(this) : any
>类型别名 :=> 任意
>new Services.TypeScriptServicesFactory().createLanguageServiceShim : any
>类型别名 :=> 任意
>new Services.TypeScriptServicesFactory() : any
>类型别名 :=> 任意
>Services.TypeScriptServicesFactory : any
>类型别名 :=> 任意
>Services : any
>类型别名 :=> 任意
>TypeScriptServicesFactory : any
>类型别名 :=> 任意
>createLanguageServiceShim : any
>类型别名 :=> 任意
>this : this

            ls.refresh(true);
>ls.refresh(true) : any
>类型别名 :=> 任意
>ls.refresh : any
>类型别名 :=> 任意
>ls : any
>类型别名 :=> 任意
>refresh : any
>类型别名 :=> 任意
>true : true
>类型别名 :=> 为真

            this.ls = ls;
>this.ls = ls : any
>类型别名 :=> 任意
>this.ls : any
>类型别名 :=> 任意
>this : this
>ls : any
>类型别名 :=> 任意
>ls : any
>类型别名 :=> 任意

            return ls;
>ls : any
>类型别名 :=> 任意
        }

        /** Parse file given its source text */
        public parseSourceText(fileName: string, sourceText: TypeScript.ISourceText): TypeScript.Script {
>parseSourceText : (fileName: string, sourceText: any) => any
>fileName : string
>类型别名 :=> 文字
>sourceText : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>ISourceText : No type information available!
>TypeScript : any
>类型别名 :=> 任意
>Script : No type information available!

            var parser = new TypeScript.Parser();
>parser : any
>类型别名 :=> 任意
>new TypeScript.Parser() : any
>类型别名 :=> 任意
>TypeScript.Parser : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>Parser : any
>类型别名 :=> 任意

            parser.setErrorRecovery(null);
>parser.setErrorRecovery(null) : any
>类型别名 :=> 任意
>parser.setErrorRecovery : any
>类型别名 :=> 任意
>parser : any
>类型别名 :=> 任意
>setErrorRecovery : any
>类型别名 :=> 任意
>null : null
>类型别名 :=> 空值

            parser.errorCallback = (a, b, c, d) => { };
>parser.errorCallback = (a, b, c, d) => { } : (a: any, b: any, c: any, d: any) => void
>parser.errorCallback : any
>类型别名 :=> 任意
>parser : any
>类型别名 :=> 任意
>errorCallback : any
>类型别名 :=> 任意
>(a, b, c, d) => { } : (a: any, b: any, c: any, d: any) => void
>a : any
>类型别名 :=> 任意
>b : any
>类型别名 :=> 任意
>c : any
>类型别名 :=> 任意
>d : any
>类型别名 :=> 任意

            var script = parser.parse(sourceText, fileName, 0);
>script : any
>类型别名 :=> 任意
>parser.parse(sourceText, fileName, 0) : any
>类型别名 :=> 任意
>parser.parse : any
>类型别名 :=> 任意
>parser : any
>类型别名 :=> 任意
>parse : any
>类型别名 :=> 任意
>sourceText : any
>类型别名 :=> 任意
>fileName : string
>类型别名 :=> 文字
>0 : 0

            return script;
>script : any
>类型别名 :=> 任意
        }

        /** Parse a file on disk given its filename */
        public parseFile(fileName: string) {
>parseFile : (fileName: string) => any
>fileName : string
>类型别名 :=> 文字

            var sourceText = new TypeScript.StringSourceText(IO.readFile(fileName))
>sourceText : any
>类型别名 :=> 任意
>new TypeScript.StringSourceText(IO.readFile(fileName)) : any
>类型别名 :=> 任意
>TypeScript.StringSourceText : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>StringSourceText : any
>类型别名 :=> 任意
>IO.readFile(fileName) : any
>类型别名 :=> 任意
>IO.readFile : any
>类型别名 :=> 任意
>IO : any
>类型别名 :=> 任意
>readFile : any
>类型别名 :=> 任意
>fileName : string
>类型别名 :=> 文字

            return this.parseSourceText(fileName, sourceText);
>this.parseSourceText(fileName, sourceText) : any
>类型别名 :=> 任意
>this.parseSourceText : (fileName: string, sourceText: any) => any
>this : this
>parseSourceText : (fileName: string, sourceText: any) => any
>fileName : string
>类型别名 :=> 文字
>sourceText : any
>类型别名 :=> 任意
        }
        
        /**
         * @param line 1 based index
         * @param col 1 based index
        */
        public lineColToPosition(fileName: string, line: number, col: number): number {
>lineColToPosition : (fileName: string, line: number, col: number) => number
>fileName : string
>类型别名 :=> 文字
>line : number
>类型别名 :=> 数字
>col : number
>类型别名 :=> 数字

            var script = this.ls.languageService.getScriptAST(fileName);
>script : any
>类型别名 :=> 任意
>this.ls.languageService.getScriptAST(fileName) : any
>类型别名 :=> 任意
>this.ls.languageService.getScriptAST : any
>类型别名 :=> 任意
>this.ls.languageService : any
>类型别名 :=> 任意
>this.ls : any
>类型别名 :=> 任意
>this : this
>ls : any
>类型别名 :=> 任意
>languageService : any
>类型别名 :=> 任意
>getScriptAST : any
>类型别名 :=> 任意
>fileName : string
>类型别名 :=> 文字

            assert.notNull(script);
>assert.notNull(script) : any
>类型别名 :=> 任意
>assert.notNull : any
>类型别名 :=> 任意
>assert : any
>类型别名 :=> 任意
>notNull : any
>类型别名 :=> 任意
>script : any
>类型别名 :=> 任意

            assert.is(line >= 1);
>assert.is(line >= 1) : any
>类型别名 :=> 任意
>assert.is : any
>类型别名 :=> 任意
>assert : any
>类型别名 :=> 任意
>is : any
>类型别名 :=> 任意
>line >= 1 : boolean
>类型别名 :=> 真假
>line : number
>类型别名 :=> 数字
>1 : 1

            assert.is(col >= 1);
>assert.is(col >= 1) : any
>类型别名 :=> 任意
>assert.is : any
>类型别名 :=> 任意
>assert : any
>类型别名 :=> 任意
>is : any
>类型别名 :=> 任意
>col >= 1 : boolean
>类型别名 :=> 真假
>col : number
>类型别名 :=> 数字
>1 : 1

            assert.is(line <= script.locationInfo.lineMap.length);
>assert.is(line <= script.locationInfo.lineMap.length) : any
>类型别名 :=> 任意
>assert.is : any
>类型别名 :=> 任意
>assert : any
>类型别名 :=> 任意
>is : any
>类型别名 :=> 任意
>line <= script.locationInfo.lineMap.length : boolean
>类型别名 :=> 真假
>line : number
>类型别名 :=> 数字
>script.locationInfo.lineMap.length : any
>类型别名 :=> 任意
>script.locationInfo.lineMap : any
>类型别名 :=> 任意
>script.locationInfo : any
>类型别名 :=> 任意
>script : any
>类型别名 :=> 任意
>locationInfo : any
>类型别名 :=> 任意
>lineMap : any
>类型别名 :=> 任意
>length : any
>类型别名 :=> 任意

            return TypeScript.getPositionFromZeroBasedLineColumn(script, line - 1, col - 1);
>TypeScript.getPositionFromZeroBasedLineColumn(script, line - 1, col - 1) : any
>类型别名 :=> 任意
>TypeScript.getPositionFromZeroBasedLineColumn : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>getPositionFromZeroBasedLineColumn : any
>类型别名 :=> 任意
>script : any
>类型别名 :=> 任意
>line - 1 : number
>类型别名 :=> 数字
>line : number
>类型别名 :=> 数字
>1 : 1
>col - 1 : number
>类型别名 :=> 数字
>col : number
>类型别名 :=> 数字
>1 : 1
        }

        /**
         * @param line 0 based index
         * @param col 0 based index
        */
        public positionToZeroBasedLineCol(fileName: string, position: number): TypeScript.ILineCol {
>positionToZeroBasedLineCol : (fileName: string, position: number) => any
>fileName : string
>类型别名 :=> 文字
>position : number
>类型别名 :=> 数字
>TypeScript : any
>类型别名 :=> 任意
>ILineCol : No type information available!

            var script = this.ls.languageService.getScriptAST(fileName);
>script : any
>类型别名 :=> 任意
>this.ls.languageService.getScriptAST(fileName) : any
>类型别名 :=> 任意
>this.ls.languageService.getScriptAST : any
>类型别名 :=> 任意
>this.ls.languageService : any
>类型别名 :=> 任意
>this.ls : any
>类型别名 :=> 任意
>this : this
>ls : any
>类型别名 :=> 任意
>languageService : any
>类型别名 :=> 任意
>getScriptAST : any
>类型别名 :=> 任意
>fileName : string
>类型别名 :=> 文字

            assert.notNull(script);
>assert.notNull(script) : any
>类型别名 :=> 任意
>assert.notNull : any
>类型别名 :=> 任意
>assert : any
>类型别名 :=> 任意
>notNull : any
>类型别名 :=> 任意
>script : any
>类型别名 :=> 任意

            var result = TypeScript.getZeroBasedLineColumnFromPosition(script, position);
>result : any
>类型别名 :=> 任意
>TypeScript.getZeroBasedLineColumnFromPosition(script, position) : any
>类型别名 :=> 任意
>TypeScript.getZeroBasedLineColumnFromPosition : any
>类型别名 :=> 任意
>TypeScript : any
>类型别名 :=> 任意
>getZeroBasedLineColumnFromPosition : any
>类型别名 :=> 任意
>script : any
>类型别名 :=> 任意
>position : number
>类型别名 :=> 数字

            assert.is(result.line >= 0);
>assert.is(result.line >= 0) : any
>类型别名 :=> 任意
>assert.is : any
>类型别名 :=> 任意
>assert : any
>类型别名 :=> 任意
>is : any
>类型别名 :=> 任意
>result.line >= 0 : boolean
>类型别名 :=> 真假
>result.line : any
>类型别名 :=> 任意
>result : any
>类型别名 :=> 任意
>line : any
>类型别名 :=> 任意
>0 : 0

            assert.is(result.col >= 0);
>assert.is(result.col >= 0) : any
>类型别名 :=> 任意
>assert.is : any
>类型别名 :=> 任意
>assert : any
>类型别名 :=> 任意
>is : any
>类型别名 :=> 任意
>result.col >= 0 : boolean
>类型别名 :=> 真假
>result.col : any
>类型别名 :=> 任意
>result : any
>类型别名 :=> 任意
>col : any
>类型别名 :=> 任意
>0 : 0

            return result;
>result : any
>类型别名 :=> 任意
        }

        /** Verify that applying edits to sourceFileName result in the content of the file baselineFileName */
        public checkEdits(sourceFileName: string, baselineFileName: string, edits: Services.TextEdit[]) {
>checkEdits : (sourceFileName: string, baselineFileName: string, edits: any[]) => void
>sourceFileName : string
>类型别名 :=> 文字
>baselineFileName : string
>类型别名 :=> 文字
>edits : any[]
>Services : any
>类型别名 :=> 任意
>TextEdit : No type information available!

            var script = readFile(sourceFileName);
>script : any
>类型别名 :=> 任意
>readFile(sourceFileName) : any
>类型别名 :=> 任意
>readFile : (path: string) => any
>sourceFileName : string
>类型别名 :=> 文字

            var formattedScript = this.applyEdits(script, edits);
>formattedScript : string
>类型别名 :=> 文字
>this.applyEdits(script, edits) : string
>类型别名 :=> 文字
>this.applyEdits : (content: string, edits: any[]) => string
>this : this
>applyEdits : (content: string, edits: any[]) => string
>script : any
>类型别名 :=> 任意
>edits : any[]

            var baseline = readFile(baselineFileName);
>baseline : any
>类型别名 :=> 任意
>readFile(baselineFileName) : any
>类型别名 :=> 任意
>readFile : (path: string) => any
>baselineFileName : string
>类型别名 :=> 文字

            assert.noDiff(formattedScript, baseline);
>assert.noDiff(formattedScript, baseline) : any
>类型别名 :=> 任意
>assert.noDiff : any
>类型别名 :=> 任意
>assert : any
>类型别名 :=> 任意
>noDiff : any
>类型别名 :=> 任意
>formattedScript : string
>类型别名 :=> 文字
>baseline : any
>类型别名 :=> 任意

            assert.equal(formattedScript, baseline);
>assert.equal(formattedScript, baseline) : any
>类型别名 :=> 任意
>assert.equal : any
>类型别名 :=> 任意
>assert : any
>类型别名 :=> 任意
>equal : any
>类型别名 :=> 任意
>formattedScript : string
>类型别名 :=> 文字
>baseline : any
>类型别名 :=> 任意
        }


        /** Apply an array of text edits to a string, and return the resulting string. */
        public applyEdits(content: string, edits: Services.TextEdit[]): string {
>applyEdits : (content: string, edits: any[]) => string
>content : string
>类型别名 :=> 文字
>edits : any[]
>Services : any
>类型别名 :=> 任意
>TextEdit : No type information available!

            var result = content;
>result : string
>类型别名 :=> 文字
>content : string
>类型别名 :=> 文字

            edits = this.normalizeEdits(edits);
>edits = this.normalizeEdits(edits) : any[]
>edits : any[]
>this.normalizeEdits(edits) : any[]
>this.normalizeEdits : (edits: any[]) => any[]
>this : this
>normalizeEdits : (edits: any[]) => any[]
>edits : any[]

            for (var i = edits.length - 1; i >= 0; i--) {
>i : number
>类型别名 :=> 数字
>edits.length - 1 : number
>类型别名 :=> 数字
>edits.length : number
>类型别名 :=> 数字
>edits : any[]
>length : number
>类型别名 :=> 数字
>1 : 1
>i >= 0 : boolean
>类型别名 :=> 真假
>i : number
>类型别名 :=> 数字
>0 : 0
>i-- : number
>类型别名 :=> 数字
>i : number
>类型别名 :=> 数字

                var edit = edits[i];
>edit : any
>类型别名 :=> 任意
>edits[i] : any
>类型别名 :=> 任意
>edits : any[]
>i : number
>类型别名 :=> 数字

                var prefix = result.substring(0, edit.minChar);
>prefix : string
>类型别名 :=> 文字
>result.substring(0, edit.minChar) : string
>类型别名 :=> 文字
>result.substring : (start: number, end?: number) => string
>result : string
>类型别名 :=> 文字
>substring : (start: number, end?: number) => string
>0 : 0
>edit.minChar : any
>类型别名 :=> 任意
>edit : any
>类型别名 :=> 任意
>minChar : any
>类型别名 :=> 任意

                var middle = edit.text;
>middle : any
>类型别名 :=> 任意
>edit.text : any
>类型别名 :=> 任意
>edit : any
>类型别名 :=> 任意
>text : any
>类型别名 :=> 任意

                var suffix = result.substring(edit.limChar);
>suffix : string
>类型别名 :=> 文字
>result.substring(edit.limChar) : string
>类型别名 :=> 文字
>result.substring : (start: number, end?: number) => string
>result : string
>类型别名 :=> 文字
>substring : (start: number, end?: number) => string
>edit.limChar : any
>类型别名 :=> 任意
>edit : any
>类型别名 :=> 任意
>limChar : any
>类型别名 :=> 任意

                result = prefix + middle + suffix;
>result = prefix + middle + suffix : string
>类型别名 :=> 文字
>result : string
>类型别名 :=> 文字
>prefix + middle + suffix : string
>类型别名 :=> 文字
>prefix + middle : string
>类型别名 :=> 文字
>prefix : string
>类型别名 :=> 文字
>middle : any
>类型别名 :=> 任意
>suffix : string
>类型别名 :=> 文字
            }
            return result;
>result : string
>类型别名 :=> 文字
        }

        /** Normalize an array of edits by removing overlapping entries and sorting entries on the minChar position. */
        private normalizeEdits(edits: Services.TextEdit[]): Services.TextEdit[] {
>normalizeEdits : (edits: any[]) => any[]
>edits : any[]
>Services : any
>类型别名 :=> 任意
>TextEdit : No type information available!
>Services : any
>类型别名 :=> 任意
>TextEdit : No type information available!

            var result: Services.TextEdit[] = [];
>result : any[]
>Services : any
>类型别名 :=> 任意
>TextEdit : No type information available!
>[] : undefined[]

            function mapEdits(edits: Services.TextEdit[]): { edit: Services.TextEdit; index: number; }[] {
>mapEdits : (edits: any[]) => { edit: any; index: number; }[]
>edits : any[]
>Services : any
>类型别名 :=> 任意
>TextEdit : No type information available!
>edit : any
>类型别名 :=> 任意
>Services : any
>类型别名 :=> 任意
>TextEdit : No type information available!
>index : number
>类型别名 :=> 数字

                var result = [];
>result : any[]
>[] : undefined[]

                for (var i = 0; i < edits.length; i++) {
>i : number
>类型别名 :=> 数字
>0 : 0
>i < edits.length : boolean
>类型别名 :=> 真假
>i : number
>类型别名 :=> 数字
>edits.length : number
>类型别名 :=> 数字
>edits : any[]
>length : number
>类型别名 :=> 数字
>i++ : number
>类型别名 :=> 数字
>i : number
>类型别名 :=> 数字

                    result.push({ edit: edits[i], index: i });
>result.push({ edit: edits[i], index: i }) : number
>类型别名 :=> 数字
>result.push : (...items: any[]) => number
>result : any[]
>push : (...items: any[]) => number
>{ edit: edits[i], index: i } : { edit: any; index: number; }
>edit : any
>类型别名 :=> 任意
>edits[i] : any
>类型别名 :=> 任意
>edits : any[]
>i : number
>类型别名 :=> 数字
>index : number
>类型别名 :=> 数字
>i : number
>类型别名 :=> 数字
                }
                return result;
>result : any[]
            }

            var temp = mapEdits(edits).sort(function (a, b) {
>temp : { edit: any; index: number; }[]
>mapEdits(edits).sort(function (a, b) {                var result = a.edit.minChar - b.edit.minChar;                if (result == 0)                    result = a.index - b.index;                return result;            }) : { edit: any; index: number; }[]
>mapEdits(edits).sort : (compareFn?: (a: { edit: any; index: number; }, b: { edit: any; index: number; }) => number) => { edit: any; index: number; }[]
>mapEdits(edits) : { edit: any; index: number; }[]
>mapEdits : (edits: any[]) => { edit: any; index: number; }[]
>edits : any[]
>sort : (compareFn?: (a: { edit: any; index: number; }, b: { edit: any; index: number; }) => number) => { edit: any; index: number; }[]
>function (a, b) {                var result = a.edit.minChar - b.edit.minChar;                if (result == 0)                    result = a.index - b.index;                return result;            } : (a: { edit: any; index: number; }, b: { edit: any; index: number; }) => number
>a : { edit: any; index: number; }
>b : { edit: any; index: number; }

                var result = a.edit.minChar - b.edit.minChar;
>result : number
>类型别名 :=> 数字
>a.edit.minChar - b.edit.minChar : number
>类型别名 :=> 数字
>a.edit.minChar : any
>类型别名 :=> 任意
>a.edit : any
>类型别名 :=> 任意
>a : { edit: any; index: number; }
>edit : any
>类型别名 :=> 任意
>minChar : any
>类型别名 :=> 任意
>b.edit.minChar : any
>类型别名 :=> 任意
>b.edit : any
>类型别名 :=> 任意
>b : { edit: any; index: number; }
>edit : any
>类型别名 :=> 任意
>minChar : any
>类型别名 :=> 任意

                if (result == 0)
>result == 0 : boolean
>类型别名 :=> 真假
>result : number
>类型别名 :=> 数字
>0 : 0

                    result = a.index - b.index;
>result = a.index - b.index : number
>类型别名 :=> 数字
>result : number
>类型别名 :=> 数字
>a.index - b.index : number
>类型别名 :=> 数字
>a.index : number
>类型别名 :=> 数字
>a : { edit: any; index: number; }
>index : number
>类型别名 :=> 数字
>b.index : number
>类型别名 :=> 数字
>b : { edit: any; index: number; }
>index : number
>类型别名 :=> 数字

                return result;
>result : number
>类型别名 :=> 数字

            });

            var current = 0;
>current : number
>类型别名 :=> 数字
>0 : 0

            var next = 1;
>next : number
>类型别名 :=> 数字
>1 : 1

            while (current < temp.length) {
>current < temp.length : boolean
>类型别名 :=> 真假
>current : number
>类型别名 :=> 数字
>temp.length : number
>类型别名 :=> 数字
>temp : { edit: any; index: number; }[]
>length : number
>类型别名 :=> 数字

                var currentEdit = temp[current].edit;
>currentEdit : any
>类型别名 :=> 任意
>temp[current].edit : any
>类型别名 :=> 任意
>temp[current] : { edit: any; index: number; }
>temp : { edit: any; index: number; }[]
>current : number
>类型别名 :=> 数字
>edit : any
>类型别名 :=> 任意

                // Last edit
                if (next >= temp.length) {
>next >= temp.length : boolean
>类型别名 :=> 真假
>next : number
>类型别名 :=> 数字
>temp.length : number
>类型别名 :=> 数字
>temp : { edit: any; index: number; }[]
>length : number
>类型别名 :=> 数字

                    result.push(currentEdit);
>result.push(currentEdit) : number
>类型别名 :=> 数字
>result.push : (...items: any[]) => number
>result : any[]
>push : (...items: any[]) => number
>currentEdit : any
>类型别名 :=> 任意

                    current++;
>current++ : number
>类型别名 :=> 数字
>current : number
>类型别名 :=> 数字

                    continue;
                }
                var nextEdit = temp[next].edit;
>nextEdit : any
>类型别名 :=> 任意
>temp[next].edit : any
>类型别名 :=> 任意
>temp[next] : { edit: any; index: number; }
>temp : { edit: any; index: number; }[]
>next : number
>类型别名 :=> 数字
>edit : any
>类型别名 :=> 任意

                var gap = nextEdit.minChar - currentEdit.limChar;
>gap : number
>类型别名 :=> 数字
>nextEdit.minChar - currentEdit.limChar : number
>类型别名 :=> 数字
>nextEdit.minChar : any
>类型别名 :=> 任意
>nextEdit : any
>类型别名 :=> 任意
>minChar : any
>类型别名 :=> 任意
>currentEdit.limChar : any
>类型别名 :=> 任意
>currentEdit : any
>类型别名 :=> 任意
>limChar : any
>类型别名 :=> 任意

                // non-overlapping edits
                if (gap >= 0) {
>gap >= 0 : boolean
>类型别名 :=> 真假
>gap : number
>类型别名 :=> 数字
>0 : 0

                    result.push(currentEdit);
>result.push(currentEdit) : number
>类型别名 :=> 数字
>result.push : (...items: any[]) => number
>result : any[]
>push : (...items: any[]) => number
>currentEdit : any
>类型别名 :=> 任意

                    current = next;
>current = next : number
>类型别名 :=> 数字
>current : number
>类型别名 :=> 数字
>next : number
>类型别名 :=> 数字

                    next++;
>next++ : number
>类型别名 :=> 数字
>next : number
>类型别名 :=> 数字

                    continue;
                }

                // overlapping edits: for now, we only support ignoring an next edit 
                // entirely contained in the current edit.
                if (currentEdit.limChar >= nextEdit.limChar) {
>currentEdit.limChar >= nextEdit.limChar : boolean
>类型别名 :=> 真假
>currentEdit.limChar : any
>类型别名 :=> 任意
>currentEdit : any
>类型别名 :=> 任意
>limChar : any
>类型别名 :=> 任意
>nextEdit.limChar : any
>类型别名 :=> 任意
>nextEdit : any
>类型别名 :=> 任意
>limChar : any
>类型别名 :=> 任意

                    next++;
>next++ : number
>类型别名 :=> 数字
>next : number
>类型别名 :=> 数字

                    continue;
                }
                else {
                    throw new Error("Trying to apply overlapping edits");
>new Error("Trying to apply overlapping edits") : Error
>Error : ErrorConstructor
>"Trying to apply overlapping edits" : "Trying to apply overlapping edits"
                }
            }

            return result;
>result : any[]
        }

        public getHostSettings(): string {
>getHostSettings : () => string

            return JSON.stringify({ usePullLanguageService: usePull });
>JSON.stringify({ usePullLanguageService: usePull }) : string
>类型别名 :=> 文字
>JSON.stringify : { (value: any, replacer?: (key: string, value: any) => any, space?: string | number): string; (value: any, replacer?: (string | number)[], space?: string | number): string; }
>JSON : JSON
>stringify : { (value: any, replacer?: (key: string, value: any) => any, space?: string | number): string; (value: any, replacer?: (string | number)[], space?: string | number): string; }
>{ usePullLanguageService: usePull } : { usePullLanguageService: boolean; }
>usePullLanguageService : boolean
>类型别名 :=> 真假
>usePull : boolean
>类型别名 :=> 真假
        }
    }

    // Describe/it definitions
    export function describe(description: string, block: () => any) {
>describe : (description: string, block: () => any) => void
>description : string
>类型别名 :=> 文字
>block : () => any

        var newScenario = new Scenario(description, block);
>newScenario : Scenario
>new Scenario(description, block) : Scenario
>Scenario : typeof Scenario
>description : string
>类型别名 :=> 文字
>block : () => any

        if (Runnable.currentStack.length === 0) {
>Runnable.currentStack.length === 0 : boolean
>类型别名 :=> 真假
>Runnable.currentStack.length : number
>类型别名 :=> 数字
>Runnable.currentStack : Runnable[]
>Runnable : typeof Runnable
>currentStack : Runnable[]
>length : number
>类型别名 :=> 数字
>0 : 0

            Runnable.currentStack.push(currentRun);
>Runnable.currentStack.push(currentRun) : number
>类型别名 :=> 数字
>Runnable.currentStack.push : (...items: Runnable[]) => number
>Runnable.currentStack : Runnable[]
>Runnable : typeof Runnable
>currentStack : Runnable[]
>push : (...items: Runnable[]) => number
>currentRun : Run
        }

        Runnable.currentStack[Runnable.currentStack.length - 1].addChild(newScenario);
>Runnable.currentStack[Runnable.currentStack.length - 1].addChild(newScenario) : void
>类型别名 :=> 无值
>Runnable.currentStack[Runnable.currentStack.length - 1].addChild : (child: Runnable) => void
>Runnable.currentStack[Runnable.currentStack.length - 1] : Runnable
>Runnable.currentStack : Runnable[]
>Runnable : typeof Runnable
>currentStack : Runnable[]
>Runnable.currentStack.length - 1 : number
>类型别名 :=> 数字
>Runnable.currentStack.length : number
>类型别名 :=> 数字
>Runnable.currentStack : Runnable[]
>Runnable : typeof Runnable
>currentStack : Runnable[]
>length : number
>类型别名 :=> 数字
>1 : 1
>addChild : (child: Runnable) => void
>newScenario : Scenario
    }
    export function it(description: string, block: () => void ) {
>it : (description: string, block: () => void) => void
>description : string
>类型别名 :=> 文字
>block : () => void

        var testCase = new TestCase(description, block);
>testCase : TestCase
>new TestCase(description, block) : TestCase
>TestCase : typeof TestCase
>description : string
>类型别名 :=> 文字
>block : () => void

        Runnable.currentStack[Runnable.currentStack.length - 1].addChild(testCase);
>Runnable.currentStack[Runnable.currentStack.length - 1].addChild(testCase) : void
>类型别名 :=> 无值
>Runnable.currentStack[Runnable.currentStack.length - 1].addChild : (child: Runnable) => void
>Runnable.currentStack[Runnable.currentStack.length - 1] : Runnable
>Runnable.currentStack : Runnable[]
>Runnable : typeof Runnable
>currentStack : Runnable[]
>Runnable.currentStack.length - 1 : number
>类型别名 :=> 数字
>Runnable.currentStack.length : number
>类型别名 :=> 数字
>Runnable.currentStack : Runnable[]
>Runnable : typeof Runnable
>currentStack : Runnable[]
>length : number
>类型别名 :=> 数字
>1 : 1
>addChild : (child: Runnable) => void
>testCase : TestCase
    }

    export function run() {
>run : () => void

        if (typeof process !== "undefined") {
>typeof process !== "undefined" : boolean
>类型别名 :=> 真假
>typeof process : "string" | "number" | "boolean" | "symbol" | "undefined" | "object" | "function" | "文字" | "数字" | "真假" | "符号" | "未定" | "对象" | "函数"
>process : typeof process
>"undefined" : "undefined"

            process.on('uncaughtException', Runnable.handleError);
>process.on('uncaughtException', Runnable.handleError) : any
>类型别名 :=> 任意
>process.on : (event: string, listener: Function) => any
>process : typeof process
>on : (event: string, listener: Function) => any
>'uncaughtException' : "uncaughtException"
>Runnable.handleError : (e: Error) => void
>Runnable : typeof Runnable
>handleError : (e: Error) => void
        }

        Baseline.reset();
>Baseline.reset() : void
>类型别名 :=> 无值
>Baseline.reset : () => void
>Baseline : typeof Baseline
>reset : () => void

        currentRun.run();
>currentRun.run() : void
>类型别名 :=> 无值
>currentRun.run : () => void
>currentRun : Run
>run : () => void
    }

    /** Runs TypeScript or Javascript code. */
    export module Runner {
>Runner : typeof Runner

        export function runCollateral(path: string, callback: (error: Error, result: any) => void ) {
>runCollateral : (path: string, callback: (error: Error, result: any) => void) => void
>path : string
>类型别名 :=> 文字
>callback : (error: Error, result: any) => void
>error : Error
>Error : Error
>result : any
>类型别名 :=> 任意

            path = switchToForwardSlashes(path);
>path = switchToForwardSlashes(path) : string
>类型别名 :=> 文字
>path : string
>类型别名 :=> 文字
>switchToForwardSlashes(path) : string
>类型别名 :=> 文字
>switchToForwardSlashes : (path: string) => string
>path : string
>类型别名 :=> 文字

            runString(readFile(path), path.match(/[^\/]*$/)[0], callback);
>runString(readFile(path), path.match(/[^\/]*$/)[0], callback) : void
>类型别名 :=> 无值
>runString : (code: string, unitName: string, callback: (error: Error, result: any) => void) => void
>readFile(path) : any
>类型别名 :=> 任意
>readFile : (path: string) => any
>path : string
>类型别名 :=> 文字
>path.match(/[^\/]*$/)[0] : string
>类型别名 :=> 文字
>path.match(/[^\/]*$/) : RegExpMatchArray
>path.match : (regexp: string | RegExp) => RegExpMatchArray
>path : string
>类型别名 :=> 文字
>match : (regexp: string | RegExp) => RegExpMatchArray
>/[^\/]*$/ : RegExp
>0 : 0
>callback : (error: Error, result: any) => void
        }

        export function runJSString(code: string, callback: (error: Error, result: any) => void ) {
>runJSString : (code: string, callback: (error: Error, result: any) => void) => void
>code : string
>类型别名 :=> 文字
>callback : (error: Error, result: any) => void
>error : Error
>Error : Error
>result : any
>类型别名 :=> 任意

            // List of names that get overriden by various test code we eval
            var dangerNames: any = ['Array'];
>dangerNames : any
>类型别名 :=> 任意
>['Array'] : string[]
>'Array' : "Array"

            var globalBackup: any = {};
>globalBackup : any
>类型别名 :=> 任意
>{} : {}

            var n: string = null;
>n : string
>类型别名 :=> 文字
>null : null
>类型别名 :=> 空值

            for (n in dangerNames) {
>n : string
>类型别名 :=> 文字
>dangerNames : any
>类型别名 :=> 任意

                globalBackup[dangerNames[n]] = global[dangerNames[n]];
>globalBackup[dangerNames[n]] = global[dangerNames[n]] : any
>类型别名 :=> 任意
>globalBackup[dangerNames[n]] : any
>类型别名 :=> 任意
>globalBackup : any
>类型别名 :=> 任意
>dangerNames[n] : any
>类型别名 :=> 任意
>dangerNames : any
>类型别名 :=> 任意
>n : string
>类型别名 :=> 文字
>global[dangerNames[n]] : any
>类型别名 :=> 任意
>global : any
>类型别名 :=> 任意
>dangerNames[n] : any
>类型别名 :=> 任意
>dangerNames : any
>类型别名 :=> 任意
>n : string
>类型别名 :=> 文字
            }

            try {
                var res = eval(code);
>res : any
>类型别名 :=> 任意
>eval(code) : any
>类型别名 :=> 任意
>eval : (x: string) => any
>code : string
>类型别名 :=> 文字

                for (n in dangerNames) {
>n : string
>类型别名 :=> 文字
>dangerNames : any
>类型别名 :=> 任意

                    global[dangerNames[n]] = globalBackup[dangerNames[n]];
>global[dangerNames[n]] = globalBackup[dangerNames[n]] : any
>类型别名 :=> 任意
>global[dangerNames[n]] : any
>类型别名 :=> 任意
>global : any
>类型别名 :=> 任意
>dangerNames[n] : any
>类型别名 :=> 任意
>dangerNames : any
>类型别名 :=> 任意
>n : string
>类型别名 :=> 文字
>globalBackup[dangerNames[n]] : any
>类型别名 :=> 任意
>globalBackup : any
>类型别名 :=> 任意
>dangerNames[n] : any
>类型别名 :=> 任意
>dangerNames : any
>类型别名 :=> 任意
>n : string
>类型别名 :=> 文字
                }

                callback(null, res);
>callback(null, res) : void
>类型别名 :=> 无值
>callback : (error: Error, result: any) => void
>null : null
>类型别名 :=> 空值
>res : any
>类型别名 :=> 任意

            } catch (e) {
>e : any
>类型别名 :=> 任意

                for (n in dangerNames) {
>n : string
>类型别名 :=> 文字
>dangerNames : any
>类型别名 :=> 任意

                    global[dangerNames[n]] = globalBackup[dangerNames[n]];
>global[dangerNames[n]] = globalBackup[dangerNames[n]] : any
>类型别名 :=> 任意
>global[dangerNames[n]] : any
>类型别名 :=> 任意
>global : any
>类型别名 :=> 任意
>dangerNames[n] : any
>类型别名 :=> 任意
>dangerNames : any
>类型别名 :=> 任意
>n : string
>类型别名 :=> 文字
>globalBackup[dangerNames[n]] : any
>类型别名 :=> 任意
>globalBackup : any
>类型别名 :=> 任意
>dangerNames[n] : any
>类型别名 :=> 任意
>dangerNames : any
>类型别名 :=> 任意
>n : string
>类型别名 :=> 文字
                }

                callback(e, null);
>callback(e, null) : void
>类型别名 :=> 无值
>callback : (error: Error, result: any) => void
>e : any
>类型别名 :=> 任意
>null : null
>类型别名 :=> 空值
            }
        }

        export function runString(code: string, unitName: string, callback: (error: Error, result: any) => void ) {
>runString : (code: string, unitName: string, callback: (error: Error, result: any) => void) => void
>code : string
>类型别名 :=> 文字
>unitName : string
>类型别名 :=> 文字
>callback : (error: Error, result: any) => void
>error : Error
>Error : Error
>result : any
>类型别名 :=> 任意

            Compiler.compileString(code, unitName, function (res) {
>Compiler.compileString(code, unitName, function (res) {                runJSString(res.code, callback);            }) : void
>类型别名 :=> 无值
>Compiler.compileString : (code: string, unitName: string, callback: (res: Compiler.CompilerResult) => void, context?: Compiler.CompilationContext, references?: any[]) => void
>Compiler : typeof Compiler
>compileString : (code: string, unitName: string, callback: (res: Compiler.CompilerResult) => void, context?: Compiler.CompilationContext, references?: any[]) => void
>code : string
>类型别名 :=> 文字
>unitName : string
>类型别名 :=> 文字
>function (res) {                runJSString(res.code, callback);            } : (res: Compiler.CompilerResult) => void
>res : Compiler.CompilerResult

                runJSString(res.code, callback);
>runJSString(res.code, callback) : void
>类型别名 :=> 无值
>runJSString : (code: string, callback: (error: Error, result: any) => void) => void
>res.code : string
>类型别名 :=> 文字
>res : Compiler.CompilerResult
>code : string
>类型别名 :=> 文字
>callback : (error: Error, result: any) => void

            });
        }
    }

    /** Support class for baseline files */
    export module Baseline {
>Baseline : typeof Baseline

        var reportFilename = 'baseline-report.html';
>reportFilename : string
>类型别名 :=> 文字
>'baseline-report.html' : "baseline-report.html"

        var firstRun = true;
>firstRun : boolean
>类型别名 :=> 真假
>true : true
>类型别名 :=> 为真

        var htmlTrailer = '</body></html>';
>htmlTrailer : string
>类型别名 :=> 文字
>'</body></html>' : "</body></html>"

        var htmlLeader = '<html><head><title>Baseline Report</title>';
>htmlLeader : string
>类型别名 :=> 文字
>'<html><head><title>Baseline Report</title>' : "<html><head><title>Baseline Report</title>"

        htmlLeader += ("<style>");
>htmlLeader += ("<style>") : string
>类型别名 :=> 文字
>htmlLeader : string
>类型别名 :=> 文字
>("<style>") : "<style>"
>"<style>" : "<style>"

        htmlLeader += '\r\n' + (".code { font: 9pt 'Courier New'; }");
>htmlLeader += '\r\n' + (".code { font: 9pt 'Courier New'; }") : string
>类型别名 :=> 文字
>htmlLeader : string
>类型别名 :=> 文字
>'\r\n' + (".code { font: 9pt 'Courier New'; }") : string
>类型别名 :=> 文字
>'\r\n' : "\r\n"
>(".code { font: 9pt 'Courier New'; }") : ".code { font: 9pt 'Courier New'; }"
>".code { font: 9pt 'Courier New'; }" : ".code { font: 9pt 'Courier New'; }"

        htmlLeader += '\r\n' + (".old { background-color: #EE1111; }");
>htmlLeader += '\r\n' + (".old { background-color: #EE1111; }") : string
>类型别名 :=> 文字
>htmlLeader : string
>类型别名 :=> 文字
>'\r\n' + (".old { background-color: #EE1111; }") : string
>类型别名 :=> 文字
>'\r\n' : "\r\n"
>(".old { background-color: #EE1111; }") : ".old { background-color: #EE1111; }"
>".old { background-color: #EE1111; }" : ".old { background-color: #EE1111; }"

        htmlLeader += '\r\n' + (".new { background-color: #FFFF11; }");
>htmlLeader += '\r\n' + (".new { background-color: #FFFF11; }") : string
>类型别名 :=> 文字
>htmlLeader : string
>类型别名 :=> 文字
>'\r\n' + (".new { background-color: #FFFF11; }") : string
>类型别名 :=> 文字
>'\r\n' : "\r\n"
>(".new { background-color: #FFFF11; }") : ".new { background-color: #FFFF11; }"
>".new { background-color: #FFFF11; }" : ".new { background-color: #FFFF11; }"

        htmlLeader += '\r\n' + (".from { background-color: #EE1111; color: #1111EE; }");
>htmlLeader += '\r\n' + (".from { background-color: #EE1111; color: #1111EE; }") : string
>类型别名 :=> 文字
>htmlLeader : string
>类型别名 :=> 文字
>'\r\n' + (".from { background-color: #EE1111; color: #1111EE; }") : string
>类型别名 :=> 文字
>'\r\n' : "\r\n"
>(".from { background-color: #EE1111; color: #1111EE; }") : ".from { background-color: #EE1111; color: #1111EE; }"
>".from { background-color: #EE1111; color: #1111EE; }" : ".from { background-color: #EE1111; color: #1111EE; }"

        htmlLeader += '\r\n' + (".to { background-color: #EEEE11; color: #1111EE; }");
>htmlLeader += '\r\n' + (".to { background-color: #EEEE11; color: #1111EE; }") : string
>类型别名 :=> 文字
>htmlLeader : string
>类型别名 :=> 文字
>'\r\n' + (".to { background-color: #EEEE11; color: #1111EE; }") : string
>类型别名 :=> 文字
>'\r\n' : "\r\n"
>(".to { background-color: #EEEE11; color: #1111EE; }") : ".to { background-color: #EEEE11; color: #1111EE; }"
>".to { background-color: #EEEE11; color: #1111EE; }" : ".to { background-color: #EEEE11; color: #1111EE; }"

        htmlLeader += '\r\n' + ("h2 { margin-bottom: 0px; }");
>htmlLeader += '\r\n' + ("h2 { margin-bottom: 0px; }") : string
>类型别名 :=> 文字
>htmlLeader : string
>类型别名 :=> 文字
>'\r\n' + ("h2 { margin-bottom: 0px; }") : string
>类型别名 :=> 文字
>'\r\n' : "\r\n"
>("h2 { margin-bottom: 0px; }") : "h2 { margin-bottom: 0px; }"
>"h2 { margin-bottom: 0px; }" : "h2 { margin-bottom: 0px; }"

        htmlLeader += '\r\n' + ("h2 { padding-bottom: 0px; }");
>htmlLeader += '\r\n' + ("h2 { padding-bottom: 0px; }") : string
>类型别名 :=> 文字
>htmlLeader : string
>类型别名 :=> 文字
>'\r\n' + ("h2 { padding-bottom: 0px; }") : string
>类型别名 :=> 文字
>'\r\n' : "\r\n"
>("h2 { padding-bottom: 0px; }") : "h2 { padding-bottom: 0px; }"
>"h2 { padding-bottom: 0px; }" : "h2 { padding-bottom: 0px; }"

        htmlLeader += '\r\n' + ("h4 { font-weight: normal; }");
>htmlLeader += '\r\n' + ("h4 { font-weight: normal; }") : string
>类型别名 :=> 文字
>htmlLeader : string
>类型别名 :=> 文字
>'\r\n' + ("h4 { font-weight: normal; }") : string
>类型别名 :=> 文字
>'\r\n' : "\r\n"
>("h4 { font-weight: normal; }") : "h4 { font-weight: normal; }"
>"h4 { font-weight: normal; }" : "h4 { font-weight: normal; }"

        htmlLeader += '\r\n' + ("</style>");
>htmlLeader += '\r\n' + ("</style>") : string
>类型别名 :=> 文字
>htmlLeader : string
>类型别名 :=> 文字
>'\r\n' + ("</style>") : string
>类型别名 :=> 文字
>'\r\n' : "\r\n"
>("</style>") : "</style>"
>"</style>" : "</style>"

        export interface BaselineOptions {
>BaselineOptions : BaselineOptions

            LineEndingSensitive?: boolean;
>LineEndingSensitive : boolean
>类型别名 :=> 真假
        }

        function localPath(filename: string) {
>localPath : (filename: string) => string
>filename : string
>类型别名 :=> 文字

            if (global.runners[0].testType === 'prototyping') {
>global.runners[0].testType === 'prototyping' : boolean
>类型别名 :=> 真假
>global.runners[0].testType : any
>类型别名 :=> 任意
>global.runners[0] : any
>类型别名 :=> 任意
>global.runners : any
>类型别名 :=> 任意
>global : any
>类型别名 :=> 任意
>runners : any
>类型别名 :=> 任意
>0 : 0
>testType : any
>类型别名 :=> 任意
>'prototyping' : "prototyping"

                return Harness.userSpecifiedroot + 'tests/baselines/prototyping/local/' + filename;
>Harness.userSpecifiedroot + 'tests/baselines/prototyping/local/' + filename : string
>类型别名 :=> 文字
>Harness.userSpecifiedroot + 'tests/baselines/prototyping/local/' : string
>类型别名 :=> 文字
>Harness.userSpecifiedroot : string
>类型别名 :=> 文字
>Harness : typeof Harness
>userSpecifiedroot : string
>类型别名 :=> 文字
>'tests/baselines/prototyping/local/' : "tests/baselines/prototyping/local/"
>filename : string
>类型别名 :=> 文字
            }
            else {
                return Harness.userSpecifiedroot + 'tests/baselines/local/' + filename;
>Harness.userSpecifiedroot + 'tests/baselines/local/' + filename : string
>类型别名 :=> 文字
>Harness.userSpecifiedroot + 'tests/baselines/local/' : string
>类型别名 :=> 文字
>Harness.userSpecifiedroot : string
>类型别名 :=> 文字
>Harness : typeof Harness
>userSpecifiedroot : string
>类型别名 :=> 文字
>'tests/baselines/local/' : "tests/baselines/local/"
>filename : string
>类型别名 :=> 文字
            }
        }

        function referencePath(filename: string) {
>referencePath : (filename: string) => string
>filename : string
>类型别名 :=> 文字

            if (global.runners[0].testType === 'prototyping') {
>global.runners[0].testType === 'prototyping' : boolean
>类型别名 :=> 真假
>global.runners[0].testType : any
>类型别名 :=> 任意
>global.runners[0] : any
>类型别名 :=> 任意
>global.runners : any
>类型别名 :=> 任意
>global : any
>类型别名 :=> 任意
>runners : any
>类型别名 :=> 任意
>0 : 0
>testType : any
>类型别名 :=> 任意
>'prototyping' : "prototyping"

                return Harness.userSpecifiedroot + 'tests/baselines/prototyping/reference/' + filename;
>Harness.userSpecifiedroot + 'tests/baselines/prototyping/reference/' + filename : string
>类型别名 :=> 文字
>Harness.userSpecifiedroot + 'tests/baselines/prototyping/reference/' : string
>类型别名 :=> 文字
>Harness.userSpecifiedroot : string
>类型别名 :=> 文字
>Harness : typeof Harness
>userSpecifiedroot : string
>类型别名 :=> 文字
>'tests/baselines/prototyping/reference/' : "tests/baselines/prototyping/reference/"
>filename : string
>类型别名 :=> 文字
            }
            else {
                return Harness.userSpecifiedroot + 'tests/baselines/reference/' + filename;
>Harness.userSpecifiedroot + 'tests/baselines/reference/' + filename : string
>类型别名 :=> 文字
>Harness.userSpecifiedroot + 'tests/baselines/reference/' : string
>类型别名 :=> 文字
>Harness.userSpecifiedroot : string
>类型别名 :=> 文字
>Harness : typeof Harness
>userSpecifiedroot : string
>类型别名 :=> 文字
>'tests/baselines/reference/' : "tests/baselines/reference/"
>filename : string
>类型别名 :=> 文字
            }
        }

        export function reset() {
>reset : () => void

            if (IO.fileExists(reportFilename)) {
>IO.fileExists(reportFilename) : any
>类型别名 :=> 任意
>IO.fileExists : any
>类型别名 :=> 任意
>IO : any
>类型别名 :=> 任意
>fileExists : any
>类型别名 :=> 任意
>reportFilename : string
>类型别名 :=> 文字

                IO.deleteFile(reportFilename);
>IO.deleteFile(reportFilename) : any
>类型别名 :=> 任意
>IO.deleteFile : any
>类型别名 :=> 任意
>IO : any
>类型别名 :=> 任意
>deleteFile : any
>类型别名 :=> 任意
>reportFilename : string
>类型别名 :=> 文字
            }
        }

        function prepareBaselineReport(): string {
>prepareBaselineReport : () => string

            var reportContent = htmlLeader;
>reportContent : string
>类型别名 :=> 文字
>htmlLeader : string
>类型别名 :=> 文字

            // Delete the baseline-report.html file if needed
            if (IO.fileExists(reportFilename)) {
>IO.fileExists(reportFilename) : any
>类型别名 :=> 任意
>IO.fileExists : any
>类型别名 :=> 任意
>IO : any
>类型别名 :=> 任意
>fileExists : any
>类型别名 :=> 任意
>reportFilename : string
>类型别名 :=> 文字

                reportContent = IO.readFile(reportFilename);
>reportContent = IO.readFile(reportFilename) : any
>类型别名 :=> 任意
>reportContent : string
>类型别名 :=> 文字
>IO.readFile(reportFilename) : any
>类型别名 :=> 任意
>IO.readFile : any
>类型别名 :=> 任意
>IO : any
>类型别名 :=> 任意
>readFile : any
>类型别名 :=> 任意
>reportFilename : string
>类型别名 :=> 文字

                reportContent = reportContent.replace(htmlTrailer, '');
>reportContent = reportContent.replace(htmlTrailer, '') : string
>类型别名 :=> 文字
>reportContent : string
>类型别名 :=> 文字
>reportContent.replace(htmlTrailer, '') : string
>类型别名 :=> 文字
>reportContent.replace : { (searchValue: string | RegExp, replaceValue: string): string; (searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string; }
>reportContent : string
>类型别名 :=> 文字
>replace : { (searchValue: string | RegExp, replaceValue: string): string; (searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string; }
>htmlTrailer : string
>类型别名 :=> 文字
>'' : ""

            } else {
                reportContent = htmlLeader;
>reportContent = htmlLeader : string
>类型别名 :=> 文字
>reportContent : string
>类型别名 :=> 文字
>htmlLeader : string
>类型别名 :=> 文字
            }
            return reportContent;
>reportContent : string
>类型别名 :=> 文字
        }

        function generateActual(actualFilename: string, generateContent: () => string): string {
>generateActual : (actualFilename: string, generateContent: () => string) => string
>actualFilename : string
>类型别名 :=> 文字
>generateContent : () => string

            // Create folders if needed
            IO.createDirectory(IO.dirName(IO.dirName(actualFilename)));
>IO.createDirectory(IO.dirName(IO.dirName(actualFilename))) : any
>类型别名 :=> 任意
>IO.createDirectory : any
>类型别名 :=> 任意
>IO : any
>类型别名 :=> 任意
>createDirectory : any
>类型别名 :=> 任意
>IO.dirName(IO.dirName(actualFilename)) : any
>类型别名 :=> 任意
>IO.dirName : any
>类型别名 :=> 任意
>IO : any
>类型别名 :=> 任意
>dirName : any
>类型别名 :=> 任意
>IO.dirName(actualFilename) : any
>类型别名 :=> 任意
>IO.dirName : any
>类型别名 :=> 任意
>IO : any
>类型别名 :=> 任意
>dirName : any
>类型别名 :=> 任意
>actualFilename : string
>类型别名 :=> 文字

            IO.createDirectory(IO.dirName(actualFilename));
>IO.createDirectory(IO.dirName(actualFilename)) : any
>类型别名 :=> 任意
>IO.createDirectory : any
>类型别名 :=> 任意
>IO : any
>类型别名 :=> 任意
>createDirectory : any
>类型别名 :=> 任意
>IO.dirName(actualFilename) : any
>类型别名 :=> 任意
>IO.dirName : any
>类型别名 :=> 任意
>IO : any
>类型别名 :=> 任意
>dirName : any
>类型别名 :=> 任意
>actualFilename : string
>类型别名 :=> 文字

            // Delete the actual file in case it fails
            if (IO.fileExists(actualFilename)) {
>IO.fileExists(actualFilename) : any
>类型别名 :=> 任意
>IO.fileExists : any
>类型别名 :=> 任意
>IO : any
>类型别名 :=> 任意
>fileExists : any
>类型别名 :=> 任意
>actualFilename : string
>类型别名 :=> 文字

                IO.deleteFile(actualFilename);
>IO.deleteFile(actualFilename) : any
>类型别名 :=> 任意
>IO.deleteFile : any
>类型别名 :=> 任意
>IO : any
>类型别名 :=> 任意
>deleteFile : any
>类型别名 :=> 任意
>actualFilename : string
>类型别名 :=> 文字
            }

            var actual = generateContent();
>actual : string
>类型别名 :=> 文字
>generateContent() : string
>类型别名 :=> 文字
>generateContent : () => string

            if (actual === undefined) {
>actual === undefined : boolean
>类型别名 :=> 真假
>actual : string
>类型别名 :=> 文字
>undefined : undefined
>类型别名 :=> 未定

                throw new Error('The generated content was "undefined". Return "null" if no baselining is required."');
>new Error('The generated content was "undefined". Return "null" if no baselining is required."') : Error
>Error : ErrorConstructor
>'The generated content was "undefined". Return "null" if no baselining is required."' : "The generated content was \"undefined\". Return \"null\" if no baselining is required.\""
            }

            // Store the content in the 'local' folder so we
            // can accept it later (manually)
            if (actual !== null) {
>actual !== null : boolean
>类型别名 :=> 真假
>actual : string
>类型别名 :=> 文字
>null : null
>类型别名 :=> 空值

                IO.writeFile(actualFilename, actual);
>IO.writeFile(actualFilename, actual) : any
>类型别名 :=> 任意
>IO.writeFile : any
>类型别名 :=> 任意
>IO : any
>类型别名 :=> 任意
>writeFile : any
>类型别名 :=> 任意
>actualFilename : string
>类型别名 :=> 文字
>actual : string
>类型别名 :=> 文字
            }

            return actual;
>actual : string
>类型别名 :=> 文字
        }

        function compareToBaseline(actual: string, relativeFilename: string, opts: BaselineOptions) {
>compareToBaseline : (actual: string, relativeFilename: string, opts: BaselineOptions) => { expected: string; actual: string; }
>actual : string
>类型别名 :=> 文字
>relativeFilename : string
>类型别名 :=> 文字
>opts : BaselineOptions
>BaselineOptions : BaselineOptions

            // actual is now either undefined (the generator had an error), null (no file requested),
            // or some real output of the function
            if (actual === undefined) {
>actual === undefined : boolean
>类型别名 :=> 真假
>actual : string
>类型别名 :=> 文字
>undefined : undefined
>类型别名 :=> 未定

                // Nothing to do
                return;
            }

            var refFilename = referencePath(relativeFilename);
>refFilename : string
>类型别名 :=> 文字
>referencePath(relativeFilename) : string
>类型别名 :=> 文字
>referencePath : (filename: string) => string
>relativeFilename : string
>类型别名 :=> 文字

            if (actual === null) {
>actual === null : boolean
>类型别名 :=> 真假
>actual : string
>类型别名 :=> 文字
>null : null
>类型别名 :=> 空值

                actual = '<no content>';
>actual = '<no content>' : "<no content>"
>actual : string
>类型别名 :=> 文字
>'<no content>' : "<no content>"
            }

            var expected = '<no content>';
>expected : string
>类型别名 :=> 文字
>'<no content>' : "<no content>"

            if (IO.fileExists(refFilename)) {
>IO.fileExists(refFilename) : any
>类型别名 :=> 任意
>IO.fileExists : any
>类型别名 :=> 任意
>IO : any
>类型别名 :=> 任意
>fileExists : any
>类型别名 :=> 任意
>refFilename : string
>类型别名 :=> 文字

                expected = IO.readFile(refFilename);
>expected = IO.readFile(refFilename) : any
>类型别名 :=> 任意
>expected : string
>类型别名 :=> 文字
>IO.readFile(refFilename) : any
>类型别名 :=> 任意
>IO.readFile : any
>类型别名 :=> 任意
>IO : any
>类型别名 :=> 任意
>readFile : any
>类型别名 :=> 任意
>refFilename : string
>类型别名 :=> 文字
            }

            var lineEndingSensitive = opts && opts.LineEndingSensitive;
>lineEndingSensitive : boolean
>类型别名 :=> 真假
>opts && opts.LineEndingSensitive : boolean
>类型别名 :=> 真假
>opts : BaselineOptions
>opts.LineEndingSensitive : boolean
>类型别名 :=> 真假
>opts : BaselineOptions
>LineEndingSensitive : boolean
>类型别名 :=> 真假

            if (!lineEndingSensitive) {
>!lineEndingSensitive : boolean
>类型别名 :=> 真假
>lineEndingSensitive : boolean
>类型别名 :=> 真假

                expected = expected.replace(/\r\n?/g, '\n')
>expected = expected.replace(/\r\n?/g, '\n') : string
>类型别名 :=> 文字
>expected : string
>类型别名 :=> 文字
>expected.replace(/\r\n?/g, '\n') : string
>类型别名 :=> 文字
>expected.replace : { (searchValue: string | RegExp, replaceValue: string): string; (searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string; }
>expected : string
>类型别名 :=> 文字
>replace : { (searchValue: string | RegExp, replaceValue: string): string; (searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string; }
>/\r\n?/g : RegExp
>'\n' : "\n"

                actual = actual.replace(/\r\n?/g, '\n')
>actual = actual.replace(/\r\n?/g, '\n') : string
>类型别名 :=> 文字
>actual : string
>类型别名 :=> 文字
>actual.replace(/\r\n?/g, '\n') : string
>类型别名 :=> 文字
>actual.replace : { (searchValue: string | RegExp, replaceValue: string): string; (searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string; }
>actual : string
>类型别名 :=> 文字
>replace : { (searchValue: string | RegExp, replaceValue: string): string; (searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string; }
>/\r\n?/g : RegExp
>'\n' : "\n"
            }

            return { expected: expected, actual: actual };
>{ expected: expected, actual: actual } : { expected: string; actual: string; }
>expected : string
>类型别名 :=> 文字
>expected : string
>类型别名 :=> 文字
>actual : string
>类型别名 :=> 文字
>actual : string
>类型别名 :=> 文字
        }

        function writeComparison(expected: string, actual: string, relativeFilename: string, actualFilename: string, descriptionForDescribe: string) {
>writeComparison : (expected: string, actual: string, relativeFilename: string, actualFilename: string, descriptionForDescribe: string) => void
>expected : string
>类型别名 :=> 文字
>actual : string
>类型别名 :=> 文字
>relativeFilename : string
>类型别名 :=> 文字
>actualFilename : string
>类型别名 :=> 文字
>descriptionForDescribe : string
>类型别名 :=> 文字

            if (expected != actual) {
>expected != actual : boolean
>类型别名 :=> 真假
>expected : string
>类型别名 :=> 文字
>actual : string
>类型别名 :=> 文字

                // Overwrite & issue error
                var errMsg = 'The baseline file ' + relativeFilename + ' has changed. Please refer to baseline-report.html and ';
>errMsg : string
>类型别名 :=> 文字
>'The baseline file ' + relativeFilename + ' has changed. Please refer to baseline-report.html and ' : string
>类型别名 :=> 文字
>'The baseline file ' + relativeFilename : string
>类型别名 :=> 文字
>'The baseline file ' : "The baseline file "
>relativeFilename : string
>类型别名 :=> 文字
>' has changed. Please refer to baseline-report.html and ' : " has changed. Please refer to baseline-report.html and "

                errMsg += 'either fix the regression (if unintended) or run nmake baseline-accept (if intended).'
>errMsg += 'either fix the regression (if unintended) or run nmake baseline-accept (if intended).' : string
>类型别名 :=> 文字
>errMsg : string
>类型别名 :=> 文字
>'either fix the regression (if unintended) or run nmake baseline-accept (if intended).' : "either fix the regression (if unintended) or run nmake baseline-accept (if intended)."

                var refFilename = referencePath(relativeFilename);
>refFilename : string
>类型别名 :=> 文字
>referencePath(relativeFilename) : string
>类型别名 :=> 文字
>referencePath : (filename: string) => string
>relativeFilename : string
>类型别名 :=> 文字

                // Append diff to the report
                var diff = new Diff.StringDiff(expected, actual);
>diff : any
>类型别名 :=> 任意
>new Diff.StringDiff(expected, actual) : any
>类型别名 :=> 任意
>Diff.StringDiff : any
>类型别名 :=> 任意
>Diff : any
>类型别名 :=> 任意
>StringDiff : any
>类型别名 :=> 任意
>expected : string
>类型别名 :=> 文字
>actual : string
>类型别名 :=> 文字

                var header = '<h2>' + descriptionForDescribe + '</h2>';
>header : string
>类型别名 :=> 文字
>'<h2>' + descriptionForDescribe + '</h2>' : string
>类型别名 :=> 文字
>'<h2>' + descriptionForDescribe : string
>类型别名 :=> 文字
>'<h2>' : "<h2>"
>descriptionForDescribe : string
>类型别名 :=> 文字
>'</h2>' : "</h2>"

                header += '<h4>Left file: ' + actualFilename + '; Right file: ' + refFilename + '</h4>';
>header += '<h4>Left file: ' + actualFilename + '; Right file: ' + refFilename + '</h4>' : string
>类型别名 :=> 文字
>header : string
>类型别名 :=> 文字
>'<h4>Left file: ' + actualFilename + '; Right file: ' + refFilename + '</h4>' : string
>类型别名 :=> 文字
>'<h4>Left file: ' + actualFilename + '; Right file: ' + refFilename : string
>类型别名 :=> 文字
>'<h4>Left file: ' + actualFilename + '; Right file: ' : string
>类型别名 :=> 文字
>'<h4>Left file: ' + actualFilename : string
>类型别名 :=> 文字
>'<h4>Left file: ' : "<h4>Left file: "
>actualFilename : string
>类型别名 :=> 文字
>'; Right file: ' : "; Right file: "
>refFilename : string
>类型别名 :=> 文字
>'</h4>' : "</h4>"

                var trailer = '<hr>';
>trailer : string
>类型别名 :=> 文字
>'<hr>' : "<hr>"

                var reportContentSoFar = prepareBaselineReport();
>reportContentSoFar : string
>类型别名 :=> 文字
>prepareBaselineReport() : string
>类型别名 :=> 文字
>prepareBaselineReport : () => string

                reportContentSoFar = reportContentSoFar + header + '<div class="code">' + diff.mergedHtml + '</div>' + trailer + htmlTrailer;
>reportContentSoFar = reportContentSoFar + header + '<div class="code">' + diff.mergedHtml + '</div>' + trailer + htmlTrailer : string
>类型别名 :=> 文字
>reportContentSoFar : string
>类型别名 :=> 文字
>reportContentSoFar + header + '<div class="code">' + diff.mergedHtml + '</div>' + trailer + htmlTrailer : string
>类型别名 :=> 文字
>reportContentSoFar + header + '<div class="code">' + diff.mergedHtml + '</div>' + trailer : string
>类型别名 :=> 文字
>reportContentSoFar + header + '<div class="code">' + diff.mergedHtml + '</div>' : string
>类型别名 :=> 文字
>reportContentSoFar + header + '<div class="code">' + diff.mergedHtml : string
>类型别名 :=> 文字
>reportContentSoFar + header + '<div class="code">' : string
>类型别名 :=> 文字
>reportContentSoFar + header : string
>类型别名 :=> 文字
>reportContentSoFar : string
>类型别名 :=> 文字
>header : string
>类型别名 :=> 文字
>'<div class="code">' : "<div class=\"code\">"
>diff.mergedHtml : any
>类型别名 :=> 任意
>diff : any
>类型别名 :=> 任意
>mergedHtml : any
>类型别名 :=> 任意
>'</div>' : "</div>"
>trailer : string
>类型别名 :=> 文字
>htmlTrailer : string
>类型别名 :=> 文字

                IO.writeFile(reportFilename, reportContentSoFar);
>IO.writeFile(reportFilename, reportContentSoFar) : any
>类型别名 :=> 任意
>IO.writeFile : any
>类型别名 :=> 任意
>IO : any
>类型别名 :=> 任意
>writeFile : any
>类型别名 :=> 任意
>reportFilename : string
>类型别名 :=> 文字
>reportContentSoFar : string
>类型别名 :=> 文字

                throw new Error(errMsg);
>new Error(errMsg) : Error
>Error : ErrorConstructor
>errMsg : string
>类型别名 :=> 文字
            }
        }

        export function runBaseline(
>runBaseline : (descriptionForDescribe: string, relativeFilename: string, generateContent: () => string, runImmediately?: boolean, opts?: BaselineOptions) => void

            descriptionForDescribe: string,
>descriptionForDescribe : string
>类型别名 :=> 文字

            relativeFilename: string,
>relativeFilename : string
>类型别名 :=> 文字

            generateContent: () => string,
>generateContent : () => string

            runImmediately? = false,
>runImmediately : boolean
>类型别名 :=> 真假
>false : false
>类型别名 :=> 为假

            opts?: BaselineOptions) {
>opts : BaselineOptions
>BaselineOptions : BaselineOptions

            var actual = <string>undefined;
>actual : string
>类型别名 :=> 文字
><string>undefined : string
>类型别名 :=> 文字
>undefined : undefined
>类型别名 :=> 未定

            var actualFilename = localPath(relativeFilename);
>actualFilename : string
>类型别名 :=> 文字
>localPath(relativeFilename) : string
>类型别名 :=> 文字
>localPath : (filename: string) => string
>relativeFilename : string
>类型别名 :=> 文字

            if (runImmediately) {
>runImmediately : boolean
>类型别名 :=> 真假

                var actual = generateActual(actualFilename, generateContent);
>actual : string
>类型别名 :=> 文字
>generateActual(actualFilename, generateContent) : string
>类型别名 :=> 文字
>generateActual : (actualFilename: string, generateContent: () => string) => string
>actualFilename : string
>类型别名 :=> 文字
>generateContent : () => string

                var comparison = compareToBaseline(actual, relativeFilename, opts);
>comparison : { expected: string; actual: string; }
>compareToBaseline(actual, relativeFilename, opts) : { expected: string; actual: string; }
>compareToBaseline : (actual: string, relativeFilename: string, opts: BaselineOptions) => { expected: string; actual: string; }
>actual : string
>类型别名 :=> 文字
>relativeFilename : string
>类型别名 :=> 文字
>opts : BaselineOptions

                writeComparison(comparison.expected, comparison.actual, relativeFilename, actualFilename, descriptionForDescribe);
>writeComparison(comparison.expected, comparison.actual, relativeFilename, actualFilename, descriptionForDescribe) : void
>类型别名 :=> 无值
>writeComparison : (expected: string, actual: string, relativeFilename: string, actualFilename: string, descriptionForDescribe: string) => void
>comparison.expected : string
>类型别名 :=> 文字
>comparison : { expected: string; actual: string; }
>expected : string
>类型别名 :=> 文字
>comparison.actual : string
>类型别名 :=> 文字
>comparison : { expected: string; actual: string; }
>actual : string
>类型别名 :=> 文字
>relativeFilename : string
>类型别名 :=> 文字
>actualFilename : string
>类型别名 :=> 文字
>descriptionForDescribe : string
>类型别名 :=> 文字

            } else {
                describe(descriptionForDescribe, () => {
>describe(descriptionForDescribe, () => {                    var actual: string;                    it('Can generate the content without error', () => {                        actual = generateActual(actualFilename, generateContent);                    });                    it('Matches the baseline file', () => {                        var comparison = compareToBaseline(actual, relativeFilename, opts);                        writeComparison(comparison.expected, comparison.actual, relativeFilename, actualFilename, descriptionForDescribe);                    });                }) : void
>类型别名 :=> 无值
>describe : (description: string, block: () => any) => void
>descriptionForDescribe : string
>类型别名 :=> 文字
>() => {                    var actual: string;                    it('Can generate the content without error', () => {                        actual = generateActual(actualFilename, generateContent);                    });                    it('Matches the baseline file', () => {                        var comparison = compareToBaseline(actual, relativeFilename, opts);                        writeComparison(comparison.expected, comparison.actual, relativeFilename, actualFilename, descriptionForDescribe);                    });                } : () => void

                    var actual: string;
>actual : string
>类型别名 :=> 文字

                    it('Can generate the content without error', () => {
>it('Can generate the content without error', () => {                        actual = generateActual(actualFilename, generateContent);                    }) : void
>类型别名 :=> 无值
>it : (description: string, block: () => void) => void
>'Can generate the content without error' : "Can generate the content without error"
>() => {                        actual = generateActual(actualFilename, generateContent);                    } : () => void

                        actual = generateActual(actualFilename, generateContent);
>actual = generateActual(actualFilename, generateContent) : string
>类型别名 :=> 文字
>actual : string
>类型别名 :=> 文字
>generateActual(actualFilename, generateContent) : string
>类型别名 :=> 文字
>generateActual : (actualFilename: string, generateContent: () => string) => string
>actualFilename : string
>类型别名 :=> 文字
>generateContent : () => string

                    });

                    it('Matches the baseline file', () => {
>it('Matches the baseline file', () => {                        var comparison = compareToBaseline(actual, relativeFilename, opts);                        writeComparison(comparison.expected, comparison.actual, relativeFilename, actualFilename, descriptionForDescribe);                    }) : void
>类型别名 :=> 无值
>it : (description: string, block: () => void) => void
>'Matches the baseline file' : "Matches the baseline file"
>() => {                        var comparison = compareToBaseline(actual, relativeFilename, opts);                        writeComparison(comparison.expected, comparison.actual, relativeFilename, actualFilename, descriptionForDescribe);                    } : () => void

                        var comparison = compareToBaseline(actual, relativeFilename, opts);
>comparison : { expected: string; actual: string; }
>compareToBaseline(actual, relativeFilename, opts) : { expected: string; actual: string; }
>compareToBaseline : (actual: string, relativeFilename: string, opts: BaselineOptions) => { expected: string; actual: string; }
>actual : string
>类型别名 :=> 文字
>relativeFilename : string
>类型别名 :=> 文字
>opts : BaselineOptions

                        writeComparison(comparison.expected, comparison.actual, relativeFilename, actualFilename, descriptionForDescribe);
>writeComparison(comparison.expected, comparison.actual, relativeFilename, actualFilename, descriptionForDescribe) : void
>类型别名 :=> 无值
>writeComparison : (expected: string, actual: string, relativeFilename: string, actualFilename: string, descriptionForDescribe: string) => void
>comparison.expected : string
>类型别名 :=> 文字
>comparison : { expected: string; actual: string; }
>expected : string
>类型别名 :=> 文字
>comparison.actual : string
>类型别名 :=> 文字
>comparison : { expected: string; actual: string; }
>actual : string
>类型别名 :=> 文字
>relativeFilename : string
>类型别名 :=> 文字
>actualFilename : string
>类型别名 :=> 文字
>descriptionForDescribe : string
>类型别名 :=> 文字

                    });
                });
            }
        }
    }

    var currentRun = new Run();
>currentRun : Run
>new Run() : Run
>Run : typeof Run

    global.describe = describe;
>global.describe = describe : (description: string, block: () => any) => void
>global.describe : any
>类型别名 :=> 任意
>global : any
>类型别名 :=> 任意
>describe : any
>类型别名 :=> 任意
>describe : (description: string, block: () => any) => void

    global.run = run;
>global.run = run : () => void
>global.run : any
>类型别名 :=> 任意
>global : any
>类型别名 :=> 任意
>run : any
>类型别名 :=> 任意
>run : () => void

    global.it = it;
>global.it = it : (description: string, block: () => void) => void
>global.it : any
>类型别名 :=> 任意
>global : any
>类型别名 :=> 任意
>it : any
>类型别名 :=> 任意
>it : (description: string, block: () => void) => void

    global.assert = Harness.Assert;
>global.assert = Harness.Assert : typeof Assert
>global.assert : any
>类型别名 :=> 任意
>global : any
>类型别名 :=> 任意
>assert : any
>类型别名 :=> 任意
>Harness.Assert : typeof Assert
>Harness : typeof Harness
>Assert : typeof Assert
}

