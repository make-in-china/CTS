=== tests/cases/conformance/parser/ecmascript5/RealWorld/parserharness.ts ===
//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='..\compiler\io.ts'/>
///<reference path='..\compiler\typescript.ts'/>
///<reference path='..\services\typescriptServices.ts' />
///<reference path='diff.ts'/>

declare var assert: Harness.Assert;
>assert : 任意
>类型别名 :=> 任意
>Harness : 任意
>类型别名 :=> 任意
>Assert : No type information available!

declare var it;
>it : 任意
>类型别名 :=> 任意

declare var describe;
>describe : 任意
>类型别名 :=> 任意

declare var run;
>run : 任意
>类型别名 :=> 任意

declare var IO: IIO;
>IO : 任意
>类型别名 :=> 任意
>IIO : No type information available!

declare var __dirname; // Node-specific
>__dirname : 任意
>类型别名 :=> 任意

function switchToForwardSlashes(path: string) {
>switchToForwardSlashes : (path: 文字) => 文字
>path : 文字
>类型别名 :=> 文字

    return path.replace(/\\/g, "/");
>path.replace(/\\/g, "/") : 文字
>类型别名 :=> 文字
>path.replace : { (searchValue: 文字 | RegExp, replaceValue: 文字): 文字; (searchValue: 文字 | RegExp, replacer: (substring: 文字, ...args: 任意[]) => 文字): 文字; }
>path : 文字
>类型别名 :=> 文字
>replace : { (searchValue: 文字 | RegExp, replaceValue: 文字): 文字; (searchValue: 文字 | RegExp, replacer: (substring: 文字, ...args: 任意[]) => 文字): 文字; }
>/\\/g : RegExp
>"/" : "/"
}

function filePath(fullPath: string) {
>filePath : (fullPath: 文字) => 文字
>fullPath : 文字
>类型别名 :=> 文字

    fullPath = switchToForwardSlashes(fullPath);
>fullPath = switchToForwardSlashes(fullPath) : 文字
>类型别名 :=> 文字
>fullPath : 文字
>类型别名 :=> 文字
>switchToForwardSlashes(fullPath) : 文字
>类型别名 :=> 文字
>switchToForwardSlashes : (path: 文字) => 文字
>fullPath : 文字
>类型别名 :=> 文字

    var components = fullPath.split("/");
>components : 文字[]
>fullPath.split("/") : 文字[]
>fullPath.split : (separator: 文字 | RegExp, limit?: 数字) => 文字[]
>fullPath : 文字
>类型别名 :=> 文字
>split : (separator: 文字 | RegExp, limit?: 数字) => 文字[]
>"/" : "/"

    var path: string[] = components.slice(0, components.length - 1);
>path : 文字[]
>components.slice(0, components.length - 1) : 文字[]
>components.slice : (start?: 数字, end?: 数字) => 文字[]
>components : 文字[]
>slice : (start?: 数字, end?: 数字) => 文字[]
>0 : 0
>components.length - 1 : 数字
>类型别名 :=> 数字
>components.length : 数字
>类型别名 :=> 数字
>components : 文字[]
>length : 数字
>类型别名 :=> 数字
>1 : 1

    return path.join("/") + "/";
>path.join("/") + "/" : 文字
>类型别名 :=> 文字
>path.join("/") : 文字
>类型别名 :=> 文字
>path.join : (separator?: 文字) => 文字
>path : 文字[]
>join : (separator?: 文字) => 文字
>"/" : "/"
>"/" : "/"
}

var typescriptServiceFileName = filePath(IO.getExecutingFilePath()) + "typescriptServices.js";
>typescriptServiceFileName : 文字
>类型别名 :=> 文字
>filePath(IO.getExecutingFilePath()) + "typescriptServices.js" : 文字
>类型别名 :=> 文字
>filePath(IO.getExecutingFilePath()) : 文字
>类型别名 :=> 文字
>filePath : (fullPath: 文字) => 文字
>IO.getExecutingFilePath() : 任意
>类型别名 :=> 任意
>IO.getExecutingFilePath : 任意
>类型别名 :=> 任意
>IO : 任意
>类型别名 :=> 任意
>getExecutingFilePath : 任意
>类型别名 :=> 任意
>"typescriptServices.js" : "typescriptServices.js"

var typescriptServiceFile = IO.readFile(typescriptServiceFileName);
>typescriptServiceFile : 任意
>类型别名 :=> 任意
>IO.readFile(typescriptServiceFileName) : 任意
>类型别名 :=> 任意
>IO.readFile : 任意
>类型别名 :=> 任意
>IO : 任意
>类型别名 :=> 任意
>readFile : 任意
>类型别名 :=> 任意
>typescriptServiceFileName : 文字
>类型别名 :=> 文字

if (typeof ActiveXObject === "function") {
>typeof ActiveXObject === "function" : 真假
>类型别名 :=> 真假
>typeof ActiveXObject : "string" | "number" | "boolean" | "symbol" | "undefined" | "object" | "function" | "文字" | "数字" | "真假" | "符号" | "未定" | "对象" | "函数"
>ActiveXObject : 任意
>类型别名 :=> 任意
>"function" : "function"

    eval(typescriptServiceFile);
>eval(typescriptServiceFile) : 任意
>类型别名 :=> 任意
>eval : (x: 文字) => 任意
>typescriptServiceFile : 任意
>类型别名 :=> 任意

} else if (typeof require === "function") {
>typeof require === "function" : 真假
>类型别名 :=> 真假
>typeof require : "string" | "number" | "boolean" | "symbol" | "undefined" | "object" | "function" | "文字" | "数字" | "真假" | "符号" | "未定" | "对象" | "函数"
>require : 任意
>类型别名 :=> 任意
>"function" : "function"

    var vm = require('vm');
>vm : 任意
>类型别名 :=> 任意
>require('vm') : 任意
>类型别名 :=> 任意
>require : 任意
>类型别名 :=> 任意
>'vm' : "vm"

    vm.runInThisContext(typescriptServiceFile, 'typescriptServices.js');
>vm.runInThisContext(typescriptServiceFile, 'typescriptServices.js') : 任意
>类型别名 :=> 任意
>vm.runInThisContext : 任意
>类型别名 :=> 任意
>vm : 任意
>类型别名 :=> 任意
>runInThisContext : 任意
>类型别名 :=> 任意
>typescriptServiceFile : 任意
>类型别名 :=> 任意
>'typescriptServices.js' : "typescriptServices.js"

} else {
    throw new Error('Unknown context');
>new Error('Unknown context') : Error
>Error : ErrorConstructor
>'Unknown context' : "Unknown context"
}

declare module process {
>process : 类为 process

    export function nextTick(callback: () => any): void;
>nextTick : (callback: () => 任意) => 无值
>callback : () => 任意

    export function on(event: string, listener: Function);
>on : (event: 文字, listener: Function) => 任意
>event : 文字
>类型别名 :=> 文字
>listener : Function
>Function : Function
}

module Harness {
>Harness : 类为 Harness

    // Settings 
    export var userSpecifiedroot = "";
>userSpecifiedroot : 文字
>类型别名 :=> 文字
>"" : ""

    var global = <any>Function("return this").call(null);
>global : 任意
>类型别名 :=> 任意
><any>Function("return this").call(null) : 任意
>类型别名 :=> 任意
>Function("return this").call(null) : 任意
>类型别名 :=> 任意
>Function("return this").call : (this: Function, thisArg: 任意, ...argArray: 任意[]) => 任意
>Function("return this") : Function
>Function : FunctionConstructor
>"return this" : "return this"
>call : (this: Function, thisArg: 任意, ...argArray: 任意[]) => 任意
>null : 空值
>类型别名 :=> 空值

    export var usePull = false;
>usePull : 真假
>类型别名 :=> 真假
>false : 为假
>类型别名 :=> 为假

    export interface ITestMetadata {
>ITestMetadata : ITestMetadata

        id: string;
>id : 文字
>类型别名 :=> 文字

        desc: string;
>desc : 文字
>类型别名 :=> 文字

        pass: boolean;
>pass : 真假
>类型别名 :=> 真假

        perfResults: {
>perfResults : { mean: 数字; min: 数字; max: 数字; stdDev: 数字; trials: 数字[]; }

            mean: number;
>mean : 数字
>类型别名 :=> 数字

            min: number;
>min : 数字
>类型别名 :=> 数字

            max: number;
>max : 数字
>类型别名 :=> 数字

            stdDev: number;
>stdDev : 数字
>类型别名 :=> 数字

            trials: number[];
>trials : 数字[]

        };
    }
    export interface IScenarioMetadata {
>IScenarioMetadata : IScenarioMetadata

        id: string;
>id : 文字
>类型别名 :=> 文字

        desc: string;
>desc : 文字
>类型别名 :=> 文字

        pass: boolean;
>pass : 真假
>类型别名 :=> 真假

        bugs: string[];
>bugs : 文字[]
    }

    // Assert functions
    export module Assert {
>Assert : 类为 Assert

        export var bugIds: string[] = [];
>bugIds : 文字[]
>[] : 未定[]

        export var throwAssertError = (error: Error) => {
>throwAssertError : (error: Error) => 不及
>(error: Error) => {            throw error;        } : (error: Error) => 不及
>error : Error
>Error : Error

            throw error;
>error : Error

        };

        // Marks that the current scenario is impacted by a bug
        export function bug(id: string) {
>bug : (id: 文字) => 无值
>id : 文字
>类型别名 :=> 文字

            if (bugIds.indexOf(id) < 0) {
>bugIds.indexOf(id) < 0 : 真假
>类型别名 :=> 真假
>bugIds.indexOf(id) : 数字
>类型别名 :=> 数字
>bugIds.indexOf : (searchElement: 文字, fromIndex?: 数字) => 数字
>bugIds : 文字[]
>indexOf : (searchElement: 文字, fromIndex?: 数字) => 数字
>id : 文字
>类型别名 :=> 文字
>0 : 0

                bugIds.push(id);
>bugIds.push(id) : 数字
>类型别名 :=> 数字
>bugIds.push : (...items: 文字[]) => 数字
>bugIds : 文字[]
>push : (...items: 文字[]) => 数字
>id : 文字
>类型别名 :=> 文字
            }
        }

        // If there are any bugs in the test code, mark the scenario as impacted appropriately
        export function bugs(content: string) {
>bugs : (content: 文字) => 无值
>content : 文字
>类型别名 :=> 文字

            var bugs = content.match(/\bbug (\d+)/i);
>bugs : RegExpMatchArray
>content.match(/\bbug (\d+)/i) : RegExpMatchArray
>content.match : (regexp: 文字 | RegExp) => RegExpMatchArray
>content : 文字
>类型别名 :=> 文字
>match : (regexp: 文字 | RegExp) => RegExpMatchArray
>/\bbug (\d+)/i : RegExp

            if (bugs) {
>bugs : RegExpMatchArray

                bugs.forEach(bug => assert.bug(bug));
>bugs.forEach(bug => assert.bug(bug)) : 无值
>类型别名 :=> 无值
>bugs.forEach : (callbackfn: (value: 文字, index: 数字, array: 文字[]) => 无值, thisArg?: 任意) => 无值
>bugs : RegExpMatchArray
>forEach : (callbackfn: (value: 文字, index: 数字, array: 文字[]) => 无值, thisArg?: 任意) => 无值
>bug => assert.bug(bug) : (bug: 文字) => 任意
>bug : 文字
>类型别名 :=> 文字
>assert.bug(bug) : 任意
>类型别名 :=> 任意
>assert.bug : 任意
>类型别名 :=> 任意
>assert : 任意
>类型别名 :=> 任意
>bug : 任意
>类型别名 :=> 任意
>bug : 文字
>类型别名 :=> 文字
            }
        }

        export function is(result: boolean, msg?: string) {
>is : (result: 真假, msg?: 文字) => 无值
>result : 真假
>类型别名 :=> 真假
>msg : 文字
>类型别名 :=> 文字

            if (!result) {
>!result : 真假
>类型别名 :=> 真假
>result : 真假
>类型别名 :=> 真假

                throwAssertError(new Error(msg || "Expected true, got false."));
>throwAssertError(new Error(msg || "Expected true, got false.")) : 不及
>类型别名 :=> 不及
>throwAssertError : (error: Error) => 不及
>new Error(msg || "Expected true, got false.") : Error
>Error : ErrorConstructor
>msg || "Expected true, got false." : 文字
>类型别名 :=> 文字
>msg : 文字
>类型别名 :=> 文字
>"Expected true, got false." : "Expected true, got false."
            }
        }

        export function arrayLengthIs(arr: any[], length: number) {
>arrayLengthIs : (arr: 任意[], length: 数字) => 无值
>arr : 任意[]
>length : 数字
>类型别名 :=> 数字

            if (arr.length != length) {
>arr.length != length : 真假
>类型别名 :=> 真假
>arr.length : 数字
>类型别名 :=> 数字
>arr : 任意[]
>length : 数字
>类型别名 :=> 数字
>length : 数字
>类型别名 :=> 数字

                var actual = '';
>actual : 文字
>类型别名 :=> 文字
>'' : ""

                arr.forEach(n => actual = actual + '\n      ' + n.toString());
>arr.forEach(n => actual = actual + '\n      ' + n.toString()) : 无值
>类型别名 :=> 无值
>arr.forEach : (callbackfn: (value: 任意, index: 数字, array: 任意[]) => 无值, thisArg?: 任意) => 无值
>arr : 任意[]
>forEach : (callbackfn: (value: 任意, index: 数字, array: 任意[]) => 无值, thisArg?: 任意) => 无值
>n => actual = actual + '\n      ' + n.toString() : (n: 任意) => 文字
>n : 任意
>类型别名 :=> 任意
>actual = actual + '\n      ' + n.toString() : 文字
>类型别名 :=> 文字
>actual : 文字
>类型别名 :=> 文字
>actual + '\n      ' + n.toString() : 文字
>类型别名 :=> 文字
>actual + '\n      ' : 文字
>类型别名 :=> 文字
>actual : 文字
>类型别名 :=> 文字
>'\n      ' : "\n      "
>n.toString() : 任意
>类型别名 :=> 任意
>n.toString : 任意
>类型别名 :=> 任意
>n : 任意
>类型别名 :=> 任意
>toString : 任意
>类型别名 :=> 任意

                throwAssertError(new Error('Expected array to have ' + length + ' elements. Actual elements were:' + actual));
>throwAssertError(new Error('Expected array to have ' + length + ' elements. Actual elements were:' + actual)) : 不及
>类型别名 :=> 不及
>throwAssertError : (error: Error) => 不及
>new Error('Expected array to have ' + length + ' elements. Actual elements were:' + actual) : Error
>Error : ErrorConstructor
>'Expected array to have ' + length + ' elements. Actual elements were:' + actual : 文字
>类型别名 :=> 文字
>'Expected array to have ' + length + ' elements. Actual elements were:' : 文字
>类型别名 :=> 文字
>'Expected array to have ' + length : 文字
>类型别名 :=> 文字
>'Expected array to have ' : "Expected array to have "
>length : 数字
>类型别名 :=> 数字
>' elements. Actual elements were:' : " elements. Actual elements were:"
>actual : 文字
>类型别名 :=> 文字
            }
        }

        export function equal(actual, expected) {
>equal : (actual: 任意, expected: 任意) => 无值
>actual : 任意
>类型别名 :=> 任意
>expected : 任意
>类型别名 :=> 任意

            if (actual !== expected) {
>actual !== expected : 真假
>类型别名 :=> 真假
>actual : 任意
>类型别名 :=> 任意
>expected : 任意
>类型别名 :=> 任意

                throwAssertError(new Error("Expected " + actual + " to equal " + expected));
>throwAssertError(new Error("Expected " + actual + " to equal " + expected)) : 不及
>类型别名 :=> 不及
>throwAssertError : (error: Error) => 不及
>new Error("Expected " + actual + " to equal " + expected) : Error
>Error : ErrorConstructor
>"Expected " + actual + " to equal " + expected : 文字
>类型别名 :=> 文字
>"Expected " + actual + " to equal " : 文字
>类型别名 :=> 文字
>"Expected " + actual : 文字
>类型别名 :=> 文字
>"Expected " : "Expected "
>actual : 任意
>类型别名 :=> 任意
>" to equal " : " to equal "
>expected : 任意
>类型别名 :=> 任意
            }
        }

        export function notEqual(actual, expected) {
>notEqual : (actual: 任意, expected: 任意) => 无值
>actual : 任意
>类型别名 :=> 任意
>expected : 任意
>类型别名 :=> 任意

            if (actual === expected) {
>actual === expected : 真假
>类型别名 :=> 真假
>actual : 任意
>类型别名 :=> 任意
>expected : 任意
>类型别名 :=> 任意

                throwAssertError(new Error("Expected " + actual + " to *not* equal " + expected));
>throwAssertError(new Error("Expected " + actual + " to *not* equal " + expected)) : 不及
>类型别名 :=> 不及
>throwAssertError : (error: Error) => 不及
>new Error("Expected " + actual + " to *not* equal " + expected) : Error
>Error : ErrorConstructor
>"Expected " + actual + " to *not* equal " + expected : 文字
>类型别名 :=> 文字
>"Expected " + actual + " to *not* equal " : 文字
>类型别名 :=> 文字
>"Expected " + actual : 文字
>类型别名 :=> 文字
>"Expected " : "Expected "
>actual : 任意
>类型别名 :=> 任意
>" to *not* equal " : " to *not* equal "
>expected : 任意
>类型别名 :=> 任意
            }
        }

        export function notNull(result) {
>notNull : (result: 任意) => 无值
>result : 任意
>类型别名 :=> 任意

            if (result === null) {
>result === null : 真假
>类型别名 :=> 真假
>result : 任意
>类型别名 :=> 任意
>null : 空值
>类型别名 :=> 空值

                throwAssertError(new Error("Expected " + result + " to *not* be null"));
>throwAssertError(new Error("Expected " + result + " to *not* be null")) : 不及
>类型别名 :=> 不及
>throwAssertError : (error: Error) => 不及
>new Error("Expected " + result + " to *not* be null") : Error
>Error : ErrorConstructor
>"Expected " + result + " to *not* be null" : 文字
>类型别名 :=> 文字
>"Expected " + result : 文字
>类型别名 :=> 文字
>"Expected " : "Expected "
>result : 任意
>类型别名 :=> 任意
>" to *not* be null" : " to *not* be null"
            }
        }

        export function compilerWarning(result: Compiler.CompilerResult, line: number, column: number, desc: string) {
>compilerWarning : (result: Compiler.CompilerResult, line: 数字, column: 数字, desc: 文字) => 无值
>result : Compiler.CompilerResult
>Compiler : 任意
>类型别名 :=> 任意
>CompilerResult : Compiler.CompilerResult
>line : 数字
>类型别名 :=> 数字
>column : 数字
>类型别名 :=> 数字
>desc : 文字
>类型别名 :=> 文字

            if (!result.isErrorAt(line, column, desc)) {
>!result.isErrorAt(line, column, desc) : 真假
>类型别名 :=> 真假
>result.isErrorAt(line, column, desc) : 真假
>类型别名 :=> 真假
>result.isErrorAt : (line: 数字, column: 数字, message: 文字) => 真假
>result : Compiler.CompilerResult
>isErrorAt : (line: 数字, column: 数字, message: 文字) => 真假
>line : 数字
>类型别名 :=> 数字
>column : 数字
>类型别名 :=> 数字
>desc : 文字
>类型别名 :=> 文字

                var actual = '';
>actual : 文字
>类型别名 :=> 文字
>'' : ""

                result.errors.forEach(err => {
>result.errors.forEach(err => {                    actual = actual + '\n     ' + err.toString();                }) : 无值
>类型别名 :=> 无值
>result.errors.forEach : (callbackfn: (value: Compiler.CompilerError, index: 数字, array: Compiler.CompilerError[]) => 无值, thisArg?: 任意) => 无值
>result.errors : Compiler.CompilerError[]
>result : Compiler.CompilerResult
>errors : Compiler.CompilerError[]
>forEach : (callbackfn: (value: Compiler.CompilerError, index: 数字, array: Compiler.CompilerError[]) => 无值, thisArg?: 任意) => 无值
>err => {                    actual = actual + '\n     ' + err.toString();                } : (err: Compiler.CompilerError) => 无值
>err : Compiler.CompilerError

                    actual = actual + '\n     ' + err.toString();
>actual = actual + '\n     ' + err.toString() : 文字
>类型别名 :=> 文字
>actual : 文字
>类型别名 :=> 文字
>actual + '\n     ' + err.toString() : 文字
>类型别名 :=> 文字
>actual + '\n     ' : 文字
>类型别名 :=> 文字
>actual : 文字
>类型别名 :=> 文字
>'\n     ' : "\n     "
>err.toString() : 文字
>类型别名 :=> 文字
>err.toString : () => 文字
>err : Compiler.CompilerError
>toString : () => 文字

                });

                throwAssertError(new Error("Expected compiler warning at (" + line + ", " + column + "): " + desc + "\nActual errors follow: " + actual));
>throwAssertError(new Error("Expected compiler warning at (" + line + ", " + column + "): " + desc + "\nActual errors follow: " + actual)) : 不及
>类型别名 :=> 不及
>throwAssertError : (error: Error) => 不及
>new Error("Expected compiler warning at (" + line + ", " + column + "): " + desc + "\nActual errors follow: " + actual) : Error
>Error : ErrorConstructor
>"Expected compiler warning at (" + line + ", " + column + "): " + desc + "\nActual errors follow: " + actual : 文字
>类型别名 :=> 文字
>"Expected compiler warning at (" + line + ", " + column + "): " + desc + "\nActual errors follow: " : 文字
>类型别名 :=> 文字
>"Expected compiler warning at (" + line + ", " + column + "): " + desc : 文字
>类型别名 :=> 文字
>"Expected compiler warning at (" + line + ", " + column + "): " : 文字
>类型别名 :=> 文字
>"Expected compiler warning at (" + line + ", " + column : 文字
>类型别名 :=> 文字
>"Expected compiler warning at (" + line + ", " : 文字
>类型别名 :=> 文字
>"Expected compiler warning at (" + line : 文字
>类型别名 :=> 文字
>"Expected compiler warning at (" : "Expected compiler warning at ("
>line : 数字
>类型别名 :=> 数字
>", " : ", "
>column : 数字
>类型别名 :=> 数字
>"): " : "): "
>desc : 文字
>类型别名 :=> 文字
>"\nActual errors follow: " : "\nActual errors follow: "
>actual : 文字
>类型别名 :=> 文字
            }
        }

        export function noDiff(text1, text2) {
>noDiff : (text1: 任意, text2: 任意) => 无值
>text1 : 任意
>类型别名 :=> 任意
>text2 : 任意
>类型别名 :=> 任意

            text1 = text1.replace(/^\s+|\s+$/g, "").replace(/\r\n?/g, "\n");
>text1 = text1.replace(/^\s+|\s+$/g, "").replace(/\r\n?/g, "\n") : 任意
>类型别名 :=> 任意
>text1 : 任意
>类型别名 :=> 任意
>text1.replace(/^\s+|\s+$/g, "").replace(/\r\n?/g, "\n") : 任意
>类型别名 :=> 任意
>text1.replace(/^\s+|\s+$/g, "").replace : 任意
>类型别名 :=> 任意
>text1.replace(/^\s+|\s+$/g, "") : 任意
>类型别名 :=> 任意
>text1.replace : 任意
>类型别名 :=> 任意
>text1 : 任意
>类型别名 :=> 任意
>replace : 任意
>类型别名 :=> 任意
>/^\s+|\s+$/g : RegExp
>"" : ""
>replace : 任意
>类型别名 :=> 任意
>/\r\n?/g : RegExp
>"\n" : "\n"

            text2 = text2.replace(/^\s+|\s+$/g, "").replace(/\r\n?/g, "\n");
>text2 = text2.replace(/^\s+|\s+$/g, "").replace(/\r\n?/g, "\n") : 任意
>类型别名 :=> 任意
>text2 : 任意
>类型别名 :=> 任意
>text2.replace(/^\s+|\s+$/g, "").replace(/\r\n?/g, "\n") : 任意
>类型别名 :=> 任意
>text2.replace(/^\s+|\s+$/g, "").replace : 任意
>类型别名 :=> 任意
>text2.replace(/^\s+|\s+$/g, "") : 任意
>类型别名 :=> 任意
>text2.replace : 任意
>类型别名 :=> 任意
>text2 : 任意
>类型别名 :=> 任意
>replace : 任意
>类型别名 :=> 任意
>/^\s+|\s+$/g : RegExp
>"" : ""
>replace : 任意
>类型别名 :=> 任意
>/\r\n?/g : RegExp
>"\n" : "\n"

            if (text1 !== text2) {
>text1 !== text2 : 真假
>类型别名 :=> 真假
>text1 : 任意
>类型别名 :=> 任意
>text2 : 任意
>类型别名 :=> 任意

                var errorString = "";
>errorString : 文字
>类型别名 :=> 文字
>"" : ""

                var text1Lines = text1.split(/\n/);
>text1Lines : 任意
>类型别名 :=> 任意
>text1.split(/\n/) : 任意
>类型别名 :=> 任意
>text1.split : 任意
>类型别名 :=> 任意
>text1 : 任意
>类型别名 :=> 任意
>split : 任意
>类型别名 :=> 任意
>/\n/ : RegExp

                var text2Lines = text2.split(/\n/);
>text2Lines : 任意
>类型别名 :=> 任意
>text2.split(/\n/) : 任意
>类型别名 :=> 任意
>text2.split : 任意
>类型别名 :=> 任意
>text2 : 任意
>类型别名 :=> 任意
>split : 任意
>类型别名 :=> 任意
>/\n/ : RegExp

                for (var i = 0; i < text1Lines.length; i++) {
>i : 数字
>类型别名 :=> 数字
>0 : 0
>i < text1Lines.length : 真假
>类型别名 :=> 真假
>i : 数字
>类型别名 :=> 数字
>text1Lines.length : 任意
>类型别名 :=> 任意
>text1Lines : 任意
>类型别名 :=> 任意
>length : 任意
>类型别名 :=> 任意
>i++ : 数字
>类型别名 :=> 数字
>i : 数字
>类型别名 :=> 数字

                    if (text1Lines[i] !== text2Lines[i]) {
>text1Lines[i] !== text2Lines[i] : 真假
>类型别名 :=> 真假
>text1Lines[i] : 任意
>类型别名 :=> 任意
>text1Lines : 任意
>类型别名 :=> 任意
>i : 数字
>类型别名 :=> 数字
>text2Lines[i] : 任意
>类型别名 :=> 任意
>text2Lines : 任意
>类型别名 :=> 任意
>i : 数字
>类型别名 :=> 数字

                        errorString += "Difference at line " + (i + 1) + ":\n";
>errorString += "Difference at line " + (i + 1) + ":\n" : 文字
>类型别名 :=> 文字
>errorString : 文字
>类型别名 :=> 文字
>"Difference at line " + (i + 1) + ":\n" : 文字
>类型别名 :=> 文字
>"Difference at line " + (i + 1) : 文字
>类型别名 :=> 文字
>"Difference at line " : "Difference at line "
>(i + 1) : 数字
>类型别名 :=> 数字
>i + 1 : 数字
>类型别名 :=> 数字
>i : 数字
>类型别名 :=> 数字
>1 : 1
>":\n" : ":\n"

                        errorString += "                  Left File: " + text1Lines[i] + "\n";
>errorString += "                  Left File: " + text1Lines[i] + "\n" : 文字
>类型别名 :=> 文字
>errorString : 文字
>类型别名 :=> 文字
>"                  Left File: " + text1Lines[i] + "\n" : 文字
>类型别名 :=> 文字
>"                  Left File: " + text1Lines[i] : 文字
>类型别名 :=> 文字
>"                  Left File: " : "                  Left File: "
>text1Lines[i] : 任意
>类型别名 :=> 任意
>text1Lines : 任意
>类型别名 :=> 任意
>i : 数字
>类型别名 :=> 数字
>"\n" : "\n"

                        errorString += "                 Right File: " + text2Lines[i] + "\n\n";
>errorString += "                 Right File: " + text2Lines[i] + "\n\n" : 文字
>类型别名 :=> 文字
>errorString : 文字
>类型别名 :=> 文字
>"                 Right File: " + text2Lines[i] + "\n\n" : 文字
>类型别名 :=> 文字
>"                 Right File: " + text2Lines[i] : 文字
>类型别名 :=> 文字
>"                 Right File: " : "                 Right File: "
>text2Lines[i] : 任意
>类型别名 :=> 任意
>text2Lines : 任意
>类型别名 :=> 任意
>i : 数字
>类型别名 :=> 数字
>"\n\n" : "\n\n"
                    }
                }
                throwAssertError(new Error(errorString));
>throwAssertError(new Error(errorString)) : 不及
>类型别名 :=> 不及
>throwAssertError : (error: Error) => 不及
>new Error(errorString) : Error
>Error : ErrorConstructor
>errorString : 文字
>类型别名 :=> 文字
            }
        }

        export function arrayContains(arr: any[], contains: any[]) {
>arrayContains : (arr: 任意[], contains: 任意[]) => 无值
>arr : 任意[]
>contains : 任意[]

            var found;
>found : 任意
>类型别名 :=> 任意

            for (var i = 0; i < contains.length; i++) {
>i : 数字
>类型别名 :=> 数字
>0 : 0
>i < contains.length : 真假
>类型别名 :=> 真假
>i : 数字
>类型别名 :=> 数字
>contains.length : 数字
>类型别名 :=> 数字
>contains : 任意[]
>length : 数字
>类型别名 :=> 数字
>i++ : 数字
>类型别名 :=> 数字
>i : 数字
>类型别名 :=> 数字

                found = false;
>found = false : 为假
>类型别名 :=> 为假
>found : 任意
>类型别名 :=> 任意
>false : 为假
>类型别名 :=> 为假

                for (var j = 0; j < arr.length; j++) {
>j : 数字
>类型别名 :=> 数字
>0 : 0
>j < arr.length : 真假
>类型别名 :=> 真假
>j : 数字
>类型别名 :=> 数字
>arr.length : 数字
>类型别名 :=> 数字
>arr : 任意[]
>length : 数字
>类型别名 :=> 数字
>j++ : 数字
>类型别名 :=> 数字
>j : 数字
>类型别名 :=> 数字

                    if (arr[j] === contains[i]) {
>arr[j] === contains[i] : 真假
>类型别名 :=> 真假
>arr[j] : 任意
>类型别名 :=> 任意
>arr : 任意[]
>j : 数字
>类型别名 :=> 数字
>contains[i] : 任意
>类型别名 :=> 任意
>contains : 任意[]
>i : 数字
>类型别名 :=> 数字

                        found = true;
>found = true : 为真
>类型别名 :=> 为真
>found : 任意
>类型别名 :=> 任意
>true : 为真
>类型别名 :=> 为真

                        break;
                    }
                }

                if (!found) {
>!found : 真假
>类型别名 :=> 真假
>found : 任意
>类型别名 :=> 任意

                    throwAssertError(new Error("Expected array to contain \"" + contains[i] + "\""));
>throwAssertError(new Error("Expected array to contain \"" + contains[i] + "\"")) : 不及
>类型别名 :=> 不及
>throwAssertError : (error: Error) => 不及
>new Error("Expected array to contain \"" + contains[i] + "\"") : Error
>Error : ErrorConstructor
>"Expected array to contain \"" + contains[i] + "\"" : 文字
>类型别名 :=> 文字
>"Expected array to contain \"" + contains[i] : 文字
>类型别名 :=> 文字
>"Expected array to contain \"" : "Expected array to contain \""
>contains[i] : 任意
>类型别名 :=> 任意
>contains : 任意[]
>i : 数字
>类型别名 :=> 数字
>"\"" : "\""
                }
            }
        }

        export function arrayContainsOnce(arr: any[], filter: (item: any) => boolean) {
>arrayContainsOnce : (arr: 任意[], filter: (item: 任意) => 真假) => 无值
>arr : 任意[]
>filter : (item: 任意) => 真假
>item : 任意
>类型别名 :=> 任意

            var foundCount = 0;
>foundCount : 数字
>类型别名 :=> 数字
>0 : 0

            for (var i = 0; i < arr.length; i++) {
>i : 数字
>类型别名 :=> 数字
>0 : 0
>i < arr.length : 真假
>类型别名 :=> 真假
>i : 数字
>类型别名 :=> 数字
>arr.length : 数字
>类型别名 :=> 数字
>arr : 任意[]
>length : 数字
>类型别名 :=> 数字
>i++ : 数字
>类型别名 :=> 数字
>i : 数字
>类型别名 :=> 数字

                if (filter(arr[i])) {
>filter(arr[i]) : 真假
>类型别名 :=> 真假
>filter : (item: 任意) => 真假
>arr[i] : 任意
>类型别名 :=> 任意
>arr : 任意[]
>i : 数字
>类型别名 :=> 数字

                    foundCount++;
>foundCount++ : 数字
>类型别名 :=> 数字
>foundCount : 数字
>类型别名 :=> 数字
                }
            }

            if (foundCount !== 1) {
>foundCount !== 1 : 真假
>类型别名 :=> 真假
>foundCount : 数字
>类型别名 :=> 数字
>1 : 1

                throwAssertError(new Error("Expected array to match element only once (instead of " + foundCount + " times)"));
>throwAssertError(new Error("Expected array to match element only once (instead of " + foundCount + " times)")) : 不及
>类型别名 :=> 不及
>throwAssertError : (error: Error) => 不及
>new Error("Expected array to match element only once (instead of " + foundCount + " times)") : Error
>Error : ErrorConstructor
>"Expected array to match element only once (instead of " + foundCount + " times)" : 文字
>类型别名 :=> 文字
>"Expected array to match element only once (instead of " + foundCount : 文字
>类型别名 :=> 文字
>"Expected array to match element only once (instead of " : "Expected array to match element only once (instead of "
>foundCount : 数字
>类型别名 :=> 数字
>" times)" : " times)"
            }
        }
    }

    /** Splits the given string on \r\n or on only \n if that fails */
    export function splitContentByNewlines(content: string) {
>splitContentByNewlines : (content: 文字) => 文字[]
>content : 文字
>类型别名 :=> 文字

        // Split up the input file by line
        // Note: IE JS engine incorrectly handles consecutive delimiters here when using RegExp split, so
        // we have to string-based splitting instead and try to figure out the delimiting chars
        var lines = content.split('\r\n');
>lines : 文字[]
>content.split('\r\n') : 文字[]
>content.split : (separator: 文字 | RegExp, limit?: 数字) => 文字[]
>content : 文字
>类型别名 :=> 文字
>split : (separator: 文字 | RegExp, limit?: 数字) => 文字[]
>'\r\n' : "\r\n"

        if (lines.length === 1) {
>lines.length === 1 : 真假
>类型别名 :=> 真假
>lines.length : 数字
>类型别名 :=> 数字
>lines : 文字[]
>length : 数字
>类型别名 :=> 数字
>1 : 1

            lines = content.split('\n');
>lines = content.split('\n') : 文字[]
>lines : 文字[]
>content.split('\n') : 文字[]
>content.split : (separator: 文字 | RegExp, limit?: 数字) => 文字[]
>content : 文字
>类型别名 :=> 文字
>split : (separator: 文字 | RegExp, limit?: 数字) => 文字[]
>'\n' : "\n"
        }
        return lines;
>lines : 文字[]
    }

    /** Reads a file under /tests */
    export function readFile(path: string) {
>readFile : (path: 文字) => 任意
>path : 文字
>类型别名 :=> 文字

        if (path.indexOf('tests') < 0) {
>path.indexOf('tests') < 0 : 真假
>类型别名 :=> 真假
>path.indexOf('tests') : 数字
>类型别名 :=> 数字
>path.indexOf : (searchString: 文字, position?: 数字) => 数字
>path : 文字
>类型别名 :=> 文字
>indexOf : (searchString: 文字, position?: 数字) => 数字
>'tests' : "tests"
>0 : 0

            path = "tests/" + path;
>path = "tests/" + path : 文字
>类型别名 :=> 文字
>path : 文字
>类型别名 :=> 文字
>"tests/" + path : 文字
>类型别名 :=> 文字
>"tests/" : "tests/"
>path : 文字
>类型别名 :=> 文字
        }

        var content = IO.readFile(Harness.userSpecifiedroot + path);
>content : 任意
>类型别名 :=> 任意
>IO.readFile(Harness.userSpecifiedroot + path) : 任意
>类型别名 :=> 任意
>IO.readFile : 任意
>类型别名 :=> 任意
>IO : 任意
>类型别名 :=> 任意
>readFile : 任意
>类型别名 :=> 任意
>Harness.userSpecifiedroot + path : 文字
>类型别名 :=> 文字
>Harness.userSpecifiedroot : 文字
>类型别名 :=> 文字
>Harness : 类为 Harness
>userSpecifiedroot : 文字
>类型别名 :=> 文字
>path : 文字
>类型别名 :=> 文字

        if (content == null) {
>content == null : 真假
>类型别名 :=> 真假
>content : 任意
>类型别名 :=> 任意
>null : 空值
>类型别名 :=> 空值

            throw new Error("failed to read file at: '" + Harness.userSpecifiedroot + path + "'");
>new Error("failed to read file at: '" + Harness.userSpecifiedroot + path + "'") : Error
>Error : ErrorConstructor
>"failed to read file at: '" + Harness.userSpecifiedroot + path + "'" : 文字
>类型别名 :=> 文字
>"failed to read file at: '" + Harness.userSpecifiedroot + path : 文字
>类型别名 :=> 文字
>"failed to read file at: '" + Harness.userSpecifiedroot : 文字
>类型别名 :=> 文字
>"failed to read file at: '" : "failed to read file at: '"
>Harness.userSpecifiedroot : 文字
>类型别名 :=> 文字
>Harness : 类为 Harness
>userSpecifiedroot : 文字
>类型别名 :=> 文字
>path : 文字
>类型别名 :=> 文字
>"'" : "'"
        }

        return content;
>content : 任意
>类型别名 :=> 任意
    }

    // Logger
    export interface ILogger {
>ILogger : ILogger

        start: (fileName?: string, priority?: number) => void;
>start : (fileName?: 文字, priority?: 数字) => 无值
>fileName : 文字
>类型别名 :=> 文字
>priority : 数字
>类型别名 :=> 数字

        end: (fileName?: string) => void;
>end : (fileName?: 文字) => 无值
>fileName : 文字
>类型别名 :=> 文字

        scenarioStart: (scenario: IScenarioMetadata) => void;
>scenarioStart : (scenario: IScenarioMetadata) => 无值
>scenario : IScenarioMetadata
>IScenarioMetadata : IScenarioMetadata

        scenarioEnd: (scenario: IScenarioMetadata, error?: Error) => void;
>scenarioEnd : (scenario: IScenarioMetadata, error?: Error) => 无值
>scenario : IScenarioMetadata
>IScenarioMetadata : IScenarioMetadata
>error : Error
>Error : Error

        testStart: (test: ITestMetadata) => void;
>testStart : (test: ITestMetadata) => 无值
>test : ITestMetadata
>ITestMetadata : ITestMetadata

        pass: (test: ITestMetadata) => void;
>pass : (test: ITestMetadata) => 无值
>test : ITestMetadata
>ITestMetadata : ITestMetadata

        bug: (test: ITestMetadata) => void;
>bug : (test: ITestMetadata) => 无值
>test : ITestMetadata
>ITestMetadata : ITestMetadata

        fail: (test: ITestMetadata) => void;
>fail : (test: ITestMetadata) => 无值
>test : ITestMetadata
>ITestMetadata : ITestMetadata

        error: (test: ITestMetadata, error: Error) => void;
>error : (test: ITestMetadata, error: Error) => 无值
>test : ITestMetadata
>ITestMetadata : ITestMetadata
>error : Error
>Error : Error

        comment: (comment: string) => void;
>comment : (comment: 文字) => 无值
>comment : 文字
>类型别名 :=> 文字

        verify: (test: ITestMetadata, passed: boolean, actual: any, expected: any, message: string) => void;
>verify : (test: ITestMetadata, passed: 真假, actual: 任意, expected: 任意, message: 文字) => 无值
>test : ITestMetadata
>ITestMetadata : ITestMetadata
>passed : 真假
>类型别名 :=> 真假
>actual : 任意
>类型别名 :=> 任意
>expected : 任意
>类型别名 :=> 任意
>message : 文字
>类型别名 :=> 文字
    }

    export class Logger implements ILogger {
>Logger : Logger
>ILogger : ILogger

        public start(fileName?: string, priority?: number) { }
>start : (fileName?: 文字, priority?: 数字) => 无值
>fileName : 文字
>类型别名 :=> 文字
>priority : 数字
>类型别名 :=> 数字

        public end(fileName?: string) { }
>end : (fileName?: 文字) => 无值
>fileName : 文字
>类型别名 :=> 文字

        public scenarioStart(scenario: IScenarioMetadata) { }
>scenarioStart : (scenario: IScenarioMetadata) => 无值
>scenario : IScenarioMetadata
>IScenarioMetadata : IScenarioMetadata

        public scenarioEnd(scenario: IScenarioMetadata, error?: Error) { }
>scenarioEnd : (scenario: IScenarioMetadata, error?: Error) => 无值
>scenario : IScenarioMetadata
>IScenarioMetadata : IScenarioMetadata
>error : Error
>Error : Error

        public testStart(test: ITestMetadata) { }
>testStart : (test: ITestMetadata) => 无值
>test : ITestMetadata
>ITestMetadata : ITestMetadata

        public pass(test: ITestMetadata) { }
>pass : (test: ITestMetadata) => 无值
>test : ITestMetadata
>ITestMetadata : ITestMetadata

        public bug(test: ITestMetadata) { }
>bug : (test: ITestMetadata) => 无值
>test : ITestMetadata
>ITestMetadata : ITestMetadata

        public fail(test: ITestMetadata) { }
>fail : (test: ITestMetadata) => 无值
>test : ITestMetadata
>ITestMetadata : ITestMetadata

        public error(test: ITestMetadata, error: Error) { }
>error : (test: ITestMetadata, error: Error) => 无值
>test : ITestMetadata
>ITestMetadata : ITestMetadata
>error : Error
>Error : Error

        public comment(comment: string) { }
>comment : (comment: 文字) => 无值
>comment : 文字
>类型别名 :=> 文字

        public verify(test: ITestMetadata, passed: boolean, actual: any, expected: any, message: string) { }
>verify : (test: ITestMetadata, passed: 真假, actual: 任意, expected: 任意, message: 文字) => 无值
>test : ITestMetadata
>ITestMetadata : ITestMetadata
>passed : 真假
>类型别名 :=> 真假
>actual : 任意
>类型别名 :=> 任意
>expected : 任意
>类型别名 :=> 任意
>message : 文字
>类型别名 :=> 文字
    }

    // Logger-related functions
    var loggers: ILogger[] = [];
>loggers : ILogger[]
>ILogger : ILogger
>[] : 未定[]

    export function registerLogger(logger: ILogger) {
>registerLogger : (logger: ILogger) => 无值
>logger : ILogger
>ILogger : ILogger

        loggers.push(logger);
>loggers.push(logger) : 数字
>类型别名 :=> 数字
>loggers.push : (...items: ILogger[]) => 数字
>loggers : ILogger[]
>push : (...items: ILogger[]) => 数字
>logger : ILogger
    }
    export function emitLog(field: string, ...params: any[]) {
>emitLog : (field: 文字, ...params: 任意[]) => 无值
>field : 文字
>类型别名 :=> 文字
>params : 任意[]

        for (var i = 0; i < loggers.length; i++) {
>i : 数字
>类型别名 :=> 数字
>0 : 0
>i < loggers.length : 真假
>类型别名 :=> 真假
>i : 数字
>类型别名 :=> 数字
>loggers.length : 数字
>类型别名 :=> 数字
>loggers : ILogger[]
>length : 数字
>类型别名 :=> 数字
>i++ : 数字
>类型别名 :=> 数字
>i : 数字
>类型别名 :=> 数字

            if (typeof loggers[i][field] === 'function') {
>typeof loggers[i][field] === 'function' : 真假
>类型别名 :=> 真假
>typeof loggers[i][field] : "string" | "number" | "boolean" | "symbol" | "undefined" | "object" | "function" | "文字" | "数字" | "真假" | "符号" | "未定" | "对象" | "函数"
>loggers[i][field] : 任意
>类型别名 :=> 任意
>loggers[i] : ILogger
>loggers : ILogger[]
>i : 数字
>类型别名 :=> 数字
>field : 文字
>类型别名 :=> 文字
>'function' : "function"

                loggers[i][field].apply(loggers[i], params);
>loggers[i][field].apply(loggers[i], params) : 任意
>类型别名 :=> 任意
>loggers[i][field].apply : 任意
>类型别名 :=> 任意
>loggers[i][field] : 任意
>类型别名 :=> 任意
>loggers[i] : ILogger
>loggers : ILogger[]
>i : 数字
>类型别名 :=> 数字
>field : 文字
>类型别名 :=> 文字
>apply : 任意
>类型别名 :=> 任意
>loggers[i] : ILogger
>loggers : ILogger[]
>i : 数字
>类型别名 :=> 数字
>params : 任意[]
            }
        }
    }

    // BDD Framework
    export interface IDone {
>IDone : IDone

        (e?: Error): void;
>e : Error
>Error : Error
    }
    export class Runnable {
>Runnable : Runnable

        constructor(public description: string, public block: any) { }
>description : 文字
>类型别名 :=> 文字
>block : 任意
>类型别名 :=> 任意

        // The current stack of Runnable objects
        static currentStack: Runnable[] = [];
>currentStack : Runnable[]
>Runnable : Runnable
>[] : 未定[]

        // The error, if any, that occurred when running 'block'
        public error: Error = null;
>error : Error
>Error : Error
>null : 空值
>类型别名 :=> 空值

        // Whether or not this object has any failures (including in its descendants)
        public passed = null;
>passed : 任意
>类型别名 :=> 任意
>null : 空值
>类型别名 :=> 空值

        // A list of bugs impacting this object
        public bugs: string[] = [];
>bugs : 文字[]
>[] : 未定[]

        // A list of all our child Runnables
        public children: Runnable[] = [];
>children : Runnable[]
>Runnable : Runnable
>[] : 未定[]

        public addChild(child: Runnable): void {
>addChild : (child: Runnable) => 无值
>child : Runnable
>Runnable : Runnable

            this.children.push(child);
>this.children.push(child) : 数字
>类型别名 :=> 数字
>this.children.push : (...items: Runnable[]) => 数字
>this.children : Runnable[]
>this : 本体
>children : Runnable[]
>push : (...items: Runnable[]) => 数字
>child : Runnable
        }

        /** Call function fn, which may take a done function and may possibly execute
         *  asynchronously, calling done when finished. Returns true or false depending
         *  on whether the function was asynchronous or not.
         */
        public call(fn: (done?: IDone) => void , done: IDone) {
>call : (fn: (done?: IDone) => 无值, done: IDone) => 真假
>fn : (done?: IDone) => 无值
>done : IDone
>IDone : IDone
>done : IDone
>IDone : IDone

            var isAsync = true;
>isAsync : 真假
>类型别名 :=> 真假
>true : 为真
>类型别名 :=> 为真

            try {
                if (fn.length === 0) {
>fn.length === 0 : 真假
>类型别名 :=> 真假
>fn.length : 数字
>类型别名 :=> 数字
>fn : (done?: IDone) => 无值
>length : 数字
>类型别名 :=> 数字
>0 : 0

                    // No async.
                    fn();
>fn() : 无值
>类型别名 :=> 无值
>fn : (done?: IDone) => 无值

                    done();
>done() : 无值
>类型别名 :=> 无值
>done : IDone

                    return false;
>false : 为假
>类型别名 :=> 为假

                } else {
                    // Possibly async

                    Runnable.pushGlobalErrorHandler(done);
>Runnable.pushGlobalErrorHandler(done) : 无值
>类型别名 :=> 无值
>Runnable.pushGlobalErrorHandler : (done: IDone) => 无值
>Runnable : 类为 Runnable
>pushGlobalErrorHandler : (done: IDone) => 无值
>done : IDone

                    fn(function () {
>fn(function () {                        isAsync = false; // If we execute synchronously, this will get called before the return below.                        Runnable.popGlobalErrorHandler();                        done();                    }) : 无值
>类型别名 :=> 无值
>fn : (done?: IDone) => 无值
>function () {                        isAsync = false; // If we execute synchronously, this will get called before the return below.                        Runnable.popGlobalErrorHandler();                        done();                    } : () => 无值

                        isAsync = false; // If we execute synchronously, this will get called before the return below.
>isAsync = false : 为假
>类型别名 :=> 为假
>isAsync : 真假
>类型别名 :=> 真假
>false : 为假
>类型别名 :=> 为假

                        Runnable.popGlobalErrorHandler();
>Runnable.popGlobalErrorHandler() : 无值
>类型别名 :=> 无值
>Runnable.popGlobalErrorHandler : () => 无值
>Runnable : 类为 Runnable
>popGlobalErrorHandler : () => 无值

                        done();
>done() : 无值
>类型别名 :=> 无值
>done : IDone

                    });

                    return isAsync;
>isAsync : 为真
>类型别名 :=> 为真
                }

            } catch (e) {
>e : 任意
>类型别名 :=> 任意

                done(e);
>done(e) : 无值
>类型别名 :=> 无值
>done : IDone
>e : 任意
>类型别名 :=> 任意

                return false;
>false : 为假
>类型别名 :=> 为假
            }
        }

        public run(done: IDone) { }
>run : (done: IDone) => 无值
>done : IDone
>IDone : IDone

        public runBlock(done: IDone) {
>runBlock : (done: IDone) => 真假
>done : IDone
>IDone : IDone

            return this.call(this.block, done);
>this.call(this.block, done) : 真假
>类型别名 :=> 真假
>this.call : (fn: (done?: IDone) => 无值, done: IDone) => 真假
>this : 本体
>call : (fn: (done?: IDone) => 无值, done: IDone) => 真假
>this.block : 任意
>类型别名 :=> 任意
>this : 本体
>block : 任意
>类型别名 :=> 任意
>done : IDone
        }

        public runChild(index: number, done: IDone) {
>runChild : (index: 数字, done: IDone) => 真假
>index : 数字
>类型别名 :=> 数字
>done : IDone
>IDone : IDone

            return this.call(<any>((done) => this.children[index].run(done)), done);
>this.call(<any>((done) => this.children[index].run(done)), done) : 真假
>类型别名 :=> 真假
>this.call : (fn: (done?: IDone) => 无值, done: IDone) => 真假
>this : 本体
>call : (fn: (done?: IDone) => 无值, done: IDone) => 真假
><any>((done) => this.children[index].run(done)) : 任意
>类型别名 :=> 任意
>((done) => this.children[index].run(done)) : (done: 任意) => 无值
>(done) => this.children[index].run(done) : (done: 任意) => 无值
>done : 任意
>类型别名 :=> 任意
>this.children[index].run(done) : 无值
>类型别名 :=> 无值
>this.children[index].run : (done: IDone) => 无值
>this.children[index] : Runnable
>this.children : Runnable[]
>this : 本体
>children : Runnable[]
>index : 数字
>类型别名 :=> 数字
>run : (done: IDone) => 无值
>done : 任意
>类型别名 :=> 任意
>done : IDone
        }

        static errorHandlerStack: { (e: Error): void; }[] = [];
>errorHandlerStack : ((e: Error) => 无值)[]
>e : Error
>Error : Error
>[] : 未定[]

        static pushGlobalErrorHandler(done: IDone) {
>pushGlobalErrorHandler : (done: IDone) => 无值
>done : IDone
>IDone : IDone

            errorHandlerStack.push(function (e) {
>errorHandlerStack.push(function (e) {                done(e);            }) : 任意
>类型别名 :=> 任意
>errorHandlerStack.push : 任意
>类型别名 :=> 任意
>errorHandlerStack : 任意
>类型别名 :=> 任意
>push : 任意
>类型别名 :=> 任意
>function (e) {                done(e);            } : (e: 任意) => 无值
>e : 任意
>类型别名 :=> 任意

                done(e);
>done(e) : 无值
>类型别名 :=> 无值
>done : IDone
>e : 任意
>类型别名 :=> 任意

            });
        }

        static popGlobalErrorHandler() {
>popGlobalErrorHandler : () => 无值

            errorHandlerStack.pop();
>errorHandlerStack.pop() : 任意
>类型别名 :=> 任意
>errorHandlerStack.pop : 任意
>类型别名 :=> 任意
>errorHandlerStack : 任意
>类型别名 :=> 任意
>pop : 任意
>类型别名 :=> 任意
        }

        static handleError(e: Error) {
>handleError : (e: Error) => 无值
>e : Error
>Error : Error

            if (errorHandlerStack.length === 0) {
>errorHandlerStack.length === 0 : 真假
>类型别名 :=> 真假
>errorHandlerStack.length : 任意
>类型别名 :=> 任意
>errorHandlerStack : 任意
>类型别名 :=> 任意
>length : 任意
>类型别名 :=> 任意
>0 : 0

                IO.printLine('Global error: ' + e);
>IO.printLine('Global error: ' + e) : 任意
>类型别名 :=> 任意
>IO.printLine : 任意
>类型别名 :=> 任意
>IO : 任意
>类型别名 :=> 任意
>printLine : 任意
>类型别名 :=> 任意
>'Global error: ' + e : 文字
>类型别名 :=> 文字
>'Global error: ' : "Global error: "
>e : Error

            } else {
                errorHandlerStack[errorHandlerStack.length - 1](e);
>errorHandlerStack[errorHandlerStack.length - 1](e) : 任意
>类型别名 :=> 任意
>errorHandlerStack[errorHandlerStack.length - 1] : 任意
>类型别名 :=> 任意
>errorHandlerStack : 任意
>类型别名 :=> 任意
>errorHandlerStack.length - 1 : 数字
>类型别名 :=> 数字
>errorHandlerStack.length : 任意
>类型别名 :=> 任意
>errorHandlerStack : 任意
>类型别名 :=> 任意
>length : 任意
>类型别名 :=> 任意
>1 : 1
>e : Error
            }
        }
    }
    export class TestCase extends Runnable {
>TestCase : TestCase
>Runnable : Runnable

        public description: string;
>description : 文字
>类型别名 :=> 文字

        public block;
>block : 任意
>类型别名 :=> 任意

        constructor(description: string, block: any) {
>description : 文字
>类型别名 :=> 文字
>block : 任意
>类型别名 :=> 任意

            super(description, block);
>super(description, block) : 无值
>类型别名 :=> 无值
>super : 类为 Runnable
>description : 文字
>类型别名 :=> 文字
>block : 任意
>类型别名 :=> 任意

            this.description = description;
>this.description = description : 文字
>类型别名 :=> 文字
>this.description : 文字
>类型别名 :=> 文字
>this : 本体
>description : 文字
>类型别名 :=> 文字
>description : 文字
>类型别名 :=> 文字

            this.block = block;
>this.block = block : 任意
>类型别名 :=> 任意
>this.block : 任意
>类型别名 :=> 任意
>this : 本体
>block : 任意
>类型别名 :=> 任意
>block : 任意
>类型别名 :=> 任意
        }

        public addChild(child: Runnable): void {
>addChild : (child: Runnable) => 无值
>child : Runnable
>Runnable : Runnable

            throw new Error("Testcases may not be nested inside other testcases");
>new Error("Testcases may not be nested inside other testcases") : Error
>Error : ErrorConstructor
>"Testcases may not be nested inside other testcases" : "Testcases may not be nested inside other testcases"
        }

        /** Run the test case block and fail the test if it raised an error. If no error is raised, the test passes. */
        public run(done: IDone) {
>run : (done: IDone) => 无值
>done : IDone
>IDone : IDone

            var that = this;
>that : 本体
>this : 本体

            Runnable.currentStack.push(this);
>Runnable.currentStack.push(this) : 数字
>类型别名 :=> 数字
>Runnable.currentStack.push : (...items: Runnable[]) => 数字
>Runnable.currentStack : Runnable[]
>Runnable : 类为 Runnable
>currentStack : Runnable[]
>push : (...items: Runnable[]) => 数字
>this : 本体

            emitLog('testStart', { desc: this.description });
>emitLog('testStart', { desc: this.description }) : 无值
>类型别名 :=> 无值
>emitLog : (field: 文字, ...params: 任意[]) => 无值
>'testStart' : "testStart"
>{ desc: this.description } : { desc: 文字; }
>desc : 文字
>类型别名 :=> 文字
>this.description : 文字
>类型别名 :=> 文字
>this : 本体
>description : 文字
>类型别名 :=> 文字

            if (this.block) {
>this.block : 任意
>类型别名 :=> 任意
>this : 本体
>block : 任意
>类型别名 :=> 任意

                var async = this.runBlock(<any>function (e) {
>async : 真假
>类型别名 :=> 真假
>this.runBlock(<any>function (e) {                    if (e) {                        that.passed = false;                        that.error = e;                        emitLog('error', { desc: this.description, pass: false }, e);                    } else {                        that.passed = true;                        emitLog('pass', { desc: this.description, pass: true });                    }                    Runnable.currentStack.pop();                    done()                }) : 真假
>类型别名 :=> 真假
>this.runBlock : (done: IDone) => 真假
>this : 本体
>runBlock : (done: IDone) => 真假
><any>function (e) {                    if (e) {                        that.passed = false;                        that.error = e;                        emitLog('error', { desc: this.description, pass: false }, e);                    } else {                        that.passed = true;                        emitLog('pass', { desc: this.description, pass: true });                    }                    Runnable.currentStack.pop();                    done()                } : 任意
>类型别名 :=> 任意
>function (e) {                    if (e) {                        that.passed = false;                        that.error = e;                        emitLog('error', { desc: this.description, pass: false }, e);                    } else {                        that.passed = true;                        emitLog('pass', { desc: this.description, pass: true });                    }                    Runnable.currentStack.pop();                    done()                } : (e: 任意) => 无值
>e : 任意
>类型别名 :=> 任意

                    if (e) {
>e : 任意
>类型别名 :=> 任意

                        that.passed = false;
>that.passed = false : 为假
>类型别名 :=> 为假
>that.passed : 任意
>类型别名 :=> 任意
>that : 本体
>passed : 任意
>类型别名 :=> 任意
>false : 为假
>类型别名 :=> 为假

                        that.error = e;
>that.error = e : 任意
>类型别名 :=> 任意
>that.error : Error
>that : 本体
>error : Error
>e : 任意
>类型别名 :=> 任意

                        emitLog('error', { desc: this.description, pass: false }, e);
>emitLog('error', { desc: this.description, pass: false }, e) : 无值
>类型别名 :=> 无值
>emitLog : (field: 文字, ...params: 任意[]) => 无值
>'error' : "error"
>{ desc: this.description, pass: false } : { desc: 任意; pass: 真假; }
>desc : 任意
>类型别名 :=> 任意
>this.description : 任意
>类型别名 :=> 任意
>this : 任意
>类型别名 :=> 任意
>description : 任意
>类型别名 :=> 任意
>pass : 真假
>类型别名 :=> 真假
>false : 为假
>类型别名 :=> 为假
>e : 任意
>类型别名 :=> 任意

                    } else {
                        that.passed = true;
>that.passed = true : 为真
>类型别名 :=> 为真
>that.passed : 任意
>类型别名 :=> 任意
>that : 本体
>passed : 任意
>类型别名 :=> 任意
>true : 为真
>类型别名 :=> 为真

                        emitLog('pass', { desc: this.description, pass: true });
>emitLog('pass', { desc: this.description, pass: true }) : 无值
>类型别名 :=> 无值
>emitLog : (field: 文字, ...params: 任意[]) => 无值
>'pass' : "pass"
>{ desc: this.description, pass: true } : { desc: 任意; pass: 真假; }
>desc : 任意
>类型别名 :=> 任意
>this.description : 任意
>类型别名 :=> 任意
>this : 任意
>类型别名 :=> 任意
>description : 任意
>类型别名 :=> 任意
>pass : 真假
>类型别名 :=> 真假
>true : 为真
>类型别名 :=> 为真
                    }

                    Runnable.currentStack.pop();
>Runnable.currentStack.pop() : Runnable
>Runnable.currentStack.pop : () => Runnable
>Runnable.currentStack : Runnable[]
>Runnable : 类为 Runnable
>currentStack : Runnable[]
>pop : () => Runnable

                    done()
>done() : 无值
>类型别名 :=> 无值
>done : IDone

                });
            }

        }
    }

    export class Scenario extends Runnable {
>Scenario : Scenario
>Runnable : Runnable

        public description: string;
>description : 文字
>类型别名 :=> 文字

        public block;
>block : 任意
>类型别名 :=> 任意

        constructor(description: string, block: any) {
>description : 文字
>类型别名 :=> 文字
>block : 任意
>类型别名 :=> 任意

            super(description, block);
>super(description, block) : 无值
>类型别名 :=> 无值
>super : 类为 Runnable
>description : 文字
>类型别名 :=> 文字
>block : 任意
>类型别名 :=> 任意

            this.description = description;
>this.description = description : 文字
>类型别名 :=> 文字
>this.description : 文字
>类型别名 :=> 文字
>this : 本体
>description : 文字
>类型别名 :=> 文字
>description : 文字
>类型别名 :=> 文字

            this.block = block;
>this.block = block : 任意
>类型别名 :=> 任意
>this.block : 任意
>类型别名 :=> 任意
>this : 本体
>block : 任意
>类型别名 :=> 任意
>block : 任意
>类型别名 :=> 任意
        }

        /** Run the block, and if the block doesn't raise an error, run the children. */
        public run(done: IDone) {
>run : (done: IDone) => 无值
>done : IDone
>IDone : IDone

            var that = this;
>that : 本体
>this : 本体

            Runnable.currentStack.push(this);
>Runnable.currentStack.push(this) : 数字
>类型别名 :=> 数字
>Runnable.currentStack.push : (...items: Runnable[]) => 数字
>Runnable.currentStack : Runnable[]
>Runnable : 类为 Runnable
>currentStack : Runnable[]
>push : (...items: Runnable[]) => 数字
>this : 本体

            emitLog('scenarioStart', { desc: this.description });
>emitLog('scenarioStart', { desc: this.description }) : 无值
>类型别名 :=> 无值
>emitLog : (field: 文字, ...params: 任意[]) => 无值
>'scenarioStart' : "scenarioStart"
>{ desc: this.description } : { desc: 文字; }
>desc : 文字
>类型别名 :=> 文字
>this.description : 文字
>类型别名 :=> 文字
>this : 本体
>description : 文字
>类型别名 :=> 文字

            var async = this.runBlock(<any>function (e) {
>async : 真假
>类型别名 :=> 真假
>this.runBlock(<any>function (e) {                Runnable.currentStack.pop();                if (e) {                    that.passed = false;                    that.error = e;                    var metadata: IScenarioMetadata = { id: undefined, desc: this.description, pass: false, bugs: assert.bugIds };                    // Report all bugs affecting this scenario                    assert.bugIds.forEach(desc => emitLog('bug', metadata, desc));                    emitLog('scenarioEnd', metadata, e);                    done();                } else {                    that.passed = true; // so far so good.                    that.runChildren(done);                }            }) : 真假
>类型别名 :=> 真假
>this.runBlock : (done: IDone) => 真假
>this : 本体
>runBlock : (done: IDone) => 真假
><any>function (e) {                Runnable.currentStack.pop();                if (e) {                    that.passed = false;                    that.error = e;                    var metadata: IScenarioMetadata = { id: undefined, desc: this.description, pass: false, bugs: assert.bugIds };                    // Report all bugs affecting this scenario                    assert.bugIds.forEach(desc => emitLog('bug', metadata, desc));                    emitLog('scenarioEnd', metadata, e);                    done();                } else {                    that.passed = true; // so far so good.                    that.runChildren(done);                }            } : 任意
>类型别名 :=> 任意
>function (e) {                Runnable.currentStack.pop();                if (e) {                    that.passed = false;                    that.error = e;                    var metadata: IScenarioMetadata = { id: undefined, desc: this.description, pass: false, bugs: assert.bugIds };                    // Report all bugs affecting this scenario                    assert.bugIds.forEach(desc => emitLog('bug', metadata, desc));                    emitLog('scenarioEnd', metadata, e);                    done();                } else {                    that.passed = true; // so far so good.                    that.runChildren(done);                }            } : (e: 任意) => 无值
>e : 任意
>类型别名 :=> 任意

                Runnable.currentStack.pop();
>Runnable.currentStack.pop() : Runnable
>Runnable.currentStack.pop : () => Runnable
>Runnable.currentStack : Runnable[]
>Runnable : 类为 Runnable
>currentStack : Runnable[]
>pop : () => Runnable

                if (e) {
>e : 任意
>类型别名 :=> 任意

                    that.passed = false;
>that.passed = false : 为假
>类型别名 :=> 为假
>that.passed : 任意
>类型别名 :=> 任意
>that : 本体
>passed : 任意
>类型别名 :=> 任意
>false : 为假
>类型别名 :=> 为假

                    that.error = e;
>that.error = e : 任意
>类型别名 :=> 任意
>that.error : Error
>that : 本体
>error : Error
>e : 任意
>类型别名 :=> 任意

                    var metadata: IScenarioMetadata = { id: undefined, desc: this.description, pass: false, bugs: assert.bugIds };
>metadata : IScenarioMetadata
>IScenarioMetadata : IScenarioMetadata
>{ id: undefined, desc: this.description, pass: false, bugs: assert.bugIds } : { id: 未定; desc: 任意; pass: 为假; bugs: 任意; }
>id : 未定
>类型别名 :=> 未定
>undefined : 未定
>类型别名 :=> 未定
>desc : 任意
>类型别名 :=> 任意
>this.description : 任意
>类型别名 :=> 任意
>this : 任意
>类型别名 :=> 任意
>description : 任意
>类型别名 :=> 任意
>pass : 真假
>类型别名 :=> 真假
>false : 为假
>类型别名 :=> 为假
>bugs : 任意
>类型别名 :=> 任意
>assert.bugIds : 任意
>类型别名 :=> 任意
>assert : 任意
>类型别名 :=> 任意
>bugIds : 任意
>类型别名 :=> 任意

                    // Report all bugs affecting this scenario
                    assert.bugIds.forEach(desc => emitLog('bug', metadata, desc));
>assert.bugIds.forEach(desc => emitLog('bug', metadata, desc)) : 任意
>类型别名 :=> 任意
>assert.bugIds.forEach : 任意
>类型别名 :=> 任意
>assert.bugIds : 任意
>类型别名 :=> 任意
>assert : 任意
>类型别名 :=> 任意
>bugIds : 任意
>类型别名 :=> 任意
>forEach : 任意
>类型别名 :=> 任意
>desc => emitLog('bug', metadata, desc) : (desc: 任意) => 无值
>desc : 任意
>类型别名 :=> 任意
>emitLog('bug', metadata, desc) : 无值
>类型别名 :=> 无值
>emitLog : (field: 文字, ...params: 任意[]) => 无值
>'bug' : "bug"
>metadata : IScenarioMetadata
>desc : 任意
>类型别名 :=> 任意

                    emitLog('scenarioEnd', metadata, e);
>emitLog('scenarioEnd', metadata, e) : 无值
>类型别名 :=> 无值
>emitLog : (field: 文字, ...params: 任意[]) => 无值
>'scenarioEnd' : "scenarioEnd"
>metadata : IScenarioMetadata
>e : 任意
>类型别名 :=> 任意

                    done();
>done() : 无值
>类型别名 :=> 无值
>done : IDone

                } else {
                    that.passed = true; // so far so good.
>that.passed = true : 为真
>类型别名 :=> 为真
>that.passed : 任意
>类型别名 :=> 任意
>that : 本体
>passed : 任意
>类型别名 :=> 任意
>true : 为真
>类型别名 :=> 为真

                    that.runChildren(done);
>that.runChildren(done) : 无值
>类型别名 :=> 无值
>that.runChildren : (done: IDone, index?: 数字) => 无值
>that : 本体
>runChildren : (done: IDone, index?: 数字) => 无值
>done : IDone
                }
            });
        }

        /** Run the children of the scenario (other scenarios and test cases). If any fail,
         *  set this scenario to failed. Synchronous tests will run synchronously without
         *  adding stack frames.
         */
        public runChildren(done: IDone, index = 0) {
>runChildren : (done: IDone, index?: 数字) => 无值
>done : IDone
>IDone : IDone
>index : 数字
>类型别名 :=> 数字
>0 : 0

            var that = this;
>that : 本体
>this : 本体

            var async = false;
>async : 真假
>类型别名 :=> 真假
>false : 为假
>类型别名 :=> 为假

            for (; index < this.children.length; index++) {
>index < this.children.length : 真假
>类型别名 :=> 真假
>index : 数字
>类型别名 :=> 数字
>this.children.length : 数字
>类型别名 :=> 数字
>this.children : Runnable[]
>this : 本体
>children : Runnable[]
>length : 数字
>类型别名 :=> 数字
>index++ : 数字
>类型别名 :=> 数字
>index : 数字
>类型别名 :=> 数字

                async = this.runChild(index, <any>function (e) {
>async = this.runChild(index, <any>function (e) {                    that.passed = that.passed && that.children[index].passed;                    if (async)                        that.runChildren(done, index + 1);                }) : 真假
>类型别名 :=> 真假
>async : 真假
>类型别名 :=> 真假
>this.runChild(index, <any>function (e) {                    that.passed = that.passed && that.children[index].passed;                    if (async)                        that.runChildren(done, index + 1);                }) : 真假
>类型别名 :=> 真假
>this.runChild : (index: 数字, done: IDone) => 真假
>this : 本体
>runChild : (index: 数字, done: IDone) => 真假
>index : 数字
>类型别名 :=> 数字
><any>function (e) {                    that.passed = that.passed && that.children[index].passed;                    if (async)                        that.runChildren(done, index + 1);                } : 任意
>类型别名 :=> 任意
>function (e) {                    that.passed = that.passed && that.children[index].passed;                    if (async)                        that.runChildren(done, index + 1);                } : (e: 任意) => 无值
>e : 任意
>类型别名 :=> 任意

                    that.passed = that.passed && that.children[index].passed;
>that.passed = that.passed && that.children[index].passed : 任意
>类型别名 :=> 任意
>that.passed : 任意
>类型别名 :=> 任意
>that : 本体
>passed : 任意
>类型别名 :=> 任意
>that.passed && that.children[index].passed : 任意
>类型别名 :=> 任意
>that.passed : 任意
>类型别名 :=> 任意
>that : 本体
>passed : 任意
>类型别名 :=> 任意
>that.children[index].passed : 任意
>类型别名 :=> 任意
>that.children[index] : Runnable
>that.children : Runnable[]
>that : 本体
>children : Runnable[]
>index : 数字
>类型别名 :=> 数字
>passed : 任意
>类型别名 :=> 任意

                    if (async)
>async : 真假
>类型别名 :=> 真假

                        that.runChildren(done, index + 1);
>that.runChildren(done, index + 1) : 无值
>类型别名 :=> 无值
>that.runChildren : (done: IDone, index?: 数字) => 无值
>that : 本体
>runChildren : (done: IDone, index?: 数字) => 无值
>done : IDone
>index + 1 : 数字
>类型别名 :=> 数字
>index : 数字
>类型别名 :=> 数字
>1 : 1

                });

                if (async)
>async : 真假
>类型别名 :=> 真假

                    return;
            }

            var metadata: IScenarioMetadata = { id: undefined, desc: this.description, pass: this.passed, bugs: assert.bugIds };
>metadata : IScenarioMetadata
>IScenarioMetadata : IScenarioMetadata
>{ id: undefined, desc: this.description, pass: this.passed, bugs: assert.bugIds } : { id: 未定; desc: 文字; pass: 任意; bugs: 任意; }
>id : 未定
>类型别名 :=> 未定
>undefined : 未定
>类型别名 :=> 未定
>desc : 文字
>类型别名 :=> 文字
>this.description : 文字
>类型别名 :=> 文字
>this : 本体
>description : 文字
>类型别名 :=> 文字
>pass : 任意
>类型别名 :=> 任意
>this.passed : 任意
>类型别名 :=> 任意
>this : 本体
>passed : 任意
>类型别名 :=> 任意
>bugs : 任意
>类型别名 :=> 任意
>assert.bugIds : 任意
>类型别名 :=> 任意
>assert : 任意
>类型别名 :=> 任意
>bugIds : 任意
>类型别名 :=> 任意

            // Report all bugs affecting this scenario
            assert.bugIds.forEach(desc => emitLog('bug', metadata, desc));
>assert.bugIds.forEach(desc => emitLog('bug', metadata, desc)) : 任意
>类型别名 :=> 任意
>assert.bugIds.forEach : 任意
>类型别名 :=> 任意
>assert.bugIds : 任意
>类型别名 :=> 任意
>assert : 任意
>类型别名 :=> 任意
>bugIds : 任意
>类型别名 :=> 任意
>forEach : 任意
>类型别名 :=> 任意
>desc => emitLog('bug', metadata, desc) : (desc: 任意) => 无值
>desc : 任意
>类型别名 :=> 任意
>emitLog('bug', metadata, desc) : 无值
>类型别名 :=> 无值
>emitLog : (field: 文字, ...params: 任意[]) => 无值
>'bug' : "bug"
>metadata : IScenarioMetadata
>desc : 任意
>类型别名 :=> 任意

            emitLog('scenarioEnd', metadata);
>emitLog('scenarioEnd', metadata) : 无值
>类型别名 :=> 无值
>emitLog : (field: 文字, ...params: 任意[]) => 无值
>'scenarioEnd' : "scenarioEnd"
>metadata : IScenarioMetadata

            done();
>done() : 无值
>类型别名 :=> 无值
>done : IDone
        }
    }
    export class Run extends Runnable {
>Run : Run
>Runnable : Runnable

        constructor() {
            super('Test Run', null);
>super('Test Run', null) : 无值
>类型别名 :=> 无值
>super : 类为 Runnable
>'Test Run' : "Test Run"
>null : 空值
>类型别名 :=> 空值
        }

        public run() {
>run : () => 无值

            emitLog('start');
>emitLog('start') : 无值
>类型别名 :=> 无值
>emitLog : (field: 文字, ...params: 任意[]) => 无值
>'start' : "start"

            this.runChildren();
>this.runChildren() : 无值
>类型别名 :=> 无值
>this.runChildren : (index?: 数字) => 无值
>this : 本体
>runChildren : (index?: 数字) => 无值
        }

        public runChildren(index = 0) {
>runChildren : (index?: 数字) => 无值
>index : 数字
>类型别名 :=> 数字
>0 : 0

            var async = false;
>async : 真假
>类型别名 :=> 真假
>false : 为假
>类型别名 :=> 为假

            var that = this;
>that : 本体
>this : 本体

            for (; index < this.children.length; index++) {
>index < this.children.length : 真假
>类型别名 :=> 真假
>index : 数字
>类型别名 :=> 数字
>this.children.length : 数字
>类型别名 :=> 数字
>this.children : Runnable[]
>this : 本体
>children : Runnable[]
>length : 数字
>类型别名 :=> 数字
>index++ : 数字
>类型别名 :=> 数字
>index : 数字
>类型别名 :=> 数字

                // Clear out bug descriptions
                assert.bugIds = [];
>assert.bugIds = [] : 未定[]
>assert.bugIds : 任意
>类型别名 :=> 任意
>assert : 任意
>类型别名 :=> 任意
>bugIds : 任意
>类型别名 :=> 任意
>[] : 未定[]

                async = this.runChild(index, <any>function (e) {
>async = this.runChild(index, <any>function (e) {                    if (async) {                        that.runChildren(index + 1);                    }                }) : 真假
>类型别名 :=> 真假
>async : 真假
>类型别名 :=> 真假
>this.runChild(index, <any>function (e) {                    if (async) {                        that.runChildren(index + 1);                    }                }) : 真假
>类型别名 :=> 真假
>this.runChild : (index: 数字, done: IDone) => 真假
>this : 本体
>runChild : (index: 数字, done: IDone) => 真假
>index : 数字
>类型别名 :=> 数字
><any>function (e) {                    if (async) {                        that.runChildren(index + 1);                    }                } : 任意
>类型别名 :=> 任意
>function (e) {                    if (async) {                        that.runChildren(index + 1);                    }                } : (e: 任意) => 无值
>e : 任意
>类型别名 :=> 任意

                    if (async) {
>async : 真假
>类型别名 :=> 真假

                        that.runChildren(index + 1);
>that.runChildren(index + 1) : 无值
>类型别名 :=> 无值
>that.runChildren : (index?: 数字) => 无值
>that : 本体
>runChildren : (index?: 数字) => 无值
>index + 1 : 数字
>类型别名 :=> 数字
>index : 数字
>类型别名 :=> 数字
>1 : 1
                    }
                });

                if (async) {
>async : 真假
>类型别名 :=> 真假

                    return;
                }
            }

            Perf.runBenchmarks();
>Perf.runBenchmarks() : 无值
>类型别名 :=> 无值
>Perf.runBenchmarks : () => 无值
>Perf : 类为 Perf
>runBenchmarks : () => 无值

            emitLog('end');
>emitLog('end') : 无值
>类型别名 :=> 无值
>emitLog : (field: 文字, ...params: 任意[]) => 无值
>'end' : "end"
        }
    }

    // Performance test
    export module Perf {
>Perf : 类为 Perf

        export module Clock {
>Clock : 类为 Clock

            export var now: () => number;
>now : () => 数字

            export var resolution: number;
>resolution : 数字
>类型别名 :=> 数字

            declare module WScript {
>WScript : 类为 WScript

                export function InitializeProjection();
>InitializeProjection : () => 任意
            }

            declare module TestUtilities {
>TestUtilities : 类为 TestUtilities

                export function QueryPerformanceCounter(): number;
>QueryPerformanceCounter : () => 数字

                export function QueryPerformanceFrequency(): number;
>QueryPerformanceFrequency : () => 数字
            }

            if (typeof WScript !== "undefined" && typeof global['WScript'].InitializeProjection !== "undefined") {
>typeof WScript !== "undefined" && typeof global['WScript'].InitializeProjection !== "undefined" : 真假
>类型别名 :=> 真假
>typeof WScript !== "undefined" : 真假
>类型别名 :=> 真假
>typeof WScript : "string" | "number" | "boolean" | "symbol" | "undefined" | "object" | "function" | "文字" | "数字" | "真假" | "符号" | "未定" | "对象" | "函数"
>WScript : 类为 WScript
>"undefined" : "undefined"
>typeof global['WScript'].InitializeProjection !== "undefined" : 真假
>类型别名 :=> 真假
>typeof global['WScript'].InitializeProjection : "string" | "number" | "boolean" | "symbol" | "undefined" | "object" | "function" | "文字" | "数字" | "真假" | "符号" | "未定" | "对象" | "函数"
>global['WScript'].InitializeProjection : 任意
>类型别名 :=> 任意
>global['WScript'] : 任意
>类型别名 :=> 任意
>global : 任意
>类型别名 :=> 任意
>'WScript' : "WScript"
>InitializeProjection : 任意
>类型别名 :=> 任意
>"undefined" : "undefined"

                // Running in JSHost.
                global['WScript'].InitializeProjection();
>global['WScript'].InitializeProjection() : 任意
>类型别名 :=> 任意
>global['WScript'].InitializeProjection : 任意
>类型别名 :=> 任意
>global['WScript'] : 任意
>类型别名 :=> 任意
>global : 任意
>类型别名 :=> 任意
>'WScript' : "WScript"
>InitializeProjection : 任意
>类型别名 :=> 任意

                now = function () {
>now = function () {                    return TestUtilities.QueryPerformanceCounter();                } : () => 数字
>now : () => 数字
>function () {                    return TestUtilities.QueryPerformanceCounter();                } : () => 数字

                    return TestUtilities.QueryPerformanceCounter();
>TestUtilities.QueryPerformanceCounter() : 数字
>类型别名 :=> 数字
>TestUtilities.QueryPerformanceCounter : () => 数字
>TestUtilities : 类为 TestUtilities
>QueryPerformanceCounter : () => 数字
                }

                resolution = TestUtilities.QueryPerformanceFrequency();
>resolution = TestUtilities.QueryPerformanceFrequency() : 数字
>类型别名 :=> 数字
>resolution : 数字
>类型别名 :=> 数字
>TestUtilities.QueryPerformanceFrequency() : 数字
>类型别名 :=> 数字
>TestUtilities.QueryPerformanceFrequency : () => 数字
>TestUtilities : 类为 TestUtilities
>QueryPerformanceFrequency : () => 数字

            } else {
                now = function () {
>now = function () {                    return Date.now();                } : () => 数字
>now : () => 数字
>function () {                    return Date.now();                } : () => 数字

                    return Date.now();
>Date.now() : 数字
>类型别名 :=> 数字
>Date.now : () => 数字
>Date : DateConstructor
>now : () => 数字
                }

                resolution = 1000;
>resolution = 1000 : 1000
>resolution : 数字
>类型别名 :=> 数字
>1000 : 1000
            }
        }

        export class Timer {
>Timer : Timer

            public startTime;
>startTime : 任意
>类型别名 :=> 任意

            public time = 0;
>time : 数字
>类型别名 :=> 数字
>0 : 0

            public start() {
>start : () => 无值

                this.time = 0;
>this.time = 0 : 0
>this.time : 数字
>类型别名 :=> 数字
>this : 本体
>time : 数字
>类型别名 :=> 数字
>0 : 0

                this.startTime = Clock.now();
>this.startTime = Clock.now() : 数字
>类型别名 :=> 数字
>this.startTime : 任意
>类型别名 :=> 任意
>this : 本体
>startTime : 任意
>类型别名 :=> 任意
>Clock.now() : 数字
>类型别名 :=> 数字
>Clock.now : () => 数字
>Clock : 类为 Clock
>now : () => 数字
            }

            public end() {
>end : () => 无值

                // Set time to MS.
                this.time = (Clock.now() - this.startTime) / Clock.resolution * 1000;
>this.time = (Clock.now() - this.startTime) / Clock.resolution * 1000 : 数字
>类型别名 :=> 数字
>this.time : 数字
>类型别名 :=> 数字
>this : 本体
>time : 数字
>类型别名 :=> 数字
>(Clock.now() - this.startTime) / Clock.resolution * 1000 : 数字
>类型别名 :=> 数字
>(Clock.now() - this.startTime) / Clock.resolution : 数字
>类型别名 :=> 数字
>(Clock.now() - this.startTime) : 数字
>类型别名 :=> 数字
>Clock.now() - this.startTime : 数字
>类型别名 :=> 数字
>Clock.now() : 数字
>类型别名 :=> 数字
>Clock.now : () => 数字
>Clock : 类为 Clock
>now : () => 数字
>this.startTime : 任意
>类型别名 :=> 任意
>this : 本体
>startTime : 任意
>类型别名 :=> 任意
>Clock.resolution : 数字
>类型别名 :=> 数字
>Clock : 类为 Clock
>resolution : 数字
>类型别名 :=> 数字
>1000 : 1000
            }
        }

        export class Dataset {
>Dataset : Dataset

            public data: number[] = [];
>data : 数字[]
>[] : 未定[]

            public add(value: number) {
>add : (value: 数字) => 无值
>value : 数字
>类型别名 :=> 数字

                this.data.push(value);
>this.data.push(value) : 数字
>类型别名 :=> 数字
>this.data.push : (...items: 数字[]) => 数字
>this.data : 数字[]
>this : 本体
>data : 数字[]
>push : (...items: 数字[]) => 数字
>value : 数字
>类型别名 :=> 数字
            }

            public mean() {
>mean : () => 数字

                var sum = 0;
>sum : 数字
>类型别名 :=> 数字
>0 : 0

                for (var i = 0; i < this.data.length; i++) {
>i : 数字
>类型别名 :=> 数字
>0 : 0
>i < this.data.length : 真假
>类型别名 :=> 真假
>i : 数字
>类型别名 :=> 数字
>this.data.length : 数字
>类型别名 :=> 数字
>this.data : 数字[]
>this : 本体
>data : 数字[]
>length : 数字
>类型别名 :=> 数字
>i++ : 数字
>类型别名 :=> 数字
>i : 数字
>类型别名 :=> 数字

                    sum += this.data[i];
>sum += this.data[i] : 数字
>类型别名 :=> 数字
>sum : 数字
>类型别名 :=> 数字
>this.data[i] : 数字
>类型别名 :=> 数字
>this.data : 数字[]
>this : 本体
>data : 数字[]
>i : 数字
>类型别名 :=> 数字
                }

                return sum / this.data.length;
>sum / this.data.length : 数字
>类型别名 :=> 数字
>sum : 数字
>类型别名 :=> 数字
>this.data.length : 数字
>类型别名 :=> 数字
>this.data : 数字[]
>this : 本体
>data : 数字[]
>length : 数字
>类型别名 :=> 数字
            }

            public min() {
>min : () => 数字

                var min = this.data[0];
>min : 数字
>类型别名 :=> 数字
>this.data[0] : 数字
>类型别名 :=> 数字
>this.data : 数字[]
>this : 本体
>data : 数字[]
>0 : 0

                for (var i = 1; i < this.data.length; i++) {
>i : 数字
>类型别名 :=> 数字
>1 : 1
>i < this.data.length : 真假
>类型别名 :=> 真假
>i : 数字
>类型别名 :=> 数字
>this.data.length : 数字
>类型别名 :=> 数字
>this.data : 数字[]
>this : 本体
>data : 数字[]
>length : 数字
>类型别名 :=> 数字
>i++ : 数字
>类型别名 :=> 数字
>i : 数字
>类型别名 :=> 数字

                    if (this.data[i] < min) {
>this.data[i] < min : 真假
>类型别名 :=> 真假
>this.data[i] : 数字
>类型别名 :=> 数字
>this.data : 数字[]
>this : 本体
>data : 数字[]
>i : 数字
>类型别名 :=> 数字
>min : 数字
>类型别名 :=> 数字

                        min = this.data[i];
>min = this.data[i] : 数字
>类型别名 :=> 数字
>min : 数字
>类型别名 :=> 数字
>this.data[i] : 数字
>类型别名 :=> 数字
>this.data : 数字[]
>this : 本体
>data : 数字[]
>i : 数字
>类型别名 :=> 数字
                    }
                }

                return min;
>min : 数字
>类型别名 :=> 数字
            }

            public max() {
>max : () => 数字

                var max = this.data[0];
>max : 数字
>类型别名 :=> 数字
>this.data[0] : 数字
>类型别名 :=> 数字
>this.data : 数字[]
>this : 本体
>data : 数字[]
>0 : 0

                for (var i = 1; i < this.data.length; i++) {
>i : 数字
>类型别名 :=> 数字
>1 : 1
>i < this.data.length : 真假
>类型别名 :=> 真假
>i : 数字
>类型别名 :=> 数字
>this.data.length : 数字
>类型别名 :=> 数字
>this.data : 数字[]
>this : 本体
>data : 数字[]
>length : 数字
>类型别名 :=> 数字
>i++ : 数字
>类型别名 :=> 数字
>i : 数字
>类型别名 :=> 数字

                    if (this.data[i] > max) {
>this.data[i] > max : 真假
>类型别名 :=> 真假
>this.data[i] : 数字
>类型别名 :=> 数字
>this.data : 数字[]
>this : 本体
>data : 数字[]
>i : 数字
>类型别名 :=> 数字
>max : 数字
>类型别名 :=> 数字

                        max = this.data[i];
>max = this.data[i] : 数字
>类型别名 :=> 数字
>max : 数字
>类型别名 :=> 数字
>this.data[i] : 数字
>类型别名 :=> 数字
>this.data : 数字[]
>this : 本体
>data : 数字[]
>i : 数字
>类型别名 :=> 数字
                    }
                }

                return max;
>max : 数字
>类型别名 :=> 数字
            }

            public stdDev() {
>stdDev : () => 数字

                var sampleMean = this.mean();
>sampleMean : 数字
>类型别名 :=> 数字
>this.mean() : 数字
>类型别名 :=> 数字
>this.mean : () => 数字
>this : 本体
>mean : () => 数字

                var sumOfSquares = 0;
>sumOfSquares : 数字
>类型别名 :=> 数字
>0 : 0

                for (var i = 0; i < this.data.length; i++) {
>i : 数字
>类型别名 :=> 数字
>0 : 0
>i < this.data.length : 真假
>类型别名 :=> 真假
>i : 数字
>类型别名 :=> 数字
>this.data.length : 数字
>类型别名 :=> 数字
>this.data : 数字[]
>this : 本体
>data : 数字[]
>length : 数字
>类型别名 :=> 数字
>i++ : 数字
>类型别名 :=> 数字
>i : 数字
>类型别名 :=> 数字

                    sumOfSquares += Math.pow(this.data[i] - sampleMean, 2);
>sumOfSquares += Math.pow(this.data[i] - sampleMean, 2) : 数字
>类型别名 :=> 数字
>sumOfSquares : 数字
>类型别名 :=> 数字
>Math.pow(this.data[i] - sampleMean, 2) : 数字
>类型别名 :=> 数字
>Math.pow : (x: 数字, y: 数字) => 数字
>Math : Math
>pow : (x: 数字, y: 数字) => 数字
>this.data[i] - sampleMean : 数字
>类型别名 :=> 数字
>this.data[i] : 数字
>类型别名 :=> 数字
>this.data : 数字[]
>this : 本体
>data : 数字[]
>i : 数字
>类型别名 :=> 数字
>sampleMean : 数字
>类型别名 :=> 数字
>2 : 2
                }

                return Math.sqrt(sumOfSquares / this.data.length);
>Math.sqrt(sumOfSquares / this.data.length) : 数字
>类型别名 :=> 数字
>Math.sqrt : (x: 数字) => 数字
>Math : Math
>sqrt : (x: 数字) => 数字
>sumOfSquares / this.data.length : 数字
>类型别名 :=> 数字
>sumOfSquares : 数字
>类型别名 :=> 数字
>this.data.length : 数字
>类型别名 :=> 数字
>this.data : 数字[]
>this : 本体
>data : 数字[]
>length : 数字
>类型别名 :=> 数字
            }
        }

        // Base benchmark class with some defaults.
        export class Benchmark {
>Benchmark : Benchmark

            public iterations = 10;
>iterations : 数字
>类型别名 :=> 数字
>10 : 10

            public description = "";
>description : 文字
>类型别名 :=> 文字
>"" : ""

            public bench(subBench?: () => void ) { }
>bench : (subBench?: () => 无值) => 无值
>subBench : () => 无值

            public before() { }
>before : () => 无值

            public beforeEach() { }
>beforeEach : () => 无值

            public after() { }
>after : () => 无值

            public afterEach() { }
>afterEach : () => 无值

            public results: { [x: string]: Dataset; } = <{ [x: string]: Dataset; }>{};
>results : { [x: 文字]: Dataset; }
>x : 文字
>类型别名 :=> 文字
>Dataset : Dataset
><{ [x: string]: Dataset; }>{} : { [x: 文字]: Dataset; }
>x : 文字
>类型别名 :=> 文字
>Dataset : Dataset
>{} : {}

            public addTimingFor(name: string, timing: number) {
>addTimingFor : (name: 文字, timing: 数字) => 无值
>name : 文字
>类型别名 :=> 文字
>timing : 数字
>类型别名 :=> 数字

                this.results[name] = this.results[name] || new Dataset();
>this.results[name] = this.results[name] || new Dataset() : Dataset
>this.results[name] : Dataset
>this.results : { [x: 文字]: Dataset; }
>this : 本体
>results : { [x: 文字]: Dataset; }
>name : 文字
>类型别名 :=> 文字
>this.results[name] || new Dataset() : Dataset
>this.results[name] : Dataset
>this.results : { [x: 文字]: Dataset; }
>this : 本体
>results : { [x: 文字]: Dataset; }
>name : 文字
>类型别名 :=> 文字
>new Dataset() : Dataset
>Dataset : 类为 Dataset

                this.results[name].add(timing);
>this.results[name].add(timing) : 无值
>类型别名 :=> 无值
>this.results[name].add : (value: 数字) => 无值
>this.results[name] : Dataset
>this.results : { [x: 文字]: Dataset; }
>this : 本体
>results : { [x: 文字]: Dataset; }
>name : 文字
>类型别名 :=> 文字
>add : (value: 数字) => 无值
>timing : 数字
>类型别名 :=> 数字
            }
        }

        export var benchmarks: { new (): Benchmark; }[] = [];
>benchmarks : (新建 () => Benchmark)[]
>Benchmark : Benchmark
>[] : 未定[]

        var timeFunction: (
>timeFunction : (benchmark: Benchmark, description?: 文字, name?: 文字, f?: (bench?: () => 无值) => 无值) => 无值

            benchmark: Benchmark,
>benchmark : Benchmark
>Benchmark : Benchmark

            description?: string,
>description : 文字
>类型别名 :=> 文字

            name?: string,
>name : 文字
>类型别名 :=> 文字

            f?: (bench?: { (): void; }) => void
>f : (bench?: () => 无值) => 无值
>bench : () => 无值

        ) => void;

        timeFunction = function (
>timeFunction = function (            benchmark: Benchmark,            description: string = benchmark.description,            name: string = '',            f = benchmark.bench        ): void {            var t = new Timer();            t.start();            var subBenchmark = function (name, f): void {                timeFunction(benchmark, description, name, f);            }            f.call(benchmark, subBenchmark);            t.end();            benchmark.addTimingFor(name, t.time);        } : (benchmark: Benchmark, description?: 文字, name?: 文字, f?: (bench?: () => 无值) => 无值) => 无值
>timeFunction : (benchmark: Benchmark, description?: 文字, name?: 文字, f?: (bench?: () => 无值) => 无值) => 无值
>function (            benchmark: Benchmark,            description: string = benchmark.description,            name: string = '',            f = benchmark.bench        ): void {            var t = new Timer();            t.start();            var subBenchmark = function (name, f): void {                timeFunction(benchmark, description, name, f);            }            f.call(benchmark, subBenchmark);            t.end();            benchmark.addTimingFor(name, t.time);        } : (benchmark: Benchmark, description?: 文字, name?: 文字, f?: (bench?: () => 无值) => 无值) => 无值

            benchmark: Benchmark,
>benchmark : Benchmark
>Benchmark : Benchmark

            description: string = benchmark.description,
>description : 文字
>类型别名 :=> 文字
>benchmark.description : 文字
>类型别名 :=> 文字
>benchmark : Benchmark
>description : 文字
>类型别名 :=> 文字

            name: string = '',
>name : 文字
>类型别名 :=> 文字
>'' : ""

            f = benchmark.bench
>f : (bench?: () => 无值) => 无值
>benchmark.bench : (subBench?: () => 无值) => 无值
>benchmark : Benchmark
>bench : (subBench?: () => 无值) => 无值

        ): void {

            var t = new Timer();
>t : Timer
>new Timer() : Timer
>Timer : 类为 Timer

            t.start();
>t.start() : 无值
>类型别名 :=> 无值
>t.start : () => 无值
>t : Timer
>start : () => 无值

            var subBenchmark = function (name, f): void {
>subBenchmark : (name: 任意, f: 任意) => 无值
>function (name, f): void {                timeFunction(benchmark, description, name, f);            } : (name: 任意, f: 任意) => 无值
>name : 任意
>类型别名 :=> 任意
>f : 任意
>类型别名 :=> 任意

                timeFunction(benchmark, description, name, f);
>timeFunction(benchmark, description, name, f) : 无值
>类型别名 :=> 无值
>timeFunction : (benchmark: Benchmark, description?: 文字, name?: 文字, f?: (bench?: () => 无值) => 无值) => 无值
>benchmark : Benchmark
>description : 文字
>类型别名 :=> 文字
>name : 任意
>类型别名 :=> 任意
>f : 任意
>类型别名 :=> 任意
            }

            f.call(benchmark, subBenchmark);
>f.call(benchmark, subBenchmark) : 任意
>类型别名 :=> 任意
>f.call : (this: Function, thisArg: 任意, ...argArray: 任意[]) => 任意
>f : (bench?: () => 无值) => 无值
>call : (this: Function, thisArg: 任意, ...argArray: 任意[]) => 任意
>benchmark : Benchmark
>subBenchmark : (name: 任意, f: 任意) => 无值

            t.end();
>t.end() : 无值
>类型别名 :=> 无值
>t.end : () => 无值
>t : Timer
>end : () => 无值

            benchmark.addTimingFor(name, t.time);
>benchmark.addTimingFor(name, t.time) : 无值
>类型别名 :=> 无值
>benchmark.addTimingFor : (name: 文字, timing: 数字) => 无值
>benchmark : Benchmark
>addTimingFor : (name: 文字, timing: 数字) => 无值
>name : 文字
>类型别名 :=> 文字
>t.time : 数字
>类型别名 :=> 数字
>t : Timer
>time : 数字
>类型别名 :=> 数字
        }

        export function runBenchmarks() {
>runBenchmarks : () => 无值

            for (var i = 0; i < benchmarks.length; i++) {
>i : 数字
>类型别名 :=> 数字
>0 : 0
>i < benchmarks.length : 真假
>类型别名 :=> 真假
>i : 数字
>类型别名 :=> 数字
>benchmarks.length : 数字
>类型别名 :=> 数字
>benchmarks : (新建 () => Benchmark)[]
>length : 数字
>类型别名 :=> 数字
>i++ : 数字
>类型别名 :=> 数字
>i : 数字
>类型别名 :=> 数字

                var b = new benchmarks[i]();
>b : Benchmark
>new benchmarks[i]() : Benchmark
>benchmarks[i] : 新建 () => Benchmark
>benchmarks : (新建 () => Benchmark)[]
>i : 数字
>类型别名 :=> 数字


                var t = new Timer();
>t : Timer
>new Timer() : Timer
>Timer : 类为 Timer

                b.before();
>b.before() : 无值
>类型别名 :=> 无值
>b.before : () => 无值
>b : Benchmark
>before : () => 无值

                for (var j = 0; j < b.iterations; j++) {
>j : 数字
>类型别名 :=> 数字
>0 : 0
>j < b.iterations : 真假
>类型别名 :=> 真假
>j : 数字
>类型别名 :=> 数字
>b.iterations : 数字
>类型别名 :=> 数字
>b : Benchmark
>iterations : 数字
>类型别名 :=> 数字
>j++ : 数字
>类型别名 :=> 数字
>j : 数字
>类型别名 :=> 数字

                    b.beforeEach();
>b.beforeEach() : 无值
>类型别名 :=> 无值
>b.beforeEach : () => 无值
>b : Benchmark
>beforeEach : () => 无值

                    timeFunction(b);
>timeFunction(b) : 无值
>类型别名 :=> 无值
>timeFunction : (benchmark: Benchmark, description?: 文字, name?: 文字, f?: (bench?: () => 无值) => 无值) => 无值
>b : Benchmark

                    b.afterEach();
>b.afterEach() : 无值
>类型别名 :=> 无值
>b.afterEach : () => 无值
>b : Benchmark
>afterEach : () => 无值
                }
                b.after();
>b.after() : 无值
>类型别名 :=> 无值
>b.after : () => 无值
>b : Benchmark
>after : () => 无值

                for (var prop in b.results) {
>prop : 文字
>类型别名 :=> 文字
>b.results : { [x: 文字]: Dataset; }
>b : Benchmark
>results : { [x: 文字]: Dataset; }

                    var description = b.description + (prop ? ": " + prop : '');
>description : 文字
>类型别名 :=> 文字
>b.description + (prop ? ": " + prop : '') : 文字
>类型别名 :=> 文字
>b.description : 文字
>类型别名 :=> 文字
>b : Benchmark
>description : 文字
>类型别名 :=> 文字
>(prop ? ": " + prop : '') : 文字
>类型别名 :=> 文字
>prop ? ": " + prop : '' : 文字
>类型别名 :=> 文字
>prop : 文字
>类型别名 :=> 文字
>": " + prop : 文字
>类型别名 :=> 文字
>": " : ": "
>prop : 文字
>类型别名 :=> 文字
>'' : ""

                    emitLog('testStart', { desc: description });
>emitLog('testStart', { desc: description }) : 无值
>类型别名 :=> 无值
>emitLog : (field: 文字, ...params: 任意[]) => 无值
>'testStart' : "testStart"
>{ desc: description } : { desc: 文字; }
>desc : 文字
>类型别名 :=> 文字
>description : 文字
>类型别名 :=> 文字

                    emitLog('pass', {
>emitLog('pass', {                        desc: description, pass: true, perfResults: {                            mean: b.results[prop].mean(),                            min: b.results[prop].min(),                            max: b.results[prop].max(),                            stdDev: b.results[prop].stdDev(),                            trials: b.results[prop].data                        }                    }) : 无值
>类型别名 :=> 无值
>emitLog : (field: 文字, ...params: 任意[]) => 无值
>'pass' : "pass"
>{                        desc: description, pass: true, perfResults: {                            mean: b.results[prop].mean(),                            min: b.results[prop].min(),                            max: b.results[prop].max(),                            stdDev: b.results[prop].stdDev(),                            trials: b.results[prop].data                        }                    } : { desc: 文字; pass: 真假; perfResults: { mean: 数字; min: 数字; max: 数字; stdDev: 数字; trials: 数字[]; }; }

                        desc: description, pass: true, perfResults: {
>desc : 文字
>类型别名 :=> 文字
>description : 文字
>类型别名 :=> 文字
>pass : 真假
>类型别名 :=> 真假
>true : 为真
>类型别名 :=> 为真
>perfResults : { mean: 数字; min: 数字; max: 数字; stdDev: 数字; trials: 数字[]; }
>{                            mean: b.results[prop].mean(),                            min: b.results[prop].min(),                            max: b.results[prop].max(),                            stdDev: b.results[prop].stdDev(),                            trials: b.results[prop].data                        } : { mean: 数字; min: 数字; max: 数字; stdDev: 数字; trials: 数字[]; }

                            mean: b.results[prop].mean(),
>mean : 数字
>类型别名 :=> 数字
>b.results[prop].mean() : 数字
>类型别名 :=> 数字
>b.results[prop].mean : () => 数字
>b.results[prop] : Dataset
>b.results : { [x: 文字]: Dataset; }
>b : Benchmark
>results : { [x: 文字]: Dataset; }
>prop : 文字
>类型别名 :=> 文字
>mean : () => 数字

                            min: b.results[prop].min(),
>min : 数字
>类型别名 :=> 数字
>b.results[prop].min() : 数字
>类型别名 :=> 数字
>b.results[prop].min : () => 数字
>b.results[prop] : Dataset
>b.results : { [x: 文字]: Dataset; }
>b : Benchmark
>results : { [x: 文字]: Dataset; }
>prop : 文字
>类型别名 :=> 文字
>min : () => 数字

                            max: b.results[prop].max(),
>max : 数字
>类型别名 :=> 数字
>b.results[prop].max() : 数字
>类型别名 :=> 数字
>b.results[prop].max : () => 数字
>b.results[prop] : Dataset
>b.results : { [x: 文字]: Dataset; }
>b : Benchmark
>results : { [x: 文字]: Dataset; }
>prop : 文字
>类型别名 :=> 文字
>max : () => 数字

                            stdDev: b.results[prop].stdDev(),
>stdDev : 数字
>类型别名 :=> 数字
>b.results[prop].stdDev() : 数字
>类型别名 :=> 数字
>b.results[prop].stdDev : () => 数字
>b.results[prop] : Dataset
>b.results : { [x: 文字]: Dataset; }
>b : Benchmark
>results : { [x: 文字]: Dataset; }
>prop : 文字
>类型别名 :=> 文字
>stdDev : () => 数字

                            trials: b.results[prop].data
>trials : 数字[]
>b.results[prop].data : 数字[]
>b.results[prop] : Dataset
>b.results : { [x: 文字]: Dataset; }
>b : Benchmark
>results : { [x: 文字]: Dataset; }
>prop : 文字
>类型别名 :=> 文字
>data : 数字[]
                        }
                    });
                }

            }
        }

        // Replace with better type when classes are assignment compatible with
        // the below type.
        // export function addBenchmark(BenchmarkClass: {new(): Benchmark;}) {
        export function addBenchmark(BenchmarkClass: any) {
>addBenchmark : (BenchmarkClass: 任意) => 无值
>BenchmarkClass : 任意
>类型别名 :=> 任意

            benchmarks.push(BenchmarkClass);
>benchmarks.push(BenchmarkClass) : 数字
>类型别名 :=> 数字
>benchmarks.push : (...items: (新建 () => Benchmark)[]) => 数字
>benchmarks : (新建 () => Benchmark)[]
>push : (...items: (新建 () => Benchmark)[]) => 数字
>BenchmarkClass : 任意
>类型别名 :=> 任意
        }

    }

    /** Functionality for compiling TypeScript code */
    export module Compiler {
>Compiler : 类为 Compiler

        /** Aggregate various writes into a single array of lines. Useful for passing to the
         *  TypeScript compiler to fill with source code or errors.
         */
        export class WriterAggregator implements ITextWriter {
>WriterAggregator : WriterAggregator
>ITextWriter : No type information available!

            public lines: string[] = [];
>lines : 文字[]
>[] : 未定[]

            public currentLine = "";
>currentLine : 文字
>类型别名 :=> 文字
>"" : ""

            public Write(str) {
>Write : (str: 任意) => 无值
>str : 任意
>类型别名 :=> 任意

                this.currentLine += str;
>this.currentLine += str : 文字
>类型别名 :=> 文字
>this.currentLine : 文字
>类型别名 :=> 文字
>this : 本体
>currentLine : 文字
>类型别名 :=> 文字
>str : 任意
>类型别名 :=> 任意
            }

            public WriteLine(str) {
>WriteLine : (str: 任意) => 无值
>str : 任意
>类型别名 :=> 任意

                this.lines.push(this.currentLine + str);
>this.lines.push(this.currentLine + str) : 数字
>类型别名 :=> 数字
>this.lines.push : (...items: 文字[]) => 数字
>this.lines : 文字[]
>this : 本体
>lines : 文字[]
>push : (...items: 文字[]) => 数字
>this.currentLine + str : 文字
>类型别名 :=> 文字
>this.currentLine : 文字
>类型别名 :=> 文字
>this : 本体
>currentLine : 文字
>类型别名 :=> 文字
>str : 任意
>类型别名 :=> 任意

                this.currentLine = "";
>this.currentLine = "" : ""
>this.currentLine : 文字
>类型别名 :=> 文字
>this : 本体
>currentLine : 文字
>类型别名 :=> 文字
>"" : ""
            }

            public Close() {
>Close : () => 无值

                if (this.currentLine.length > 0) { this.lines.push(this.currentLine); }
>this.currentLine.length > 0 : 真假
>类型别名 :=> 真假
>this.currentLine.length : 数字
>类型别名 :=> 数字
>this.currentLine : 文字
>类型别名 :=> 文字
>this : 本体
>currentLine : 文字
>类型别名 :=> 文字
>length : 数字
>类型别名 :=> 数字
>0 : 0
>this.lines.push(this.currentLine) : 数字
>类型别名 :=> 数字
>this.lines.push : (...items: 文字[]) => 数字
>this.lines : 文字[]
>this : 本体
>lines : 文字[]
>push : (...items: 文字[]) => 数字
>this.currentLine : 文字
>类型别名 :=> 文字
>this : 本体
>currentLine : 文字
>类型别名 :=> 文字

                this.currentLine = "";
>this.currentLine = "" : ""
>this.currentLine : 文字
>类型别名 :=> 文字
>this : 本体
>currentLine : 文字
>类型别名 :=> 文字
>"" : ""
            }

            public reset() {
>reset : () => 无值

                this.lines = [];
>this.lines = [] : 未定[]
>this.lines : 文字[]
>this : 本体
>lines : 文字[]
>[] : 未定[]

                this.currentLine = "";
>this.currentLine = "" : ""
>this.currentLine : 文字
>类型别名 :=> 文字
>this : 本体
>currentLine : 文字
>类型别名 :=> 文字
>"" : ""
            }
        }

        /** Mimics having multiple files, later concatenated to a single file. */
        export class EmitterIOHost implements TypeScript.EmitterIOHost {
>EmitterIOHost : EmitterIOHost
>TypeScript.EmitterIOHost : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>EmitterIOHost : No type information available!

            private fileCollection = {};
>fileCollection : {}
>{} : {}

            /** create file gets the whole path to create, so this works as expected with the --out parameter */
            public createFile(s: string, useUTF8?: boolean): ITextWriter {
>createFile : (s: 文字, useUTF8?: 真假) => 任意
>s : 文字
>类型别名 :=> 文字
>useUTF8 : 真假
>类型别名 :=> 真假
>ITextWriter : No type information available!

                if (this.fileCollection[s]) {
>this.fileCollection[s] : 任意
>类型别名 :=> 任意
>this.fileCollection : {}
>this : 本体
>fileCollection : {}
>s : 文字
>类型别名 :=> 文字

                    return <ITextWriter>this.fileCollection[s];
><ITextWriter>this.fileCollection[s] : 任意
>类型别名 :=> 任意
>ITextWriter : No type information available!
>this.fileCollection[s] : 任意
>类型别名 :=> 任意
>this.fileCollection : {}
>this : 本体
>fileCollection : {}
>s : 文字
>类型别名 :=> 文字
                }

                var writer = new Harness.Compiler.WriterAggregator();
>writer : WriterAggregator
>new Harness.Compiler.WriterAggregator() : WriterAggregator
>Harness.Compiler.WriterAggregator : 类为 WriterAggregator
>Harness.Compiler : 类为 Compiler
>Harness : 类为 Harness
>Compiler : 类为 Compiler
>WriterAggregator : 类为 WriterAggregator

                this.fileCollection[s] = writer;
>this.fileCollection[s] = writer : WriterAggregator
>this.fileCollection[s] : 任意
>类型别名 :=> 任意
>this.fileCollection : {}
>this : 本体
>fileCollection : {}
>s : 文字
>类型别名 :=> 文字
>writer : WriterAggregator

                return writer;
>writer : WriterAggregator
            }

            public directoryExists(s: string) { return false; }
>directoryExists : (s: 文字) => 真假
>s : 文字
>类型别名 :=> 文字
>false : 为假
>类型别名 :=> 为假

            public fileExists(s: string) { return typeof this.fileCollection[s] !== 'undefined'; }
>fileExists : (s: 文字) => 真假
>s : 文字
>类型别名 :=> 文字
>typeof this.fileCollection[s] !== 'undefined' : 真假
>类型别名 :=> 真假
>typeof this.fileCollection[s] : "string" | "number" | "boolean" | "symbol" | "undefined" | "object" | "function" | "文字" | "数字" | "真假" | "符号" | "未定" | "对象" | "函数"
>this.fileCollection[s] : 任意
>类型别名 :=> 任意
>this.fileCollection : {}
>this : 本体
>fileCollection : {}
>s : 文字
>类型别名 :=> 文字
>'undefined' : "undefined"

            public resolvePath(s: string) { return s; }
>resolvePath : (s: 文字) => 文字
>s : 文字
>类型别名 :=> 文字
>s : 文字
>类型别名 :=> 文字

            public reset() { this.fileCollection = {}; }
>reset : () => 无值
>this.fileCollection = {} : {}
>this.fileCollection : {}
>this : 本体
>fileCollection : {}
>{} : {}

            public toArray(): { filename: string; file: WriterAggregator; }[] {
>toArray : () => { filename: 文字; file: WriterAggregator; }[]
>filename : 文字
>类型别名 :=> 文字
>file : WriterAggregator
>WriterAggregator : WriterAggregator

                var result: { filename: string; file: WriterAggregator; }[] = [];
>result : { filename: 文字; file: WriterAggregator; }[]
>filename : 文字
>类型别名 :=> 文字
>file : WriterAggregator
>WriterAggregator : WriterAggregator
>[] : 未定[]

                for (var p in this.fileCollection) {
>p : 文字
>类型别名 :=> 文字
>this.fileCollection : {}
>this : 本体
>fileCollection : {}

                    if (this.fileCollection.hasOwnProperty(p)) {
>this.fileCollection.hasOwnProperty(p) : 真假
>类型别名 :=> 真假
>this.fileCollection.hasOwnProperty : (v: 文字) => 真假
>this.fileCollection : {}
>this : 本体
>fileCollection : {}
>hasOwnProperty : (v: 文字) => 真假
>p : 文字
>类型别名 :=> 文字

                        var current = <Harness.Compiler.WriterAggregator>this.fileCollection[p];
>current : WriterAggregator
><Harness.Compiler.WriterAggregator>this.fileCollection[p] : WriterAggregator
>Harness : 任意
>类型别名 :=> 任意
>Compiler : 任意
>类型别名 :=> 任意
>WriterAggregator : WriterAggregator
>this.fileCollection[p] : 任意
>类型别名 :=> 任意
>this.fileCollection : {}
>this : 本体
>fileCollection : {}
>p : 文字
>类型别名 :=> 文字

                        if (current.lines.length > 0) {
>current.lines.length > 0 : 真假
>类型别名 :=> 真假
>current.lines.length : 数字
>类型别名 :=> 数字
>current.lines : 文字[]
>current : WriterAggregator
>lines : 文字[]
>length : 数字
>类型别名 :=> 数字
>0 : 0

                            if (p !== '0.js') { current.lines.unshift('////[' + p + ']'); }
>p !== '0.js' : 真假
>类型别名 :=> 真假
>p : 文字
>类型别名 :=> 文字
>'0.js' : "0.js"
>current.lines.unshift('////[' + p + ']') : 数字
>类型别名 :=> 数字
>current.lines.unshift : (...items: 文字[]) => 数字
>current.lines : 文字[]
>current : WriterAggregator
>lines : 文字[]
>unshift : (...items: 文字[]) => 数字
>'////[' + p + ']' : 文字
>类型别名 :=> 文字
>'////[' + p : 文字
>类型别名 :=> 文字
>'////[' : "////["
>p : 文字
>类型别名 :=> 文字
>']' : "]"

                            result.push({ filename: p, file: this.fileCollection[p] });
>result.push({ filename: p, file: this.fileCollection[p] }) : 数字
>类型别名 :=> 数字
>result.push : (...items: { filename: 文字; file: WriterAggregator; }[]) => 数字
>result : { filename: 文字; file: WriterAggregator; }[]
>push : (...items: { filename: 文字; file: WriterAggregator; }[]) => 数字
>{ filename: p, file: this.fileCollection[p] } : { filename: 文字; file: 任意; }
>filename : 文字
>类型别名 :=> 文字
>p : 文字
>类型别名 :=> 文字
>file : 任意
>类型别名 :=> 任意
>this.fileCollection[p] : 任意
>类型别名 :=> 任意
>this.fileCollection : {}
>this : 本体
>fileCollection : {}
>p : 文字
>类型别名 :=> 文字
                        }
                    }
                }
                return result;
>result : { filename: 文字; file: WriterAggregator; }[]
            }
        }

        var libFolder: string = global['WScript'] ? TypeScript.filePath(global['WScript'].ScriptFullName) : (__dirname + '/');
>libFolder : 文字
>类型别名 :=> 文字
>global['WScript'] ? TypeScript.filePath(global['WScript'].ScriptFullName) : (__dirname + '/') : 任意
>类型别名 :=> 任意
>global['WScript'] : 任意
>类型别名 :=> 任意
>global : 任意
>类型别名 :=> 任意
>'WScript' : "WScript"
>TypeScript.filePath(global['WScript'].ScriptFullName) : 任意
>类型别名 :=> 任意
>TypeScript.filePath : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>filePath : 任意
>类型别名 :=> 任意
>global['WScript'].ScriptFullName : 任意
>类型别名 :=> 任意
>global['WScript'] : 任意
>类型别名 :=> 任意
>global : 任意
>类型别名 :=> 任意
>'WScript' : "WScript"
>ScriptFullName : 任意
>类型别名 :=> 任意
>(__dirname + '/') : 文字
>类型别名 :=> 文字
>__dirname + '/' : 文字
>类型别名 :=> 文字
>__dirname : 任意
>类型别名 :=> 任意
>'/' : "/"

        export var libText = IO ? IO.readFile(libFolder + "lib.d.ts") : '';
>libText : 任意
>类型别名 :=> 任意
>IO ? IO.readFile(libFolder + "lib.d.ts") : '' : 任意
>类型别名 :=> 任意
>IO : 任意
>类型别名 :=> 任意
>IO.readFile(libFolder + "lib.d.ts") : 任意
>类型别名 :=> 任意
>IO.readFile : 任意
>类型别名 :=> 任意
>IO : 任意
>类型别名 :=> 任意
>readFile : 任意
>类型别名 :=> 任意
>libFolder + "lib.d.ts" : 文字
>类型别名 :=> 文字
>libFolder : 文字
>类型别名 :=> 文字
>"lib.d.ts" : "lib.d.ts"
>'' : ""

        var stdout = new EmitterIOHost();
>stdout : EmitterIOHost
>new EmitterIOHost() : EmitterIOHost
>EmitterIOHost : 类为 EmitterIOHost

        var stderr = new WriterAggregator();
>stderr : WriterAggregator
>new WriterAggregator() : WriterAggregator
>WriterAggregator : 类为 WriterAggregator

        export function isDeclareFile(filename: string) {
>isDeclareFile : (filename: 文字) => 真假
>filename : 文字
>类型别名 :=> 文字

            return /\.d\.ts$/.test(filename);
>/\.d\.ts$/.test(filename) : 真假
>类型别名 :=> 真假
>/\.d\.ts$/.test : (string: 文字) => 真假
>/\.d\.ts$/ : RegExp
>test : (string: 文字) => 真假
>filename : 文字
>类型别名 :=> 文字
        }

        export function makeDefaultCompilerForTest(c?: TypeScript.TypeScriptCompiler) {
>makeDefaultCompilerForTest : (c?: 任意) => 任意
>c : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>TypeScriptCompiler : No type information available!

            var compiler = c || new TypeScript.TypeScriptCompiler(stderr);
>compiler : 任意
>类型别名 :=> 任意
>c || new TypeScript.TypeScriptCompiler(stderr) : 任意
>类型别名 :=> 任意
>c : 任意
>类型别名 :=> 任意
>new TypeScript.TypeScriptCompiler(stderr) : 任意
>类型别名 :=> 任意
>TypeScript.TypeScriptCompiler : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>TypeScriptCompiler : 任意
>类型别名 :=> 任意
>stderr : WriterAggregator

            compiler.parser.errorRecovery = true;
>compiler.parser.errorRecovery = true : 为真
>类型别名 :=> 为真
>compiler.parser.errorRecovery : 任意
>类型别名 :=> 任意
>compiler.parser : 任意
>类型别名 :=> 任意
>compiler : 任意
>类型别名 :=> 任意
>parser : 任意
>类型别名 :=> 任意
>errorRecovery : 任意
>类型别名 :=> 任意
>true : 为真
>类型别名 :=> 为真

            compiler.settings.codeGenTarget = TypeScript.CodeGenTarget.ES5;
>compiler.settings.codeGenTarget = TypeScript.CodeGenTarget.ES5 : 任意
>类型别名 :=> 任意
>compiler.settings.codeGenTarget : 任意
>类型别名 :=> 任意
>compiler.settings : 任意
>类型别名 :=> 任意
>compiler : 任意
>类型别名 :=> 任意
>settings : 任意
>类型别名 :=> 任意
>codeGenTarget : 任意
>类型别名 :=> 任意
>TypeScript.CodeGenTarget.ES5 : 任意
>类型别名 :=> 任意
>TypeScript.CodeGenTarget : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>CodeGenTarget : 任意
>类型别名 :=> 任意
>ES5 : 任意
>类型别名 :=> 任意

            compiler.settings.controlFlow = true;
>compiler.settings.controlFlow = true : 为真
>类型别名 :=> 为真
>compiler.settings.controlFlow : 任意
>类型别名 :=> 任意
>compiler.settings : 任意
>类型别名 :=> 任意
>compiler : 任意
>类型别名 :=> 任意
>settings : 任意
>类型别名 :=> 任意
>controlFlow : 任意
>类型别名 :=> 任意
>true : 为真
>类型别名 :=> 为真

            compiler.settings.controlFlowUseDef = true;
>compiler.settings.controlFlowUseDef = true : 为真
>类型别名 :=> 为真
>compiler.settings.controlFlowUseDef : 任意
>类型别名 :=> 任意
>compiler.settings : 任意
>类型别名 :=> 任意
>compiler : 任意
>类型别名 :=> 任意
>settings : 任意
>类型别名 :=> 任意
>controlFlowUseDef : 任意
>类型别名 :=> 任意
>true : 为真
>类型别名 :=> 为真

            if (Harness.usePull) {
>Harness.usePull : 真假
>类型别名 :=> 真假
>Harness : 类为 Harness
>usePull : 真假
>类型别名 :=> 真假

                compiler.settings.usePull = true;
>compiler.settings.usePull = true : 为真
>类型别名 :=> 为真
>compiler.settings.usePull : 任意
>类型别名 :=> 任意
>compiler.settings : 任意
>类型别名 :=> 任意
>compiler : 任意
>类型别名 :=> 任意
>settings : 任意
>类型别名 :=> 任意
>usePull : 任意
>类型别名 :=> 任意
>true : 为真
>类型别名 :=> 为真

                compiler.settings.useFidelity = true;
>compiler.settings.useFidelity = true : 为真
>类型别名 :=> 为真
>compiler.settings.useFidelity : 任意
>类型别名 :=> 任意
>compiler.settings : 任意
>类型别名 :=> 任意
>compiler : 任意
>类型别名 :=> 任意
>settings : 任意
>类型别名 :=> 任意
>useFidelity : 任意
>类型别名 :=> 任意
>true : 为真
>类型别名 :=> 为真
            }

            compiler.parseEmitOption(stdout);
>compiler.parseEmitOption(stdout) : 任意
>类型别名 :=> 任意
>compiler.parseEmitOption : 任意
>类型别名 :=> 任意
>compiler : 任意
>类型别名 :=> 任意
>parseEmitOption : 任意
>类型别名 :=> 任意
>stdout : EmitterIOHost

            TypeScript.moduleGenTarget = TypeScript.ModuleGenTarget.Synchronous;
>TypeScript.moduleGenTarget = TypeScript.ModuleGenTarget.Synchronous : 任意
>类型别名 :=> 任意
>TypeScript.moduleGenTarget : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>moduleGenTarget : 任意
>类型别名 :=> 任意
>TypeScript.ModuleGenTarget.Synchronous : 任意
>类型别名 :=> 任意
>TypeScript.ModuleGenTarget : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>ModuleGenTarget : 任意
>类型别名 :=> 任意
>Synchronous : 任意
>类型别名 :=> 任意

            compiler.addUnit(Harness.Compiler.libText, "lib.d.ts", true);
>compiler.addUnit(Harness.Compiler.libText, "lib.d.ts", true) : 任意
>类型别名 :=> 任意
>compiler.addUnit : 任意
>类型别名 :=> 任意
>compiler : 任意
>类型别名 :=> 任意
>addUnit : 任意
>类型别名 :=> 任意
>Harness.Compiler.libText : 任意
>类型别名 :=> 任意
>Harness.Compiler : 类为 Compiler
>Harness : 类为 Harness
>Compiler : 类为 Compiler
>libText : 任意
>类型别名 :=> 任意
>"lib.d.ts" : "lib.d.ts"
>true : 为真
>类型别名 :=> 为真

            return compiler;
>compiler : 任意
>类型别名 :=> 任意
        }

        var compiler: TypeScript.TypeScriptCompiler;
>compiler : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>TypeScriptCompiler : No type information available!

        recreate();
>recreate() : 无值
>类型别名 :=> 无值
>recreate : () => 无值

        // pullUpdateUnit is sufficient if an existing unit is updated, if a new unit is added we need to do a full typecheck
        var needsFullTypeCheck = true;
>needsFullTypeCheck : 真假
>类型别名 :=> 真假
>true : 为真
>类型别名 :=> 为真

        export function compile(code?: string, filename?: string) {
>compile : (code?: 文字, filename?: 文字) => 无值
>code : 文字
>类型别名 :=> 文字
>filename : 文字
>类型别名 :=> 文字

            if (usePull) {
>usePull : 真假
>类型别名 :=> 真假

                if (needsFullTypeCheck) {
>needsFullTypeCheck : 真假
>类型别名 :=> 真假

                    compiler.pullTypeCheck(true);
>compiler.pullTypeCheck(true) : 任意
>类型别名 :=> 任意
>compiler.pullTypeCheck : 任意
>类型别名 :=> 任意
>compiler : 任意
>类型别名 :=> 任意
>pullTypeCheck : 任意
>类型别名 :=> 任意
>true : 为真
>类型别名 :=> 为真

                    needsFullTypeCheck = false;
>needsFullTypeCheck = false : 为假
>类型别名 :=> 为假
>needsFullTypeCheck : 真假
>类型别名 :=> 真假
>false : 为假
>类型别名 :=> 为假
                }
                else {
                    // requires unit to already exist in the compiler
                    compiler.pullUpdateUnit(new TypeScript.StringSourceText(""), filename, true);
>compiler.pullUpdateUnit(new TypeScript.StringSourceText(""), filename, true) : 任意
>类型别名 :=> 任意
>compiler.pullUpdateUnit : 任意
>类型别名 :=> 任意
>compiler : 任意
>类型别名 :=> 任意
>pullUpdateUnit : 任意
>类型别名 :=> 任意
>new TypeScript.StringSourceText("") : 任意
>类型别名 :=> 任意
>TypeScript.StringSourceText : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>StringSourceText : 任意
>类型别名 :=> 任意
>"" : ""
>filename : 文字
>类型别名 :=> 文字
>true : 为真
>类型别名 :=> 为真

                    compiler.pullUpdateUnit(new TypeScript.StringSourceText(code), filename, true);
>compiler.pullUpdateUnit(new TypeScript.StringSourceText(code), filename, true) : 任意
>类型别名 :=> 任意
>compiler.pullUpdateUnit : 任意
>类型别名 :=> 任意
>compiler : 任意
>类型别名 :=> 任意
>pullUpdateUnit : 任意
>类型别名 :=> 任意
>new TypeScript.StringSourceText(code) : 任意
>类型别名 :=> 任意
>TypeScript.StringSourceText : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>StringSourceText : 任意
>类型别名 :=> 任意
>code : 文字
>类型别名 :=> 文字
>filename : 文字
>类型别名 :=> 文字
>true : 为真
>类型别名 :=> 为真
                }
            }
            else {
                compiler.reTypeCheck();
>compiler.reTypeCheck() : 任意
>类型别名 :=> 任意
>compiler.reTypeCheck : 任意
>类型别名 :=> 任意
>compiler : 任意
>类型别名 :=> 任意
>reTypeCheck : 任意
>类型别名 :=> 任意
            }
        }

        // Types
        export class Type {
>Type : Type

            constructor(public type, public code, public identifier) { }
>type : 任意
>类型别名 :=> 任意
>code : 任意
>类型别名 :=> 任意
>identifier : 任意
>类型别名 :=> 任意

            public normalizeToArray(arg: any) {
>normalizeToArray : (arg: 任意) => 任意[]
>arg : 任意
>类型别名 :=> 任意

                if ((Array.isArray && Array.isArray(arg)) || arg instanceof Array)
>(Array.isArray && Array.isArray(arg)) || arg instanceof Array : 真假
>类型别名 :=> 真假
>(Array.isArray && Array.isArray(arg)) : 真假
>类型别名 :=> 真假
>Array.isArray && Array.isArray(arg) : 真假
>类型别名 :=> 真假
>Array.isArray : (arg: 任意) => arg 作为 任意[]
>Array : ArrayConstructor
>isArray : (arg: 任意) => arg 作为 任意[]
>Array.isArray(arg) : 真假
>类型别名 :=> 真假
>Array.isArray : (arg: 任意) => arg 作为 任意[]
>Array : ArrayConstructor
>isArray : (arg: 任意) => arg 作为 任意[]
>arg : 任意
>类型别名 :=> 任意
>arg instanceof Array : 真假
>类型别名 :=> 真假
>arg : 任意
>类型别名 :=> 任意
>Array : ArrayConstructor

                    return arg;
>arg : 任意[]

                return [arg];
>[arg] : 任意[]
>arg : 任意
>类型别名 :=> 任意
            }

            public compilesOk(testCode): boolean {
>compilesOk : (testCode: 任意) => 真假
>testCode : 任意
>类型别名 :=> 任意

                var errors = null;
>errors : 任意
>类型别名 :=> 任意
>null : 空值
>类型别名 :=> 空值

                compileString(testCode, 'test.ts', function (compilerResult) {
>compileString(testCode, 'test.ts', function (compilerResult) {                    errors = compilerResult.errors;                }) : 无值
>类型别名 :=> 无值
>compileString : (code: 文字, unitName: 文字, callback: (res: CompilerResult) => 无值, context?: CompilationContext, references?: 任意[]) => 无值
>testCode : 任意
>类型别名 :=> 任意
>'test.ts' : "test.ts"
>function (compilerResult) {                    errors = compilerResult.errors;                } : (compilerResult: CompilerResult) => 无值
>compilerResult : CompilerResult

                    errors = compilerResult.errors;
>errors = compilerResult.errors : CompilerError[]
>errors : 任意
>类型别名 :=> 任意
>compilerResult.errors : CompilerError[]
>compilerResult : CompilerResult
>errors : CompilerError[]

                })

                return errors.length === 0;
>errors.length === 0 : 真假
>类型别名 :=> 真假
>errors.length : 任意
>类型别名 :=> 任意
>errors : 任意
>类型别名 :=> 任意
>length : 任意
>类型别名 :=> 任意
>0 : 0
            }

            public isSubtypeOf(other: Type) {
>isSubtypeOf : (other: Type) => 真假
>other : Type
>Type : Type

                var testCode = 'class __test1__ {\n';
>testCode : 文字
>类型别名 :=> 文字
>'class __test1__ {\n' : "class __test1__ {\n"

                testCode += '    public test() {\n';
>testCode += '    public test() {\n' : 文字
>类型别名 :=> 文字
>testCode : 文字
>类型别名 :=> 文字
>'    public test() {\n' : "    public test() {\n"

                testCode += '        ' + other.code + ';\n';
>testCode += '        ' + other.code + ';\n' : 文字
>类型别名 :=> 文字
>testCode : 文字
>类型别名 :=> 文字
>'        ' + other.code + ';\n' : 文字
>类型别名 :=> 文字
>'        ' + other.code : 文字
>类型别名 :=> 文字
>'        ' : "        "
>other.code : 任意
>类型别名 :=> 任意
>other : Type
>code : 任意
>类型别名 :=> 任意
>';\n' : ";\n"

                testCode += '        return ' + other.identifier + ';\n';
>testCode += '        return ' + other.identifier + ';\n' : 文字
>类型别名 :=> 文字
>testCode : 文字
>类型别名 :=> 文字
>'        return ' + other.identifier + ';\n' : 文字
>类型别名 :=> 文字
>'        return ' + other.identifier : 文字
>类型别名 :=> 文字
>'        return ' : "        return "
>other.identifier : 任意
>类型别名 :=> 任意
>other : Type
>identifier : 任意
>类型别名 :=> 任意
>';\n' : ";\n"

                testCode += '    }\n';
>testCode += '    }\n' : 文字
>类型别名 :=> 文字
>testCode : 文字
>类型别名 :=> 文字
>'    }\n' : "    }\n"

                testCode += '}\n';
>testCode += '}\n' : 文字
>类型别名 :=> 文字
>testCode : 文字
>类型别名 :=> 文字
>'}\n' : "}\n"

                testCode += 'class __test2__ extends __test1__ {\n';
>testCode += 'class __test2__ extends __test1__ {\n' : 文字
>类型别名 :=> 文字
>testCode : 文字
>类型别名 :=> 文字
>'class __test2__ extends __test1__ {\n' : "class __test2__ extends __test1__ {\n"

                testCode += '    public test() {\n';
>testCode += '    public test() {\n' : 文字
>类型别名 :=> 文字
>testCode : 文字
>类型别名 :=> 文字
>'    public test() {\n' : "    public test() {\n"

                testCode += '        ' + this.code + ';\n';
>testCode += '        ' + this.code + ';\n' : 文字
>类型别名 :=> 文字
>testCode : 文字
>类型别名 :=> 文字
>'        ' + this.code + ';\n' : 文字
>类型别名 :=> 文字
>'        ' + this.code : 文字
>类型别名 :=> 文字
>'        ' : "        "
>this.code : 任意
>类型别名 :=> 任意
>this : 本体
>code : 任意
>类型别名 :=> 任意
>';\n' : ";\n"

                testCode += '        return ' + other.identifier + ';\n';
>testCode += '        return ' + other.identifier + ';\n' : 文字
>类型别名 :=> 文字
>testCode : 文字
>类型别名 :=> 文字
>'        return ' + other.identifier + ';\n' : 文字
>类型别名 :=> 文字
>'        return ' + other.identifier : 文字
>类型别名 :=> 文字
>'        return ' : "        return "
>other.identifier : 任意
>类型别名 :=> 任意
>other : Type
>identifier : 任意
>类型别名 :=> 任意
>';\n' : ";\n"

                testCode += '    }\n';
>testCode += '    }\n' : 文字
>类型别名 :=> 文字
>testCode : 文字
>类型别名 :=> 文字
>'    }\n' : "    }\n"

                testCode += '}\n';
>testCode += '}\n' : 文字
>类型别名 :=> 文字
>testCode : 文字
>类型别名 :=> 文字
>'}\n' : "}\n"

                return this.compilesOk(testCode);
>this.compilesOk(testCode) : 真假
>类型别名 :=> 真假
>this.compilesOk : (testCode: 任意) => 真假
>this : 本体
>compilesOk : (testCode: 任意) => 真假
>testCode : 文字
>类型别名 :=> 文字
            }

            // TODO: Find an implementation of isIdenticalTo that works.
            //public isIdenticalTo(other: Type) {
            //    var testCode = 'module __test1__ {\n';
            //    testCode += '    ' + this.code + ';\n';
            //    testCode += '    export var __val__ = ' + this.identifier + ';\n';
            //    testCode += '}\n';
            //    testCode += 'var __test1__val__ = __test1__.__val__;\n';

            //    testCode += 'module __test2__ {\n';
            //    testCode += '    ' + other.code + ';\n';
            //    testCode += '    export var __val__ = ' + other.identifier + ';\n';
            //    testCode += '}\n';
            //    testCode += 'var __test2__val__ = __test2__.__val__;\n';

            //    testCode += 'function __test__function__() { if(true) { return __test1__val__ }; return __test2__val__; }';

            //    return this.compilesOk(testCode);
            //}

            public assertSubtypeOf(others: any) {
>assertSubtypeOf : (others: 任意) => 无值
>others : 任意
>类型别名 :=> 任意

                others = this.normalizeToArray(others);
>others = this.normalizeToArray(others) : 任意[]
>others : 任意
>类型别名 :=> 任意
>this.normalizeToArray(others) : 任意[]
>this.normalizeToArray : (arg: 任意) => 任意[]
>this : 本体
>normalizeToArray : (arg: 任意) => 任意[]
>others : 任意
>类型别名 :=> 任意

                for (var i = 0; i < others.length; i++) {
>i : 数字
>类型别名 :=> 数字
>0 : 0
>i < others.length : 真假
>类型别名 :=> 真假
>i : 数字
>类型别名 :=> 数字
>others.length : 任意
>类型别名 :=> 任意
>others : 任意
>类型别名 :=> 任意
>length : 任意
>类型别名 :=> 任意
>i++ : 数字
>类型别名 :=> 数字
>i : 数字
>类型别名 :=> 数字

                    if (!this.isSubtypeOf(others[i])) {
>!this.isSubtypeOf(others[i]) : 真假
>类型别名 :=> 真假
>this.isSubtypeOf(others[i]) : 真假
>类型别名 :=> 真假
>this.isSubtypeOf : (other: Type) => 真假
>this : 本体
>isSubtypeOf : (other: Type) => 真假
>others[i] : 任意
>类型别名 :=> 任意
>others : 任意
>类型别名 :=> 任意
>i : 数字
>类型别名 :=> 数字

                        throw new Error("Expected " + this.type + " to be a subtype of " + others[i].type);
>new Error("Expected " + this.type + " to be a subtype of " + others[i].type) : Error
>Error : ErrorConstructor
>"Expected " + this.type + " to be a subtype of " + others[i].type : 文字
>类型别名 :=> 文字
>"Expected " + this.type + " to be a subtype of " : 文字
>类型别名 :=> 文字
>"Expected " + this.type : 文字
>类型别名 :=> 文字
>"Expected " : "Expected "
>this.type : 任意
>类型别名 :=> 任意
>this : 本体
>type : 任意
>类型别名 :=> 任意
>" to be a subtype of " : " to be a subtype of "
>others[i].type : 任意
>类型别名 :=> 任意
>others[i] : 任意
>类型别名 :=> 任意
>others : 任意
>类型别名 :=> 任意
>i : 数字
>类型别名 :=> 数字
>type : 任意
>类型别名 :=> 任意
                    }
                }
            }

            public assertNotSubtypeOf(others: any) {
>assertNotSubtypeOf : (others: 任意) => 无值
>others : 任意
>类型别名 :=> 任意

                others = this.normalizeToArray(others);
>others = this.normalizeToArray(others) : 任意[]
>others : 任意
>类型别名 :=> 任意
>this.normalizeToArray(others) : 任意[]
>this.normalizeToArray : (arg: 任意) => 任意[]
>this : 本体
>normalizeToArray : (arg: 任意) => 任意[]
>others : 任意
>类型别名 :=> 任意

                for (var i = 0; i < others.length; i++) {
>i : 数字
>类型别名 :=> 数字
>0 : 0
>i < others.length : 真假
>类型别名 :=> 真假
>i : 数字
>类型别名 :=> 数字
>others.length : 任意
>类型别名 :=> 任意
>others : 任意
>类型别名 :=> 任意
>length : 任意
>类型别名 :=> 任意
>i++ : 数字
>类型别名 :=> 数字
>i : 数字
>类型别名 :=> 数字

                    if (this.isSubtypeOf(others[i])) {
>this.isSubtypeOf(others[i]) : 真假
>类型别名 :=> 真假
>this.isSubtypeOf : (other: Type) => 真假
>this : 本体
>isSubtypeOf : (other: Type) => 真假
>others[i] : 任意
>类型别名 :=> 任意
>others : 任意
>类型别名 :=> 任意
>i : 数字
>类型别名 :=> 数字

                        throw new Error("Expected " + this.type + " to be a subtype of " + others[i].type);
>new Error("Expected " + this.type + " to be a subtype of " + others[i].type) : Error
>Error : ErrorConstructor
>"Expected " + this.type + " to be a subtype of " + others[i].type : 文字
>类型别名 :=> 文字
>"Expected " + this.type + " to be a subtype of " : 文字
>类型别名 :=> 文字
>"Expected " + this.type : 文字
>类型别名 :=> 文字
>"Expected " : "Expected "
>this.type : 任意
>类型别名 :=> 任意
>this : 本体
>type : 任意
>类型别名 :=> 任意
>" to be a subtype of " : " to be a subtype of "
>others[i].type : 任意
>类型别名 :=> 任意
>others[i] : 任意
>类型别名 :=> 任意
>others : 任意
>类型别名 :=> 任意
>i : 数字
>类型别名 :=> 数字
>type : 任意
>类型别名 :=> 任意
                    }
                }
            }

            //public assertIdenticalTo(other: Type) {
            //    if (!this.isIdenticalTo(other)) {
            //        throw new Error("Expected " + this.type + " to be identical to " + other.type);
            //    }
            //}

            //public assertNotIdenticalTo(other: Type) {
            //    if (!this.isIdenticalTo(other)) {
            //        throw new Error("Expected " + this.type + " to not be identical to " + other.type);
            //    }
            //}

            public isAssignmentCompatibleWith(other: Type) {
>isAssignmentCompatibleWith : (other: Type) => 真假
>other : Type
>Type : Type

                var testCode = 'module __test1__ {\n';
>testCode : 文字
>类型别名 :=> 文字
>'module __test1__ {\n' : "module __test1__ {\n"

                testCode += '    ' + this.code + ';\n';
>testCode += '    ' + this.code + ';\n' : 文字
>类型别名 :=> 文字
>testCode : 文字
>类型别名 :=> 文字
>'    ' + this.code + ';\n' : 文字
>类型别名 :=> 文字
>'    ' + this.code : 文字
>类型别名 :=> 文字
>'    ' : "    "
>this.code : 任意
>类型别名 :=> 任意
>this : 本体
>code : 任意
>类型别名 :=> 任意
>';\n' : ";\n"

                testCode += '    export var __val__ = ' + this.identifier + ';\n';
>testCode += '    export var __val__ = ' + this.identifier + ';\n' : 文字
>类型别名 :=> 文字
>testCode : 文字
>类型别名 :=> 文字
>'    export var __val__ = ' + this.identifier + ';\n' : 文字
>类型别名 :=> 文字
>'    export var __val__ = ' + this.identifier : 文字
>类型别名 :=> 文字
>'    export var __val__ = ' : "    export var __val__ = "
>this.identifier : 任意
>类型别名 :=> 任意
>this : 本体
>identifier : 任意
>类型别名 :=> 任意
>';\n' : ";\n"

                testCode += '}\n';
>testCode += '}\n' : 文字
>类型别名 :=> 文字
>testCode : 文字
>类型别名 :=> 文字
>'}\n' : "}\n"

                testCode += 'var __test1__val__ = __test1__.__val__;\n';
>testCode += 'var __test1__val__ = __test1__.__val__;\n' : 文字
>类型别名 :=> 文字
>testCode : 文字
>类型别名 :=> 文字
>'var __test1__val__ = __test1__.__val__;\n' : "var __test1__val__ = __test1__.__val__;\n"

                testCode += 'module __test2__ {\n';
>testCode += 'module __test2__ {\n' : 文字
>类型别名 :=> 文字
>testCode : 文字
>类型别名 :=> 文字
>'module __test2__ {\n' : "module __test2__ {\n"

                testCode += '    export ' + other.code + ';\n';
>testCode += '    export ' + other.code + ';\n' : 文字
>类型别名 :=> 文字
>testCode : 文字
>类型别名 :=> 文字
>'    export ' + other.code + ';\n' : 文字
>类型别名 :=> 文字
>'    export ' + other.code : 文字
>类型别名 :=> 文字
>'    export ' : "    export "
>other.code : 任意
>类型别名 :=> 任意
>other : Type
>code : 任意
>类型别名 :=> 任意
>';\n' : ";\n"

                testCode += '    export var __val__ = ' + other.identifier + ';\n';
>testCode += '    export var __val__ = ' + other.identifier + ';\n' : 文字
>类型别名 :=> 文字
>testCode : 文字
>类型别名 :=> 文字
>'    export var __val__ = ' + other.identifier + ';\n' : 文字
>类型别名 :=> 文字
>'    export var __val__ = ' + other.identifier : 文字
>类型别名 :=> 文字
>'    export var __val__ = ' : "    export var __val__ = "
>other.identifier : 任意
>类型别名 :=> 任意
>other : Type
>identifier : 任意
>类型别名 :=> 任意
>';\n' : ";\n"

                testCode += '}\n';
>testCode += '}\n' : 文字
>类型别名 :=> 文字
>testCode : 文字
>类型别名 :=> 文字
>'}\n' : "}\n"

                testCode += 'var __test2__val__ = __test2__.__val__;\n';
>testCode += 'var __test2__val__ = __test2__.__val__;\n' : 文字
>类型别名 :=> 文字
>testCode : 文字
>类型别名 :=> 文字
>'var __test2__val__ = __test2__.__val__;\n' : "var __test2__val__ = __test2__.__val__;\n"

                testCode += '__test2__val__ = __test1__val__;';
>testCode += '__test2__val__ = __test1__val__;' : 文字
>类型别名 :=> 文字
>testCode : 文字
>类型别名 :=> 文字
>'__test2__val__ = __test1__val__;' : "__test2__val__ = __test1__val__;"

                return this.compilesOk(testCode);
>this.compilesOk(testCode) : 真假
>类型别名 :=> 真假
>this.compilesOk : (testCode: 任意) => 真假
>this : 本体
>compilesOk : (testCode: 任意) => 真假
>testCode : 文字
>类型别名 :=> 文字
            }

            public assertAssignmentCompatibleWith(others: any) {
>assertAssignmentCompatibleWith : (others: 任意) => 无值
>others : 任意
>类型别名 :=> 任意

                others = this.normalizeToArray(others);
>others = this.normalizeToArray(others) : 任意[]
>others : 任意
>类型别名 :=> 任意
>this.normalizeToArray(others) : 任意[]
>this.normalizeToArray : (arg: 任意) => 任意[]
>this : 本体
>normalizeToArray : (arg: 任意) => 任意[]
>others : 任意
>类型别名 :=> 任意

                for (var i = 0; i < others.length; i++) {
>i : 数字
>类型别名 :=> 数字
>0 : 0
>i < others.length : 真假
>类型别名 :=> 真假
>i : 数字
>类型别名 :=> 数字
>others.length : 任意
>类型别名 :=> 任意
>others : 任意
>类型别名 :=> 任意
>length : 任意
>类型别名 :=> 任意
>i++ : 数字
>类型别名 :=> 数字
>i : 数字
>类型别名 :=> 数字

                    var other = others[i];
>other : 任意
>类型别名 :=> 任意
>others[i] : 任意
>类型别名 :=> 任意
>others : 任意
>类型别名 :=> 任意
>i : 数字
>类型别名 :=> 数字

                    if (!this.isAssignmentCompatibleWith(other)) {
>!this.isAssignmentCompatibleWith(other) : 真假
>类型别名 :=> 真假
>this.isAssignmentCompatibleWith(other) : 真假
>类型别名 :=> 真假
>this.isAssignmentCompatibleWith : (other: Type) => 真假
>this : 本体
>isAssignmentCompatibleWith : (other: Type) => 真假
>other : 任意
>类型别名 :=> 任意

                        throw new Error("Expected " + this.type + " to be assignment compatible with " + other.type);
>new Error("Expected " + this.type + " to be assignment compatible with " + other.type) : Error
>Error : ErrorConstructor
>"Expected " + this.type + " to be assignment compatible with " + other.type : 文字
>类型别名 :=> 文字
>"Expected " + this.type + " to be assignment compatible with " : 文字
>类型别名 :=> 文字
>"Expected " + this.type : 文字
>类型别名 :=> 文字
>"Expected " : "Expected "
>this.type : 任意
>类型别名 :=> 任意
>this : 本体
>type : 任意
>类型别名 :=> 任意
>" to be assignment compatible with " : " to be assignment compatible with "
>other.type : 任意
>类型别名 :=> 任意
>other : 任意
>类型别名 :=> 任意
>type : 任意
>类型别名 :=> 任意
                    }
                }
            }

            public assertNotAssignmentCompatibleWith(others: any) {
>assertNotAssignmentCompatibleWith : (others: 任意) => 无值
>others : 任意
>类型别名 :=> 任意

                others = this.normalizeToArray(others);
>others = this.normalizeToArray(others) : 任意[]
>others : 任意
>类型别名 :=> 任意
>this.normalizeToArray(others) : 任意[]
>this.normalizeToArray : (arg: 任意) => 任意[]
>this : 本体
>normalizeToArray : (arg: 任意) => 任意[]
>others : 任意
>类型别名 :=> 任意

                for (var i = 0; i < others.length; i++) {
>i : 数字
>类型别名 :=> 数字
>0 : 0
>i < others.length : 真假
>类型别名 :=> 真假
>i : 数字
>类型别名 :=> 数字
>others.length : 任意
>类型别名 :=> 任意
>others : 任意
>类型别名 :=> 任意
>length : 任意
>类型别名 :=> 任意
>i++ : 数字
>类型别名 :=> 数字
>i : 数字
>类型别名 :=> 数字

                    var other = others[i];
>other : 任意
>类型别名 :=> 任意
>others[i] : 任意
>类型别名 :=> 任意
>others : 任意
>类型别名 :=> 任意
>i : 数字
>类型别名 :=> 数字

                    if (this.isAssignmentCompatibleWith(other)) {
>this.isAssignmentCompatibleWith(other) : 真假
>类型别名 :=> 真假
>this.isAssignmentCompatibleWith : (other: Type) => 真假
>this : 本体
>isAssignmentCompatibleWith : (other: Type) => 真假
>other : 任意
>类型别名 :=> 任意

                        throw new Error("Expected " + this.type + " to not be assignment compatible with " + other.type);
>new Error("Expected " + this.type + " to not be assignment compatible with " + other.type) : Error
>Error : ErrorConstructor
>"Expected " + this.type + " to not be assignment compatible with " + other.type : 文字
>类型别名 :=> 文字
>"Expected " + this.type + " to not be assignment compatible with " : 文字
>类型别名 :=> 文字
>"Expected " + this.type : 文字
>类型别名 :=> 文字
>"Expected " : "Expected "
>this.type : 任意
>类型别名 :=> 任意
>this : 本体
>type : 任意
>类型别名 :=> 任意
>" to not be assignment compatible with " : " to not be assignment compatible with "
>other.type : 任意
>类型别名 :=> 任意
>other : 任意
>类型别名 :=> 任意
>type : 任意
>类型别名 :=> 任意
                    }
                }
            }

            public assertThisCanBeAssignedTo(desc: string, these: any[], notThese: any[]) {
>assertThisCanBeAssignedTo : (desc: 文字, these: 任意[], notThese: 任意[]) => 无值
>desc : 文字
>类型别名 :=> 文字
>these : 任意[]
>notThese : 任意[]

                it(desc + " is assignable to ", () => {
>it(desc + " is assignable to ", () => {                    this.assertAssignmentCompatibleWith(these);                }) : 无值
>类型别名 :=> 无值
>it : (description: 文字, block: () => 无值) => 无值
>desc + " is assignable to " : 文字
>类型别名 :=> 文字
>desc : 文字
>类型别名 :=> 文字
>" is assignable to " : " is assignable to "
>() => {                    this.assertAssignmentCompatibleWith(these);                } : () => 无值

                    this.assertAssignmentCompatibleWith(these);
>this.assertAssignmentCompatibleWith(these) : 无值
>类型别名 :=> 无值
>this.assertAssignmentCompatibleWith : (others: 任意) => 无值
>this : 本体
>assertAssignmentCompatibleWith : (others: 任意) => 无值
>these : 任意[]

                });
        
                it(desc + " not assignable to ", () => {
>it(desc + " not assignable to ", () => {                    this.assertNotAssignmentCompatibleWith(notThese);                }) : 无值
>类型别名 :=> 无值
>it : (description: 文字, block: () => 无值) => 无值
>desc + " not assignable to " : 文字
>类型别名 :=> 文字
>desc : 文字
>类型别名 :=> 文字
>" not assignable to " : " not assignable to "
>() => {                    this.assertNotAssignmentCompatibleWith(notThese);                } : () => 无值

                    this.assertNotAssignmentCompatibleWith(notThese);
>this.assertNotAssignmentCompatibleWith(notThese) : 无值
>类型别名 :=> 无值
>this.assertNotAssignmentCompatibleWith : (others: 任意) => 无值
>this : 本体
>assertNotAssignmentCompatibleWith : (others: 任意) => 无值
>notThese : 任意[]

                });
            }

        }

        export class TypeFactory {
>TypeFactory : TypeFactory

            public any: Type;
>any : Type
>Type : Type

            public number: Type;
>number : Type
>Type : Type

            public string: Type;
>string : Type
>Type : Type

            public boolean: Type;
>boolean : Type
>Type : Type

            constructor() {
                this.any = this.get('var x : any', 'x');
>this.any = this.get('var x : any', 'x') : Type
>this.any : Type
>this : 本体
>any : Type
>this.get('var x : any', 'x') : Type
>this.get : (code: 文字, target: 任意) => Type
>this : 本体
>get : (code: 文字, target: 任意) => Type
>'var x : any' : "var x : any"
>'x' : "x"

                this.number = this.get('var x : number', 'x');
>this.number = this.get('var x : number', 'x') : Type
>this.number : Type
>this : 本体
>number : Type
>this.get('var x : number', 'x') : Type
>this.get : (code: 文字, target: 任意) => Type
>this : 本体
>get : (code: 文字, target: 任意) => Type
>'var x : number' : "var x : number"
>'x' : "x"

                this.string = this.get('var x : string', 'x');
>this.string = this.get('var x : string', 'x') : Type
>this.string : Type
>this : 本体
>string : Type
>this.get('var x : string', 'x') : Type
>this.get : (code: 文字, target: 任意) => Type
>this : 本体
>get : (code: 文字, target: 任意) => Type
>'var x : string' : "var x : string"
>'x' : "x"

                this.boolean = this.get('var x : boolean', 'x');
>this.boolean = this.get('var x : boolean', 'x') : Type
>this.boolean : Type
>this : 本体
>boolean : Type
>this.get('var x : boolean', 'x') : Type
>this.get : (code: 文字, target: 任意) => Type
>this : 本体
>get : (code: 文字, target: 任意) => Type
>'var x : boolean' : "var x : boolean"
>'x' : "x"
            }

            public get (code: string, target: any) {
>get : (code: 文字, target: 任意) => Type
>code : 文字
>类型别名 :=> 文字
>target : 任意
>类型别名 :=> 任意

                var targetIdentifier = '';
>targetIdentifier : 文字
>类型别名 :=> 文字
>'' : ""

                var targetPosition = -1;
>targetPosition : 数字
>类型别名 :=> 数字
>-1 : -1
>1 : 1

                if (typeof target === "string") {
>typeof target === "string" : 真假
>类型别名 :=> 真假
>typeof target : "string" | "number" | "boolean" | "symbol" | "undefined" | "object" | "function" | "文字" | "数字" | "真假" | "符号" | "未定" | "对象" | "函数"
>target : 任意
>类型别名 :=> 任意
>"string" : "string"

                    targetIdentifier = target;
>targetIdentifier = target : 文字
>类型别名 :=> 文字
>targetIdentifier : 文字
>类型别名 :=> 文字
>target : 文字
>类型别名 :=> 文字
                }
                else if (typeof target === "number") {
>typeof target === "number" : 真假
>类型别名 :=> 真假
>typeof target : "string" | "number" | "boolean" | "symbol" | "undefined" | "object" | "function" | "文字" | "数字" | "真假" | "符号" | "未定" | "对象" | "函数"
>target : 任意
>类型别名 :=> 任意
>"number" : "number"

                    targetPosition = target;
>targetPosition = target : 数字
>类型别名 :=> 数字
>targetPosition : 数字
>类型别名 :=> 数字
>target : 数字
>类型别名 :=> 数字
                }
                else {
                    throw new Error("Expected string or number not " + (typeof target));
>new Error("Expected string or number not " + (typeof target)) : Error
>Error : ErrorConstructor
>"Expected string or number not " + (typeof target) : 文字
>类型别名 :=> 文字
>"Expected string or number not " : "Expected string or number not "
>(typeof target) : "string" | "number" | "boolean" | "symbol" | "undefined" | "object" | "function" | "文字" | "数字" | "真假" | "符号" | "未定" | "对象" | "函数"
>typeof target : "string" | "number" | "boolean" | "symbol" | "undefined" | "object" | "function" | "文字" | "数字" | "真假" | "符号" | "未定" | "对象" | "函数"
>target : 任意
>类型别名 :=> 任意
                }

                var errors = null;
>errors : 任意
>类型别名 :=> 任意
>null : 空值
>类型别名 :=> 空值

                compileString(code, 'test.ts', function (compilerResult) {
>compileString(code, 'test.ts', function (compilerResult) {                    errors = compilerResult.errors;                }) : 无值
>类型别名 :=> 无值
>compileString : (code: 文字, unitName: 文字, callback: (res: CompilerResult) => 无值, context?: CompilationContext, references?: 任意[]) => 无值
>code : 文字
>类型别名 :=> 文字
>'test.ts' : "test.ts"
>function (compilerResult) {                    errors = compilerResult.errors;                } : (compilerResult: CompilerResult) => 无值
>compilerResult : CompilerResult

                    errors = compilerResult.errors;
>errors = compilerResult.errors : CompilerError[]
>errors : 任意
>类型别名 :=> 任意
>compilerResult.errors : CompilerError[]
>compilerResult : CompilerResult
>errors : CompilerError[]

                })

                if (errors.length > 0)
>errors.length > 0 : 真假
>类型别名 :=> 真假
>errors.length : 任意
>类型别名 :=> 任意
>errors : 任意
>类型别名 :=> 任意
>length : 任意
>类型别名 :=> 任意
>0 : 0

                    throw new Error("Type definition contains errors: " + errors.join(","));
>new Error("Type definition contains errors: " + errors.join(",")) : Error
>Error : ErrorConstructor
>"Type definition contains errors: " + errors.join(",") : 文字
>类型别名 :=> 文字
>"Type definition contains errors: " : "Type definition contains errors: "
>errors.join(",") : 任意
>类型别名 :=> 任意
>errors.join : 任意
>类型别名 :=> 任意
>errors : 任意
>类型别名 :=> 任意
>join : 任意
>类型别名 :=> 任意
>"," : ","

                var matchingIdentifiers: Type[] = [];
>matchingIdentifiers : Type[]
>Type : Type
>[] : 未定[]

                if (!usePull) {
>!usePull : 真假
>类型别名 :=> 真假
>usePull : 真假
>类型别名 :=> 真假

                    // This will find the requested identifier in the first script where it's present, a naive search of each member in each script,
                    // which means this won't play nicely if the same identifier is used in multiple units, but it will enable this to work on multi-file tests.
                    // m = 1 because the first script will always be lib.d.ts which we don't want to search.                                
                    for (var m = 1; m < compiler.scripts.members.length; m++) {
>m : 数字
>类型别名 :=> 数字
>1 : 1
>m < compiler.scripts.members.length : 真假
>类型别名 :=> 真假
>m : 数字
>类型别名 :=> 数字
>compiler.scripts.members.length : 任意
>类型别名 :=> 任意
>compiler.scripts.members : 任意
>类型别名 :=> 任意
>compiler.scripts : 任意
>类型别名 :=> 任意
>compiler : 任意
>类型别名 :=> 任意
>scripts : 任意
>类型别名 :=> 任意
>members : 任意
>类型别名 :=> 任意
>length : 任意
>类型别名 :=> 任意
>m++ : 数字
>类型别名 :=> 数字
>m : 数字
>类型别名 :=> 数字

                        var script = compiler.scripts.members[m];
>script : 任意
>类型别名 :=> 任意
>compiler.scripts.members[m] : 任意
>类型别名 :=> 任意
>compiler.scripts.members : 任意
>类型别名 :=> 任意
>compiler.scripts : 任意
>类型别名 :=> 任意
>compiler : 任意
>类型别名 :=> 任意
>scripts : 任意
>类型别名 :=> 任意
>members : 任意
>类型别名 :=> 任意
>m : 数字
>类型别名 :=> 数字

                        var enclosingScopeContext = TypeScript.findEnclosingScopeAt(new TypeScript.NullLogger(), <TypeScript.Script>script, new TypeScript.StringSourceText(code), 0, false);
>enclosingScopeContext : 任意
>类型别名 :=> 任意
>TypeScript.findEnclosingScopeAt(new TypeScript.NullLogger(), <TypeScript.Script>script, new TypeScript.StringSourceText(code), 0, false) : 任意
>类型别名 :=> 任意
>TypeScript.findEnclosingScopeAt : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>findEnclosingScopeAt : 任意
>类型别名 :=> 任意
>new TypeScript.NullLogger() : 任意
>类型别名 :=> 任意
>TypeScript.NullLogger : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>NullLogger : 任意
>类型别名 :=> 任意
><TypeScript.Script>script : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>Script : No type information available!
>script : 任意
>类型别名 :=> 任意
>new TypeScript.StringSourceText(code) : 任意
>类型别名 :=> 任意
>TypeScript.StringSourceText : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>StringSourceText : 任意
>类型别名 :=> 任意
>code : 文字
>类型别名 :=> 文字
>0 : 0
>false : 为假
>类型别名 :=> 为假

                        var entries = new TypeScript.ScopeTraversal(compiler).getScopeEntries(enclosingScopeContext);
>entries : 任意
>类型别名 :=> 任意
>new TypeScript.ScopeTraversal(compiler).getScopeEntries(enclosingScopeContext) : 任意
>类型别名 :=> 任意
>new TypeScript.ScopeTraversal(compiler).getScopeEntries : 任意
>类型别名 :=> 任意
>new TypeScript.ScopeTraversal(compiler) : 任意
>类型别名 :=> 任意
>TypeScript.ScopeTraversal : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>ScopeTraversal : 任意
>类型别名 :=> 任意
>compiler : 任意
>类型别名 :=> 任意
>getScopeEntries : 任意
>类型别名 :=> 任意
>enclosingScopeContext : 任意
>类型别名 :=> 任意

                        for (var i = 0; i < entries.length; i++) {
>i : 数字
>类型别名 :=> 数字
>0 : 0
>i < entries.length : 真假
>类型别名 :=> 真假
>i : 数字
>类型别名 :=> 数字
>entries.length : 任意
>类型别名 :=> 任意
>entries : 任意
>类型别名 :=> 任意
>length : 任意
>类型别名 :=> 任意
>i++ : 数字
>类型别名 :=> 数字
>i : 数字
>类型别名 :=> 数字

                            if (entries[i].name === targetIdentifier) {
>entries[i].name === targetIdentifier : 真假
>类型别名 :=> 真假
>entries[i].name : 任意
>类型别名 :=> 任意
>entries[i] : 任意
>类型别名 :=> 任意
>entries : 任意
>类型别名 :=> 任意
>i : 数字
>类型别名 :=> 数字
>name : 任意
>类型别名 :=> 任意
>targetIdentifier : 文字
>类型别名 :=> 文字

                                matchingIdentifiers.push(new Type(entries[i].type, code, targetIdentifier));
>matchingIdentifiers.push(new Type(entries[i].type, code, targetIdentifier)) : 数字
>类型别名 :=> 数字
>matchingIdentifiers.push : (...items: Type[]) => 数字
>matchingIdentifiers : Type[]
>push : (...items: Type[]) => 数字
>new Type(entries[i].type, code, targetIdentifier) : Type
>Type : 类为 Type
>entries[i].type : 任意
>类型别名 :=> 任意
>entries[i] : 任意
>类型别名 :=> 任意
>entries : 任意
>类型别名 :=> 任意
>i : 数字
>类型别名 :=> 数字
>type : 任意
>类型别名 :=> 任意
>code : 文字
>类型别名 :=> 文字
>targetIdentifier : 文字
>类型别名 :=> 文字
                            }
                        }
                    }
                }
                else {
                    for (var m = 0; m < compiler.scripts.members.length; m++) {
>m : 数字
>类型别名 :=> 数字
>0 : 0
>m < compiler.scripts.members.length : 真假
>类型别名 :=> 真假
>m : 数字
>类型别名 :=> 数字
>compiler.scripts.members.length : 任意
>类型别名 :=> 任意
>compiler.scripts.members : 任意
>类型别名 :=> 任意
>compiler.scripts : 任意
>类型别名 :=> 任意
>compiler : 任意
>类型别名 :=> 任意
>scripts : 任意
>类型别名 :=> 任意
>members : 任意
>类型别名 :=> 任意
>length : 任意
>类型别名 :=> 任意
>m++ : 数字
>类型别名 :=> 数字
>m : 数字
>类型别名 :=> 数字

                        var script2 = <TypeScript.Script>compiler.scripts.members[m];
>script2 : 任意
>类型别名 :=> 任意
><TypeScript.Script>compiler.scripts.members[m] : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>Script : No type information available!
>compiler.scripts.members[m] : 任意
>类型别名 :=> 任意
>compiler.scripts.members : 任意
>类型别名 :=> 任意
>compiler.scripts : 任意
>类型别名 :=> 任意
>compiler : 任意
>类型别名 :=> 任意
>scripts : 任意
>类型别名 :=> 任意
>members : 任意
>类型别名 :=> 任意
>m : 数字
>类型别名 :=> 数字

                        if (script2.locationInfo.filename !== 'lib.d.ts') {
>script2.locationInfo.filename !== 'lib.d.ts' : 真假
>类型别名 :=> 真假
>script2.locationInfo.filename : 任意
>类型别名 :=> 任意
>script2.locationInfo : 任意
>类型别名 :=> 任意
>script2 : 任意
>类型别名 :=> 任意
>locationInfo : 任意
>类型别名 :=> 任意
>filename : 任意
>类型别名 :=> 任意
>'lib.d.ts' : "lib.d.ts"

                            if (targetPosition > -1) {
>targetPosition > -1 : 真假
>类型别名 :=> 真假
>targetPosition : 数字
>类型别名 :=> 数字
>-1 : -1
>1 : 1

                                var tyInfo = compiler.pullGetTypeInfoAtPosition(targetPosition, script2);
>tyInfo : 任意
>类型别名 :=> 任意
>compiler.pullGetTypeInfoAtPosition(targetPosition, script2) : 任意
>类型别名 :=> 任意
>compiler.pullGetTypeInfoAtPosition : 任意
>类型别名 :=> 任意
>compiler : 任意
>类型别名 :=> 任意
>pullGetTypeInfoAtPosition : 任意
>类型别名 :=> 任意
>targetPosition : 数字
>类型别名 :=> 数字
>script2 : 任意
>类型别名 :=> 任意

                                var name = this.getTypeInfoName(tyInfo.ast);
>name : 文字
>类型别名 :=> 文字
>this.getTypeInfoName(tyInfo.ast) : 文字
>类型别名 :=> 文字
>this.getTypeInfoName : (ast: 任意) => 文字
>this : 本体
>getTypeInfoName : (ast: 任意) => 文字
>tyInfo.ast : 任意
>类型别名 :=> 任意
>tyInfo : 任意
>类型别名 :=> 任意
>ast : 任意
>类型别名 :=> 任意

                                var foundValue = new Type(tyInfo.typeInfo, code, name);
>foundValue : Type
>new Type(tyInfo.typeInfo, code, name) : Type
>Type : 类为 Type
>tyInfo.typeInfo : 任意
>类型别名 :=> 任意
>tyInfo : 任意
>类型别名 :=> 任意
>typeInfo : 任意
>类型别名 :=> 任意
>code : 文字
>类型别名 :=> 文字
>name : 文字
>类型别名 :=> 文字

                                if (!matchingIdentifiers.some(value => (value.identifier === foundValue.identifier) && (value.code === foundValue.code) && (value.type === foundValue.type))) {
>!matchingIdentifiers.some(value => (value.identifier === foundValue.identifier) && (value.code === foundValue.code) && (value.type === foundValue.type)) : 真假
>类型别名 :=> 真假
>matchingIdentifiers.some(value => (value.identifier === foundValue.identifier) && (value.code === foundValue.code) && (value.type === foundValue.type)) : 真假
>类型别名 :=> 真假
>matchingIdentifiers.some : (callbackfn: (value: Type, index: 数字, array: Type[]) => 真假, thisArg?: 任意) => 真假
>matchingIdentifiers : Type[]
>some : (callbackfn: (value: Type, index: 数字, array: Type[]) => 真假, thisArg?: 任意) => 真假
>value => (value.identifier === foundValue.identifier) && (value.code === foundValue.code) && (value.type === foundValue.type) : (value: Type) => 真假
>value : Type
>(value.identifier === foundValue.identifier) && (value.code === foundValue.code) && (value.type === foundValue.type) : 真假
>类型别名 :=> 真假
>(value.identifier === foundValue.identifier) && (value.code === foundValue.code) : 真假
>类型别名 :=> 真假
>(value.identifier === foundValue.identifier) : 真假
>类型别名 :=> 真假
>value.identifier === foundValue.identifier : 真假
>类型别名 :=> 真假
>value.identifier : 任意
>类型别名 :=> 任意
>value : Type
>identifier : 任意
>类型别名 :=> 任意
>foundValue.identifier : 任意
>类型别名 :=> 任意
>foundValue : Type
>identifier : 任意
>类型别名 :=> 任意
>(value.code === foundValue.code) : 真假
>类型别名 :=> 真假
>value.code === foundValue.code : 真假
>类型别名 :=> 真假
>value.code : 任意
>类型别名 :=> 任意
>value : Type
>code : 任意
>类型别名 :=> 任意
>foundValue.code : 任意
>类型别名 :=> 任意
>foundValue : Type
>code : 任意
>类型别名 :=> 任意
>(value.type === foundValue.type) : 真假
>类型别名 :=> 真假
>value.type === foundValue.type : 真假
>类型别名 :=> 真假
>value.type : 任意
>类型别名 :=> 任意
>value : Type
>type : 任意
>类型别名 :=> 任意
>foundValue.type : 任意
>类型别名 :=> 任意
>foundValue : Type
>type : 任意
>类型别名 :=> 任意

                                    matchingIdentifiers.push(foundValue);
>matchingIdentifiers.push(foundValue) : 数字
>类型别名 :=> 数字
>matchingIdentifiers.push : (...items: Type[]) => 数字
>matchingIdentifiers : Type[]
>push : (...items: Type[]) => 数字
>foundValue : Type
                                }
                            }
                            else {
                                for (var pos = 0; pos < code.length; pos++) {
>pos : 数字
>类型别名 :=> 数字
>0 : 0
>pos < code.length : 真假
>类型别名 :=> 真假
>pos : 数字
>类型别名 :=> 数字
>code.length : 数字
>类型别名 :=> 数字
>code : 文字
>类型别名 :=> 文字
>length : 数字
>类型别名 :=> 数字
>pos++ : 数字
>类型别名 :=> 数字
>pos : 数字
>类型别名 :=> 数字

                                    var tyInfo = compiler.pullGetTypeInfoAtPosition(pos, script2);
>tyInfo : 任意
>类型别名 :=> 任意
>compiler.pullGetTypeInfoAtPosition(pos, script2) : 任意
>类型别名 :=> 任意
>compiler.pullGetTypeInfoAtPosition : 任意
>类型别名 :=> 任意
>compiler : 任意
>类型别名 :=> 任意
>pullGetTypeInfoAtPosition : 任意
>类型别名 :=> 任意
>pos : 数字
>类型别名 :=> 数字
>script2 : 任意
>类型别名 :=> 任意

                                    var name = this.getTypeInfoName(tyInfo.ast);
>name : 文字
>类型别名 :=> 文字
>this.getTypeInfoName(tyInfo.ast) : 文字
>类型别名 :=> 文字
>this.getTypeInfoName : (ast: 任意) => 文字
>this : 本体
>getTypeInfoName : (ast: 任意) => 文字
>tyInfo.ast : 任意
>类型别名 :=> 任意
>tyInfo : 任意
>类型别名 :=> 任意
>ast : 任意
>类型别名 :=> 任意

                                    if (name === targetIdentifier) {
>name === targetIdentifier : 真假
>类型别名 :=> 真假
>name : 文字
>类型别名 :=> 文字
>targetIdentifier : 文字
>类型别名 :=> 文字

                                        var foundValue = new Type(tyInfo.typeInfo, code, targetIdentifier);
>foundValue : Type
>new Type(tyInfo.typeInfo, code, targetIdentifier) : Type
>Type : 类为 Type
>tyInfo.typeInfo : 任意
>类型别名 :=> 任意
>tyInfo : 任意
>类型别名 :=> 任意
>typeInfo : 任意
>类型别名 :=> 任意
>code : 文字
>类型别名 :=> 文字
>targetIdentifier : 文字
>类型别名 :=> 文字

                                        if (!matchingIdentifiers.some(value => (value.identifier === foundValue.identifier) && (value.code === foundValue.code) && (value.type === foundValue.type))) {
>!matchingIdentifiers.some(value => (value.identifier === foundValue.identifier) && (value.code === foundValue.code) && (value.type === foundValue.type)) : 真假
>类型别名 :=> 真假
>matchingIdentifiers.some(value => (value.identifier === foundValue.identifier) && (value.code === foundValue.code) && (value.type === foundValue.type)) : 真假
>类型别名 :=> 真假
>matchingIdentifiers.some : (callbackfn: (value: Type, index: 数字, array: Type[]) => 真假, thisArg?: 任意) => 真假
>matchingIdentifiers : Type[]
>some : (callbackfn: (value: Type, index: 数字, array: Type[]) => 真假, thisArg?: 任意) => 真假
>value => (value.identifier === foundValue.identifier) && (value.code === foundValue.code) && (value.type === foundValue.type) : (value: Type) => 真假
>value : Type
>(value.identifier === foundValue.identifier) && (value.code === foundValue.code) && (value.type === foundValue.type) : 真假
>类型别名 :=> 真假
>(value.identifier === foundValue.identifier) && (value.code === foundValue.code) : 真假
>类型别名 :=> 真假
>(value.identifier === foundValue.identifier) : 真假
>类型别名 :=> 真假
>value.identifier === foundValue.identifier : 真假
>类型别名 :=> 真假
>value.identifier : 任意
>类型别名 :=> 任意
>value : Type
>identifier : 任意
>类型别名 :=> 任意
>foundValue.identifier : 任意
>类型别名 :=> 任意
>foundValue : Type
>identifier : 任意
>类型别名 :=> 任意
>(value.code === foundValue.code) : 真假
>类型别名 :=> 真假
>value.code === foundValue.code : 真假
>类型别名 :=> 真假
>value.code : 任意
>类型别名 :=> 任意
>value : Type
>code : 任意
>类型别名 :=> 任意
>foundValue.code : 任意
>类型别名 :=> 任意
>foundValue : Type
>code : 任意
>类型别名 :=> 任意
>(value.type === foundValue.type) : 真假
>类型别名 :=> 真假
>value.type === foundValue.type : 真假
>类型别名 :=> 真假
>value.type : 任意
>类型别名 :=> 任意
>value : Type
>type : 任意
>类型别名 :=> 任意
>foundValue.type : 任意
>类型别名 :=> 任意
>foundValue : Type
>type : 任意
>类型别名 :=> 任意

                                            matchingIdentifiers.push(foundValue);
>matchingIdentifiers.push(foundValue) : 数字
>类型别名 :=> 数字
>matchingIdentifiers.push : (...items: Type[]) => 数字
>matchingIdentifiers : Type[]
>push : (...items: Type[]) => 数字
>foundValue : Type
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                if (matchingIdentifiers.length === 0) {
>matchingIdentifiers.length === 0 : 真假
>类型别名 :=> 真假
>matchingIdentifiers.length : 数字
>类型别名 :=> 数字
>matchingIdentifiers : Type[]
>length : 数字
>类型别名 :=> 数字
>0 : 0

                    if (targetPosition > -1) {
>targetPosition > -1 : 真假
>类型别名 :=> 真假
>targetPosition : 数字
>类型别名 :=> 数字
>-1 : -1
>1 : 1

                        throw new Error("Could not find an identifier at position " + targetPosition);
>new Error("Could not find an identifier at position " + targetPosition) : Error
>Error : ErrorConstructor
>"Could not find an identifier at position " + targetPosition : 文字
>类型别名 :=> 文字
>"Could not find an identifier at position " : "Could not find an identifier at position "
>targetPosition : 数字
>类型别名 :=> 数字
                    }
                    else {
                        throw new Error("Could not find an identifier " + targetIdentifier + " in any known scopes");
>new Error("Could not find an identifier " + targetIdentifier + " in any known scopes") : Error
>Error : ErrorConstructor
>"Could not find an identifier " + targetIdentifier + " in any known scopes" : 文字
>类型别名 :=> 文字
>"Could not find an identifier " + targetIdentifier : 文字
>类型别名 :=> 文字
>"Could not find an identifier " : "Could not find an identifier "
>targetIdentifier : 文字
>类型别名 :=> 文字
>" in any known scopes" : " in any known scopes"
                    }
                }
                else if (matchingIdentifiers.length > 1) {
>matchingIdentifiers.length > 1 : 真假
>类型别名 :=> 真假
>matchingIdentifiers.length : 数字
>类型别名 :=> 数字
>matchingIdentifiers : Type[]
>length : 数字
>类型别名 :=> 数字
>1 : 1

                    throw new Error("Found multiple matching identifiers for " + target);
>new Error("Found multiple matching identifiers for " + target) : Error
>Error : ErrorConstructor
>"Found multiple matching identifiers for " + target : 文字
>类型别名 :=> 文字
>"Found multiple matching identifiers for " : "Found multiple matching identifiers for "
>target : 文字 | 数字
                }
                else {
                    return matchingIdentifiers[0];
>matchingIdentifiers[0] : Type
>matchingIdentifiers : Type[]
>0 : 0
                }
            }

            private getTypeInfoName(ast : TypeScript.AST) {
>getTypeInfoName : (ast: 任意) => 文字
>ast : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>AST : No type information available!

                var name = '';
>name : 文字
>类型别名 :=> 文字
>'' : ""

                switch (ast.nodeType) {
>ast.nodeType : 任意
>类型别名 :=> 任意
>ast : 任意
>类型别名 :=> 任意
>nodeType : 任意
>类型别名 :=> 任意

                    case TypeScript.NodeType.Name: // Type Name?
>TypeScript.NodeType.Name : 任意
>类型别名 :=> 任意
>TypeScript.NodeType : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>NodeType : 任意
>类型别名 :=> 任意
>Name : 任意
>类型别名 :=> 任意

                    case TypeScript.NodeType.Null:
>TypeScript.NodeType.Null : 任意
>类型别名 :=> 任意
>TypeScript.NodeType : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>NodeType : 任意
>类型别名 :=> 任意
>Null : 任意
>类型别名 :=> 任意

                    case TypeScript.NodeType.List:
>TypeScript.NodeType.List : 任意
>类型别名 :=> 任意
>TypeScript.NodeType : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>NodeType : 任意
>类型别名 :=> 任意
>List : 任意
>类型别名 :=> 任意

                    case TypeScript.NodeType.Empty:
>TypeScript.NodeType.Empty : 任意
>类型别名 :=> 任意
>TypeScript.NodeType : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>NodeType : 任意
>类型别名 :=> 任意
>Empty : 任意
>类型别名 :=> 任意

                    case TypeScript.NodeType.EmptyExpr:
>TypeScript.NodeType.EmptyExpr : 任意
>类型别名 :=> 任意
>TypeScript.NodeType : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>NodeType : 任意
>类型别名 :=> 任意
>EmptyExpr : 任意
>类型别名 :=> 任意

                    case TypeScript.NodeType.Asg:
>TypeScript.NodeType.Asg : 任意
>类型别名 :=> 任意
>TypeScript.NodeType : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>NodeType : 任意
>类型别名 :=> 任意
>Asg : 任意
>类型别名 :=> 任意

                    case TypeScript.NodeType.True:
>TypeScript.NodeType.True : 任意
>类型别名 :=> 任意
>TypeScript.NodeType : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>NodeType : 任意
>类型别名 :=> 任意
>True : 任意
>类型别名 :=> 任意

                    case TypeScript.NodeType.False:
>TypeScript.NodeType.False : 任意
>类型别名 :=> 任意
>TypeScript.NodeType : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>NodeType : 任意
>类型别名 :=> 任意
>False : 任意
>类型别名 :=> 任意

                    case TypeScript.NodeType.ArrayLit:
>TypeScript.NodeType.ArrayLit : 任意
>类型别名 :=> 任意
>TypeScript.NodeType : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>NodeType : 任意
>类型别名 :=> 任意
>ArrayLit : 任意
>类型别名 :=> 任意

                    case TypeScript.NodeType.TypeRef:
>TypeScript.NodeType.TypeRef : 任意
>类型别名 :=> 任意
>TypeScript.NodeType : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>NodeType : 任意
>类型别名 :=> 任意
>TypeRef : 任意
>类型别名 :=> 任意

                        break;
                    case TypeScript.NodeType.Super:
>TypeScript.NodeType.Super : 任意
>类型别名 :=> 任意
>TypeScript.NodeType : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>NodeType : 任意
>类型别名 :=> 任意
>Super : 任意
>类型别名 :=> 任意

                        name = (<any>ast).text;
>name = (<any>ast).text : 任意
>类型别名 :=> 任意
>name : 文字
>类型别名 :=> 文字
>(<any>ast).text : 任意
>类型别名 :=> 任意
>(<any>ast) : 任意
>类型别名 :=> 任意
><any>ast : 任意
>类型别名 :=> 任意
>ast : 任意
>类型别名 :=> 任意
>text : 任意
>类型别名 :=> 任意

                        break;
                    case TypeScript.NodeType.Regex:
>TypeScript.NodeType.Regex : 任意
>类型别名 :=> 任意
>TypeScript.NodeType : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>NodeType : 任意
>类型别名 :=> 任意
>Regex : 任意
>类型别名 :=> 任意

                        name = (<TypeScript.RegexLiteral>ast).text;
>name = (<TypeScript.RegexLiteral>ast).text : 任意
>类型别名 :=> 任意
>name : 文字
>类型别名 :=> 文字
>(<TypeScript.RegexLiteral>ast).text : 任意
>类型别名 :=> 任意
>(<TypeScript.RegexLiteral>ast) : 任意
>类型别名 :=> 任意
><TypeScript.RegexLiteral>ast : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>RegexLiteral : No type information available!
>ast : 任意
>类型别名 :=> 任意
>text : 任意
>类型别名 :=> 任意

                        break;
                    case TypeScript.NodeType.QString:
>TypeScript.NodeType.QString : 任意
>类型别名 :=> 任意
>TypeScript.NodeType : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>NodeType : 任意
>类型别名 :=> 任意
>QString : 任意
>类型别名 :=> 任意

                        name = (<any>ast).text;
>name = (<any>ast).text : 任意
>类型别名 :=> 任意
>name : 文字
>类型别名 :=> 文字
>(<any>ast).text : 任意
>类型别名 :=> 任意
>(<any>ast) : 任意
>类型别名 :=> 任意
><any>ast : 任意
>类型别名 :=> 任意
>ast : 任意
>类型别名 :=> 任意
>text : 任意
>类型别名 :=> 任意

                        break;
                    case TypeScript.NodeType.NumberLit:
>TypeScript.NodeType.NumberLit : 任意
>类型别名 :=> 任意
>TypeScript.NodeType : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>NodeType : 任意
>类型别名 :=> 任意
>NumberLit : 任意
>类型别名 :=> 任意

                        name = (<TypeScript.NumberLiteral>ast).text;
>name = (<TypeScript.NumberLiteral>ast).text : 任意
>类型别名 :=> 任意
>name : 文字
>类型别名 :=> 文字
>(<TypeScript.NumberLiteral>ast).text : 任意
>类型别名 :=> 任意
>(<TypeScript.NumberLiteral>ast) : 任意
>类型别名 :=> 任意
><TypeScript.NumberLiteral>ast : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>NumberLiteral : No type information available!
>ast : 任意
>类型别名 :=> 任意
>text : 任意
>类型别名 :=> 任意

                        break;
                    case TypeScript.NodeType.Return:
>TypeScript.NodeType.Return : 任意
>类型别名 :=> 任意
>TypeScript.NodeType : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>NodeType : 任意
>类型别名 :=> 任意
>Return : 任意
>类型别名 :=> 任意

                        //name = (<TypeScript.ReturnStatement>tyInfo.ast).returnExpression.actualText; // why is this complaining?
                        break;
                    case TypeScript.NodeType.InterfaceDeclaration:
>TypeScript.NodeType.InterfaceDeclaration : 任意
>类型别名 :=> 任意
>TypeScript.NodeType : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>NodeType : 任意
>类型别名 :=> 任意
>InterfaceDeclaration : 任意
>类型别名 :=> 任意

                        name = (<TypeScript.InterfaceDeclaration>ast).name.actualText;
>name = (<TypeScript.InterfaceDeclaration>ast).name.actualText : 任意
>类型别名 :=> 任意
>name : 文字
>类型别名 :=> 文字
>(<TypeScript.InterfaceDeclaration>ast).name.actualText : 任意
>类型别名 :=> 任意
>(<TypeScript.InterfaceDeclaration>ast).name : 任意
>类型别名 :=> 任意
>(<TypeScript.InterfaceDeclaration>ast) : 任意
>类型别名 :=> 任意
><TypeScript.InterfaceDeclaration>ast : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>InterfaceDeclaration : No type information available!
>ast : 任意
>类型别名 :=> 任意
>name : 任意
>类型别名 :=> 任意
>actualText : 任意
>类型别名 :=> 任意

                        break;
                    case TypeScript.NodeType.ModuleDeclaration:
>TypeScript.NodeType.ModuleDeclaration : 任意
>类型别名 :=> 任意
>TypeScript.NodeType : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>NodeType : 任意
>类型别名 :=> 任意
>ModuleDeclaration : 任意
>类型别名 :=> 任意

                        name = (<TypeScript.ModuleDeclaration>ast).name.actualText;
>name = (<TypeScript.ModuleDeclaration>ast).name.actualText : 任意
>类型别名 :=> 任意
>name : 文字
>类型别名 :=> 文字
>(<TypeScript.ModuleDeclaration>ast).name.actualText : 任意
>类型别名 :=> 任意
>(<TypeScript.ModuleDeclaration>ast).name : 任意
>类型别名 :=> 任意
>(<TypeScript.ModuleDeclaration>ast) : 任意
>类型别名 :=> 任意
><TypeScript.ModuleDeclaration>ast : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>ModuleDeclaration : No type information available!
>ast : 任意
>类型别名 :=> 任意
>name : 任意
>类型别名 :=> 任意
>actualText : 任意
>类型别名 :=> 任意

                        break;
                    case TypeScript.NodeType.ClassDeclaration:
>TypeScript.NodeType.ClassDeclaration : 任意
>类型别名 :=> 任意
>TypeScript.NodeType : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>NodeType : 任意
>类型别名 :=> 任意
>ClassDeclaration : 任意
>类型别名 :=> 任意

                        name = (<TypeScript.ClassDeclaration>ast).name.actualText;
>name = (<TypeScript.ClassDeclaration>ast).name.actualText : 任意
>类型别名 :=> 任意
>name : 文字
>类型别名 :=> 文字
>(<TypeScript.ClassDeclaration>ast).name.actualText : 任意
>类型别名 :=> 任意
>(<TypeScript.ClassDeclaration>ast).name : 任意
>类型别名 :=> 任意
>(<TypeScript.ClassDeclaration>ast) : 任意
>类型别名 :=> 任意
><TypeScript.ClassDeclaration>ast : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>ClassDeclaration : No type information available!
>ast : 任意
>类型别名 :=> 任意
>name : 任意
>类型别名 :=> 任意
>actualText : 任意
>类型别名 :=> 任意

                        break;
                    case TypeScript.NodeType.FuncDecl:
>TypeScript.NodeType.FuncDecl : 任意
>类型别名 :=> 任意
>TypeScript.NodeType : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>NodeType : 任意
>类型别名 :=> 任意
>FuncDecl : 任意
>类型别名 :=> 任意

                        name = !(<TypeScript.FuncDecl>ast).name ? "" : (<TypeScript.FuncDecl>ast).name.actualText; // name == null for lambdas
>name = !(<TypeScript.FuncDecl>ast).name ? "" : (<TypeScript.FuncDecl>ast).name.actualText : 任意
>类型别名 :=> 任意
>name : 文字
>类型别名 :=> 文字
>!(<TypeScript.FuncDecl>ast).name ? "" : (<TypeScript.FuncDecl>ast).name.actualText : 任意
>类型别名 :=> 任意
>!(<TypeScript.FuncDecl>ast).name : 真假
>类型别名 :=> 真假
>(<TypeScript.FuncDecl>ast).name : 任意
>类型别名 :=> 任意
>(<TypeScript.FuncDecl>ast) : 任意
>类型别名 :=> 任意
><TypeScript.FuncDecl>ast : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>FuncDecl : No type information available!
>ast : 任意
>类型别名 :=> 任意
>name : 任意
>类型别名 :=> 任意
>"" : ""
>(<TypeScript.FuncDecl>ast).name.actualText : 任意
>类型别名 :=> 任意
>(<TypeScript.FuncDecl>ast).name : 任意
>类型别名 :=> 任意
>(<TypeScript.FuncDecl>ast) : 任意
>类型别名 :=> 任意
><TypeScript.FuncDecl>ast : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>FuncDecl : No type information available!
>ast : 任意
>类型别名 :=> 任意
>name : 任意
>类型别名 :=> 任意
>actualText : 任意
>类型别名 :=> 任意

                        break;
                    default:
                        // TODO: is there a reason to mess with all the special cases above and not just do this (ie take whatever property is there and works?)
                        var a = <any>ast;
>a : 任意
>类型别名 :=> 任意
><any>ast : 任意
>类型别名 :=> 任意
>ast : 任意
>类型别名 :=> 任意

                        name = (a.id) ? (a.id.actualText) : (a.name) ? a.name.actualText : (a.text) ? a.text : '';
>name = (a.id) ? (a.id.actualText) : (a.name) ? a.name.actualText : (a.text) ? a.text : '' : 任意
>类型别名 :=> 任意
>name : 文字
>类型别名 :=> 文字
>(a.id) ? (a.id.actualText) : (a.name) ? a.name.actualText : (a.text) ? a.text : '' : 任意
>类型别名 :=> 任意
>(a.id) : 任意
>类型别名 :=> 任意
>a.id : 任意
>类型别名 :=> 任意
>a : 任意
>类型别名 :=> 任意
>id : 任意
>类型别名 :=> 任意
>(a.id.actualText) : 任意
>类型别名 :=> 任意
>a.id.actualText : 任意
>类型别名 :=> 任意
>a.id : 任意
>类型别名 :=> 任意
>a : 任意
>类型别名 :=> 任意
>id : 任意
>类型别名 :=> 任意
>actualText : 任意
>类型别名 :=> 任意
>(a.name) ? a.name.actualText : (a.text) ? a.text : '' : 任意
>类型别名 :=> 任意
>(a.name) : 任意
>类型别名 :=> 任意
>a.name : 任意
>类型别名 :=> 任意
>a : 任意
>类型别名 :=> 任意
>name : 任意
>类型别名 :=> 任意
>a.name.actualText : 任意
>类型别名 :=> 任意
>a.name : 任意
>类型别名 :=> 任意
>a : 任意
>类型别名 :=> 任意
>name : 任意
>类型别名 :=> 任意
>actualText : 任意
>类型别名 :=> 任意
>(a.text) ? a.text : '' : 任意
>类型别名 :=> 任意
>(a.text) : 任意
>类型别名 :=> 任意
>a.text : 任意
>类型别名 :=> 任意
>a : 任意
>类型别名 :=> 任意
>text : 任意
>类型别名 :=> 任意
>a.text : 任意
>类型别名 :=> 任意
>a : 任意
>类型别名 :=> 任意
>text : 任意
>类型别名 :=> 任意
>'' : ""

                        break;
                }

                return name;
>name : 文字
>类型别名 :=> 文字
            }

            public isOfType(expr: string, expectedType: string) {
>isOfType : (expr: 文字, expectedType: 文字) => 无值
>expr : 文字
>类型别名 :=> 文字
>expectedType : 文字
>类型别名 :=> 文字

                var actualType = this.get('var _v_a_r_ = ' + expr, '_v_a_r_');
>actualType : Type
>this.get('var _v_a_r_ = ' + expr, '_v_a_r_') : Type
>this.get : (code: 文字, target: 任意) => Type
>this : 本体
>get : (code: 文字, target: 任意) => Type
>'var _v_a_r_ = ' + expr : 文字
>类型别名 :=> 文字
>'var _v_a_r_ = ' : "var _v_a_r_ = "
>expr : 文字
>类型别名 :=> 文字
>'_v_a_r_' : "_v_a_r_"

                it('Expression "' + expr + '" is of type "' + expectedType + '"', function () {
>it('Expression "' + expr + '" is of type "' + expectedType + '"', function () {                    assert.equal(actualType.type, expectedType);                }) : 无值
>类型别名 :=> 无值
>it : (description: 文字, block: () => 无值) => 无值
>'Expression "' + expr + '" is of type "' + expectedType + '"' : 文字
>类型别名 :=> 文字
>'Expression "' + expr + '" is of type "' + expectedType : 文字
>类型别名 :=> 文字
>'Expression "' + expr + '" is of type "' : 文字
>类型别名 :=> 文字
>'Expression "' + expr : 文字
>类型别名 :=> 文字
>'Expression "' : "Expression \""
>expr : 文字
>类型别名 :=> 文字
>'" is of type "' : "\" is of type \""
>expectedType : 文字
>类型别名 :=> 文字
>'"' : "\""
>function () {                    assert.equal(actualType.type, expectedType);                } : () => 无值

                    assert.equal(actualType.type, expectedType);
>assert.equal(actualType.type, expectedType) : 任意
>类型别名 :=> 任意
>assert.equal : 任意
>类型别名 :=> 任意
>assert : 任意
>类型别名 :=> 任意
>equal : 任意
>类型别名 :=> 任意
>actualType.type : 任意
>类型别名 :=> 任意
>actualType : Type
>type : 任意
>类型别名 :=> 任意
>expectedType : 文字
>类型别名 :=> 文字

                });
            }
        }

        /** Generates a .d.ts file for the given code
          * @param verifyNoDeclFile pass true when the given code should generate no decl file, false otherwise
          * @param unitName add the given code under thie name, else use '0.ts'
          * @param compilationContext a set of functions to be run before and after compiling this code for doing things like adding dependencies first
          * @param references the set of referenced files used by the given code
          */
        export function generateDeclFile(code: string, verifyNoDeclFile: boolean, unitName?: string, compilationContext?: Harness.Compiler.CompilationContext, references?: TypeScript.IFileReference[]): string {
>generateDeclFile : (code: 文字, verifyNoDeclFile: 真假, unitName?: 文字, compilationContext?: CompilationContext, references?: 任意[]) => 文字
>code : 文字
>类型别名 :=> 文字
>verifyNoDeclFile : 真假
>类型别名 :=> 真假
>unitName : 文字
>类型别名 :=> 文字
>compilationContext : CompilationContext
>Harness : 任意
>类型别名 :=> 任意
>Compiler : 任意
>类型别名 :=> 任意
>CompilationContext : CompilationContext
>references : 任意[]
>TypeScript : 任意
>类型别名 :=> 任意
>IFileReference : No type information available!

            reset();
>reset() : 无值
>类型别名 :=> 无值
>reset : () => 无值

            compiler.settings.generateDeclarationFiles = true;
>compiler.settings.generateDeclarationFiles = true : 为真
>类型别名 :=> 为真
>compiler.settings.generateDeclarationFiles : 任意
>类型别名 :=> 任意
>compiler.settings : 任意
>类型别名 :=> 任意
>compiler : 任意
>类型别名 :=> 任意
>settings : 任意
>类型别名 :=> 任意
>generateDeclarationFiles : 任意
>类型别名 :=> 任意
>true : 为真
>类型别名 :=> 为真

            var oldOutputOption = compiler.settings.outputOption;
>oldOutputOption : 任意
>类型别名 :=> 任意
>compiler.settings.outputOption : 任意
>类型别名 :=> 任意
>compiler.settings : 任意
>类型别名 :=> 任意
>compiler : 任意
>类型别名 :=> 任意
>settings : 任意
>类型别名 :=> 任意
>outputOption : 任意
>类型别名 :=> 任意

            var oldEmitterIOHost = compiler.emitSettings.ioHost;
>oldEmitterIOHost : 任意
>类型别名 :=> 任意
>compiler.emitSettings.ioHost : 任意
>类型别名 :=> 任意
>compiler.emitSettings : 任意
>类型别名 :=> 任意
>compiler : 任意
>类型别名 :=> 任意
>emitSettings : 任意
>类型别名 :=> 任意
>ioHost : 任意
>类型别名 :=> 任意

            try {
                if (compilationContext && compilationContext.preCompile) {
>compilationContext && compilationContext.preCompile : () => 无值
>compilationContext : CompilationContext
>compilationContext.preCompile : () => 无值
>compilationContext : CompilationContext
>preCompile : () => 无值

                    compilationContext.preCompile();
>compilationContext.preCompile() : 无值
>类型别名 :=> 无值
>compilationContext.preCompile : () => 无值
>compilationContext : CompilationContext
>preCompile : () => 无值
                }

                addUnit(code, unitName, false, false, references);
>addUnit(code, unitName, false, false, references) : 任意
>类型别名 :=> 任意
>addUnit : (code: 文字, unitName?: 文字, isResident?: 真假, isDeclareFile?: 真假, references?: 任意[]) => 任意
>code : 文字
>类型别名 :=> 文字
>unitName : 文字
>类型别名 :=> 文字
>false : 为假
>类型别名 :=> 为假
>false : 为假
>类型别名 :=> 为假
>references : 任意[]

                compiler.reTypeCheck();
>compiler.reTypeCheck() : 任意
>类型别名 :=> 任意
>compiler.reTypeCheck : 任意
>类型别名 :=> 任意
>compiler : 任意
>类型别名 :=> 任意
>reTypeCheck : 任意
>类型别名 :=> 任意

                var outputs = {};
>outputs : {}
>{} : {}

                compiler.settings.outputOption = "";
>compiler.settings.outputOption = "" : ""
>compiler.settings.outputOption : 任意
>类型别名 :=> 任意
>compiler.settings : 任意
>类型别名 :=> 任意
>compiler : 任意
>类型别名 :=> 任意
>settings : 任意
>类型别名 :=> 任意
>outputOption : 任意
>类型别名 :=> 任意
>"" : ""

                compiler.parseEmitOption(
>compiler.parseEmitOption(                    {                        createFile: (fn: string) => {                            outputs[fn] = new Harness.Compiler.WriterAggregator();                            return outputs[fn];                        },                        directoryExists: (path: string) => true,                        fileExists: (path: string) => true,                        resolvePath: (path: string) => path                    }) : 任意
>类型别名 :=> 任意
>compiler.parseEmitOption : 任意
>类型别名 :=> 任意
>compiler : 任意
>类型别名 :=> 任意
>parseEmitOption : 任意
>类型别名 :=> 任意
                    {
>{                        createFile: (fn: string) => {                            outputs[fn] = new Harness.Compiler.WriterAggregator();                            return outputs[fn];                        },                        directoryExists: (path: string) => true,                        fileExists: (path: string) => true,                        resolvePath: (path: string) => path                    } : { createFile: (fn: 文字) => 任意; directoryExists: (path: 文字) => 真假; fileExists: (path: 文字) => 真假; resolvePath: (path: 文字) => 文字; }

                        createFile: (fn: string) => {
>createFile : (fn: 文字) => 任意
>(fn: string) => {                            outputs[fn] = new Harness.Compiler.WriterAggregator();                            return outputs[fn];                        } : (fn: 文字) => 任意
>fn : 文字
>类型别名 :=> 文字

                            outputs[fn] = new Harness.Compiler.WriterAggregator();
>outputs[fn] = new Harness.Compiler.WriterAggregator() : WriterAggregator
>outputs[fn] : 任意
>类型别名 :=> 任意
>outputs : {}
>fn : 文字
>类型别名 :=> 文字
>new Harness.Compiler.WriterAggregator() : WriterAggregator
>Harness.Compiler.WriterAggregator : 类为 WriterAggregator
>Harness.Compiler : 类为 Compiler
>Harness : 类为 Harness
>Compiler : 类为 Compiler
>WriterAggregator : 类为 WriterAggregator

                            return outputs[fn];
>outputs[fn] : 任意
>类型别名 :=> 任意
>outputs : {}
>fn : 文字
>类型别名 :=> 文字

                        },
                        directoryExists: (path: string) => true,
>directoryExists : (path: 文字) => 真假
>(path: string) => true : (path: 文字) => 真假
>path : 文字
>类型别名 :=> 文字
>true : 为真
>类型别名 :=> 为真

                        fileExists: (path: string) => true,
>fileExists : (path: 文字) => 真假
>(path: string) => true : (path: 文字) => 真假
>path : 文字
>类型别名 :=> 文字
>true : 为真
>类型别名 :=> 为真

                        resolvePath: (path: string) => path
>resolvePath : (path: 文字) => 文字
>(path: string) => path : (path: 文字) => 文字
>path : 文字
>类型别名 :=> 文字
>path : 文字
>类型别名 :=> 文字

                    });
                compiler.emitDeclarations();
>compiler.emitDeclarations() : 任意
>类型别名 :=> 任意
>compiler.emitDeclarations : 任意
>类型别名 :=> 任意
>compiler : 任意
>类型别名 :=> 任意
>emitDeclarations : 任意
>类型别名 :=> 任意

                var results: string = null;
>results : 文字
>类型别名 :=> 文字
>null : 空值
>类型别名 :=> 空值

                for (var fn in outputs) {
>fn : 文字
>类型别名 :=> 文字
>outputs : {}

                    if (fn.indexOf('.d.ts') >= 0) {
>fn.indexOf('.d.ts') >= 0 : 真假
>类型别名 :=> 真假
>fn.indexOf('.d.ts') : 数字
>类型别名 :=> 数字
>fn.indexOf : (searchString: 文字, position?: 数字) => 数字
>fn : 文字
>类型别名 :=> 文字
>indexOf : (searchString: 文字, position?: 数字) => 数字
>'.d.ts' : ".d.ts"
>0 : 0

                        var writer = <Harness.Compiler.WriterAggregator>outputs[fn];
>writer : WriterAggregator
><Harness.Compiler.WriterAggregator>outputs[fn] : WriterAggregator
>Harness : 任意
>类型别名 :=> 任意
>Compiler : 任意
>类型别名 :=> 任意
>WriterAggregator : WriterAggregator
>outputs[fn] : 任意
>类型别名 :=> 任意
>outputs : {}
>fn : 文字
>类型别名 :=> 文字

                        writer.Close();
>writer.Close() : 无值
>类型别名 :=> 无值
>writer.Close : () => 无值
>writer : WriterAggregator
>Close : () => 无值

                        results = writer.lines.join('\n');
>results = writer.lines.join('\n') : 文字
>类型别名 :=> 文字
>results : 文字
>类型别名 :=> 文字
>writer.lines.join('\n') : 文字
>类型别名 :=> 文字
>writer.lines.join : (separator?: 文字) => 文字
>writer.lines : 文字[]
>writer : WriterAggregator
>lines : 文字[]
>join : (separator?: 文字) => 文字
>'\n' : "\n"

                        if (verifyNoDeclFile && results != "") {
>verifyNoDeclFile && results != "" : 真假
>类型别名 :=> 真假
>verifyNoDeclFile : 真假
>类型别名 :=> 真假
>results != "" : 真假
>类型别名 :=> 真假
>results : 文字
>类型别名 :=> 文字
>"" : ""

                            throw new Error('Compilation should not produce ' + fn);
>new Error('Compilation should not produce ' + fn) : Error
>Error : ErrorConstructor
>'Compilation should not produce ' + fn : 文字
>类型别名 :=> 文字
>'Compilation should not produce ' : "Compilation should not produce "
>fn : 文字
>类型别名 :=> 文字
                        }
                    }
                }

                if (results) {
>results : 文字
>类型别名 :=> 文字

                    return results;
>results : 文字
>类型别名 :=> 文字
                }

                if (!verifyNoDeclFile) {
>!verifyNoDeclFile : 真假
>类型别名 :=> 真假
>verifyNoDeclFile : 真假
>类型别名 :=> 真假

                    throw new Error('Compilation did not produce .d.ts files');
>new Error('Compilation did not produce .d.ts files') : Error
>Error : ErrorConstructor
>'Compilation did not produce .d.ts files' : "Compilation did not produce .d.ts files"
                }
            } finally {
                compiler.settings.generateDeclarationFiles = false;
>compiler.settings.generateDeclarationFiles = false : 为假
>类型别名 :=> 为假
>compiler.settings.generateDeclarationFiles : 任意
>类型别名 :=> 任意
>compiler.settings : 任意
>类型别名 :=> 任意
>compiler : 任意
>类型别名 :=> 任意
>settings : 任意
>类型别名 :=> 任意
>generateDeclarationFiles : 任意
>类型别名 :=> 任意
>false : 为假
>类型别名 :=> 为假

                compiler.settings.outputOption = oldOutputOption;
>compiler.settings.outputOption = oldOutputOption : 任意
>类型别名 :=> 任意
>compiler.settings.outputOption : 任意
>类型别名 :=> 任意
>compiler.settings : 任意
>类型别名 :=> 任意
>compiler : 任意
>类型别名 :=> 任意
>settings : 任意
>类型别名 :=> 任意
>outputOption : 任意
>类型别名 :=> 任意
>oldOutputOption : 任意
>类型别名 :=> 任意

                compiler.parseEmitOption(oldEmitterIOHost);
>compiler.parseEmitOption(oldEmitterIOHost) : 任意
>类型别名 :=> 任意
>compiler.parseEmitOption : 任意
>类型别名 :=> 任意
>compiler : 任意
>类型别名 :=> 任意
>parseEmitOption : 任意
>类型别名 :=> 任意
>oldEmitterIOHost : 任意
>类型别名 :=> 任意

                if (compilationContext && compilationContext.postCompile) {
>compilationContext && compilationContext.postCompile : () => 无值
>compilationContext : CompilationContext
>compilationContext.postCompile : () => 无值
>compilationContext : CompilationContext
>postCompile : () => 无值

                    compilationContext.postCompile();
>compilationContext.postCompile() : 无值
>类型别名 :=> 无值
>compilationContext.postCompile : () => 无值
>compilationContext : CompilationContext
>postCompile : () => 无值
                }

                var uName = unitName || '0.ts';
>uName : 文字
>类型别名 :=> 文字
>unitName || '0.ts' : 文字
>类型别名 :=> 文字
>unitName : 文字
>类型别名 :=> 文字
>'0.ts' : "0.ts"

                updateUnit('', uName);
>updateUnit('', uName) : 无值
>类型别名 :=> 无值
>updateUnit : (code: 文字, unitName: 文字, setRecovery?: 真假) => 无值
>'' : ""
>uName : 文字
>类型别名 :=> 文字
            }

            return '';
>'' : ""
        }

        /** Contains the code and errors of a compilation and some helper methods to check its status. */
        export class CompilerResult {
>CompilerResult : CompilerResult

            public code: string;
>code : 文字
>类型别名 :=> 文字

            public errors: CompilerError[];
>errors : CompilerError[]
>CompilerError : CompilerError

            /** @param fileResults an array of strings for the filename and an ITextWriter with its code */
            constructor(public fileResults: { filename: string; file: WriterAggregator; }[], errorLines: string[], public scripts: TypeScript.Script[]) {
>fileResults : { filename: 文字; file: WriterAggregator; }[]
>filename : 文字
>类型别名 :=> 文字
>file : WriterAggregator
>WriterAggregator : WriterAggregator
>errorLines : 文字[]
>scripts : 任意[]
>TypeScript : 任意
>类型别名 :=> 任意
>Script : No type information available!

                var lines = [];
>lines : 任意[]
>[] : 未定[]

                fileResults.forEach(v => lines = lines.concat(v.file.lines));
>fileResults.forEach(v => lines = lines.concat(v.file.lines)) : 无值
>类型别名 :=> 无值
>fileResults.forEach : (callbackfn: (value: { filename: 文字; file: WriterAggregator; }, index: 数字, array: { filename: 文字; file: WriterAggregator; }[]) => 无值, thisArg?: 任意) => 无值
>fileResults : { filename: 文字; file: WriterAggregator; }[]
>forEach : (callbackfn: (value: { filename: 文字; file: WriterAggregator; }, index: 数字, array: { filename: 文字; file: WriterAggregator; }[]) => 无值, thisArg?: 任意) => 无值
>v => lines = lines.concat(v.file.lines) : (v: { filename: 文字; file: WriterAggregator; }) => 任意[]
>v : { filename: 文字; file: WriterAggregator; }
>lines = lines.concat(v.file.lines) : 任意[]
>lines : 任意[]
>lines.concat(v.file.lines) : 任意[]
>lines.concat : { (...items: ReadonlyArray<任意>[]): 任意[]; (...items: 任意[]): 任意[]; }
>lines : 任意[]
>concat : { (...items: ReadonlyArray<任意>[]): 任意[]; (...items: 任意[]): 任意[]; }
>v.file.lines : 文字[]
>v.file : WriterAggregator
>v : { filename: 文字; file: WriterAggregator; }
>file : WriterAggregator
>lines : 文字[]

                this.code = lines.join("\n")
>this.code = lines.join("\n") : 文字
>类型别名 :=> 文字
>this.code : 文字
>类型别名 :=> 文字
>this : 本体
>code : 文字
>类型别名 :=> 文字
>lines.join("\n") : 文字
>类型别名 :=> 文字
>lines.join : (separator?: 文字) => 文字
>lines : 任意[]
>join : (separator?: 文字) => 文字
>"\n" : "\n"

                this.errors = [];
>this.errors = [] : 未定[]
>this.errors : CompilerError[]
>this : 本体
>errors : CompilerError[]
>[] : 未定[]

                for (var i = 0; i < errorLines.length; i++) {
>i : 数字
>类型别名 :=> 数字
>0 : 0
>i < errorLines.length : 真假
>类型别名 :=> 真假
>i : 数字
>类型别名 :=> 数字
>errorLines.length : 数字
>类型别名 :=> 数字
>errorLines : 文字[]
>length : 数字
>类型别名 :=> 数字
>i++ : 数字
>类型别名 :=> 数字
>i : 数字
>类型别名 :=> 数字

                    if (Harness.usePull) {
>Harness.usePull : 真假
>类型别名 :=> 真假
>Harness : 类为 Harness
>usePull : 真假
>类型别名 :=> 真假

                        var err = <any>errorLines[i]; // TypeScript.PullError
>err : 任意
>类型别名 :=> 任意
><any>errorLines[i] : 任意
>类型别名 :=> 任意
>errorLines[i] : 文字
>类型别名 :=> 文字
>errorLines : 文字[]
>i : 数字
>类型别名 :=> 数字

                        this.errors.push(new CompilerError(err.filename, 0, 0, err.message));
>this.errors.push(new CompilerError(err.filename, 0, 0, err.message)) : 数字
>类型别名 :=> 数字
>this.errors.push : (...items: CompilerError[]) => 数字
>this.errors : CompilerError[]
>this : 本体
>errors : CompilerError[]
>push : (...items: CompilerError[]) => 数字
>new CompilerError(err.filename, 0, 0, err.message) : CompilerError
>CompilerError : 类为 CompilerError
>err.filename : 任意
>类型别名 :=> 任意
>err : 任意
>类型别名 :=> 任意
>filename : 任意
>类型别名 :=> 任意
>0 : 0
>0 : 0
>err.message : 任意
>类型别名 :=> 任意
>err : 任意
>类型别名 :=> 任意
>message : 任意
>类型别名 :=> 任意

                    } else {
                        var match = errorLines[i].match(/([^\(]*)\((\d+),(\d+)\):\s+((.*[\s\r\n]*.*)+)\s*$/);
>match : RegExpMatchArray
>errorLines[i].match(/([^\(]*)\((\d+),(\d+)\):\s+((.*[\s\r\n]*.*)+)\s*$/) : RegExpMatchArray
>errorLines[i].match : (regexp: 文字 | RegExp) => RegExpMatchArray
>errorLines[i] : 文字
>类型别名 :=> 文字
>errorLines : 文字[]
>i : 数字
>类型别名 :=> 数字
>match : (regexp: 文字 | RegExp) => RegExpMatchArray
>/([^\(]*)\((\d+),(\d+)\):\s+((.*[\s\r\n]*.*)+)\s*$/ : RegExp

                        if (match) {
>match : RegExpMatchArray

                            this.errors.push(new CompilerError(match[1], parseFloat(match[2]), parseFloat(match[3]), match[4]));
>this.errors.push(new CompilerError(match[1], parseFloat(match[2]), parseFloat(match[3]), match[4])) : 数字
>类型别名 :=> 数字
>this.errors.push : (...items: CompilerError[]) => 数字
>this.errors : CompilerError[]
>this : 本体
>errors : CompilerError[]
>push : (...items: CompilerError[]) => 数字
>new CompilerError(match[1], parseFloat(match[2]), parseFloat(match[3]), match[4]) : CompilerError
>CompilerError : 类为 CompilerError
>match[1] : 文字
>类型别名 :=> 文字
>match : RegExpMatchArray
>1 : 1
>parseFloat(match[2]) : 数字
>类型别名 :=> 数字
>parseFloat : (string: 文字) => 数字
>match[2] : 文字
>类型别名 :=> 文字
>match : RegExpMatchArray
>2 : 2
>parseFloat(match[3]) : 数字
>类型别名 :=> 数字
>parseFloat : (string: 文字) => 数字
>match[3] : 文字
>类型别名 :=> 文字
>match : RegExpMatchArray
>3 : 3
>match[4] : 文字
>类型别名 :=> 文字
>match : RegExpMatchArray
>4 : 4
                        }
                        else {
                            WScript.Echo("non-match on: " + errorLines[i]);
>WScript.Echo("non-match on: " + errorLines[i]) : 任意
>类型别名 :=> 任意
>WScript.Echo : 任意
>类型别名 :=> 任意
>WScript : 任意
>类型别名 :=> 任意
>Echo : 任意
>类型别名 :=> 任意
>"non-match on: " + errorLines[i] : 文字
>类型别名 :=> 文字
>"non-match on: " : "non-match on: "
>errorLines[i] : 文字
>类型别名 :=> 文字
>errorLines : 文字[]
>i : 数字
>类型别名 :=> 数字
                        }
                    }
                }
            }

            public isErrorAt(line: number, column: number, message: string) {
>isErrorAt : (line: 数字, column: 数字, message: 文字) => 真假
>line : 数字
>类型别名 :=> 数字
>column : 数字
>类型别名 :=> 数字
>message : 文字
>类型别名 :=> 文字

                for (var i = 0; i < this.errors.length; i++) {
>i : 数字
>类型别名 :=> 数字
>0 : 0
>i < this.errors.length : 真假
>类型别名 :=> 真假
>i : 数字
>类型别名 :=> 数字
>this.errors.length : 数字
>类型别名 :=> 数字
>this.errors : CompilerError[]
>this : 本体
>errors : CompilerError[]
>length : 数字
>类型别名 :=> 数字
>i++ : 数字
>类型别名 :=> 数字
>i : 数字
>类型别名 :=> 数字

                    if (this.errors[i].line === line && this.errors[i].column === column && this.errors[i].message === message)
>this.errors[i].line === line && this.errors[i].column === column && this.errors[i].message === message : 真假
>类型别名 :=> 真假
>this.errors[i].line === line && this.errors[i].column === column : 真假
>类型别名 :=> 真假
>this.errors[i].line === line : 真假
>类型别名 :=> 真假
>this.errors[i].line : 数字
>类型别名 :=> 数字
>this.errors[i] : CompilerError
>this.errors : CompilerError[]
>this : 本体
>errors : CompilerError[]
>i : 数字
>类型别名 :=> 数字
>line : 数字
>类型别名 :=> 数字
>line : 数字
>类型别名 :=> 数字
>this.errors[i].column === column : 真假
>类型别名 :=> 真假
>this.errors[i].column : 数字
>类型别名 :=> 数字
>this.errors[i] : CompilerError
>this.errors : CompilerError[]
>this : 本体
>errors : CompilerError[]
>i : 数字
>类型别名 :=> 数字
>column : 数字
>类型别名 :=> 数字
>column : 数字
>类型别名 :=> 数字
>this.errors[i].message === message : 真假
>类型别名 :=> 真假
>this.errors[i].message : 文字
>类型别名 :=> 文字
>this.errors[i] : CompilerError
>this.errors : CompilerError[]
>this : 本体
>errors : CompilerError[]
>i : 数字
>类型别名 :=> 数字
>message : 文字
>类型别名 :=> 文字
>message : 文字
>类型别名 :=> 文字

                        return true;
>true : 为真
>类型别名 :=> 为真
                }

                return false;
>false : 为假
>类型别名 :=> 为假
            }
        }

        // Compiler Error.
        export class CompilerError {
>CompilerError : CompilerError

            constructor(public file: string,
>file : 文字
>类型别名 :=> 文字

                    public line: number,
>line : 数字
>类型别名 :=> 数字

                    public column: number,
>column : 数字
>类型别名 :=> 数字

                    public message: string) { }
>message : 文字
>类型别名 :=> 文字

            public toString() {
>toString : () => 文字

                return this.file + "(" + this.line + "," + this.column + "): " + this.message;
>this.file + "(" + this.line + "," + this.column + "): " + this.message : 文字
>类型别名 :=> 文字
>this.file + "(" + this.line + "," + this.column + "): " : 文字
>类型别名 :=> 文字
>this.file + "(" + this.line + "," + this.column : 文字
>类型别名 :=> 文字
>this.file + "(" + this.line + "," : 文字
>类型别名 :=> 文字
>this.file + "(" + this.line : 文字
>类型别名 :=> 文字
>this.file + "(" : 文字
>类型别名 :=> 文字
>this.file : 文字
>类型别名 :=> 文字
>this : 本体
>file : 文字
>类型别名 :=> 文字
>"(" : "("
>this.line : 数字
>类型别名 :=> 数字
>this : 本体
>line : 数字
>类型别名 :=> 数字
>"," : ","
>this.column : 数字
>类型别名 :=> 数字
>this : 本体
>column : 数字
>类型别名 :=> 数字
>"): " : "): "
>this.message : 文字
>类型别名 :=> 文字
>this : 本体
>message : 文字
>类型别名 :=> 文字
            }
        }

        /** Create a new instance of the compiler with default settings and lib.d.ts, then typecheck */
        export function recreate() {
>recreate : () => 无值

            compiler = makeDefaultCompilerForTest();
>compiler = makeDefaultCompilerForTest() : 任意
>类型别名 :=> 任意
>compiler : 任意
>类型别名 :=> 任意
>makeDefaultCompilerForTest() : 任意
>类型别名 :=> 任意
>makeDefaultCompilerForTest : (c?: 任意) => 任意

            if (usePull) {
>usePull : 真假
>类型别名 :=> 真假

                compiler.pullTypeCheck(true);
>compiler.pullTypeCheck(true) : 任意
>类型别名 :=> 任意
>compiler.pullTypeCheck : 任意
>类型别名 :=> 任意
>compiler : 任意
>类型别名 :=> 任意
>pullTypeCheck : 任意
>类型别名 :=> 任意
>true : 为真
>类型别名 :=> 为真
            }
            else {
                compiler.typeCheck();
>compiler.typeCheck() : 任意
>类型别名 :=> 任意
>compiler.typeCheck : 任意
>类型别名 :=> 任意
>compiler : 任意
>类型别名 :=> 任意
>typeCheck : 任意
>类型别名 :=> 任意
            }
        }

        export function reset() {
>reset : () => 无值

            stdout.reset();
>stdout.reset() : 无值
>类型别名 :=> 无值
>stdout.reset : () => 无值
>stdout : EmitterIOHost
>reset : () => 无值

            stderr.reset();
>stderr.reset() : 无值
>类型别名 :=> 无值
>stderr.reset : () => 无值
>stderr : WriterAggregator
>reset : () => 无值

            var files = compiler.units.map((value) => value.filename);
>files : 任意
>类型别名 :=> 任意
>compiler.units.map((value) => value.filename) : 任意
>类型别名 :=> 任意
>compiler.units.map : 任意
>类型别名 :=> 任意
>compiler.units : 任意
>类型别名 :=> 任意
>compiler : 任意
>类型别名 :=> 任意
>units : 任意
>类型别名 :=> 任意
>map : 任意
>类型别名 :=> 任意
>(value) => value.filename : (value: 任意) => 任意
>value : 任意
>类型别名 :=> 任意
>value.filename : 任意
>类型别名 :=> 任意
>value : 任意
>类型别名 :=> 任意
>filename : 任意
>类型别名 :=> 任意

            for (var i = 0; i < files.length; i++) {
>i : 数字
>类型别名 :=> 数字
>0 : 0
>i < files.length : 真假
>类型别名 :=> 真假
>i : 数字
>类型别名 :=> 数字
>files.length : 任意
>类型别名 :=> 任意
>files : 任意
>类型别名 :=> 任意
>length : 任意
>类型别名 :=> 任意
>i++ : 数字
>类型别名 :=> 数字
>i : 数字
>类型别名 :=> 数字

                var fname = files[i];
>fname : 任意
>类型别名 :=> 任意
>files[i] : 任意
>类型别名 :=> 任意
>files : 任意
>类型别名 :=> 任意
>i : 数字
>类型别名 :=> 数字

                if(fname !== 'lib.d.ts') {
>fname !== 'lib.d.ts' : 真假
>类型别名 :=> 真假
>fname : 任意
>类型别名 :=> 任意
>'lib.d.ts' : "lib.d.ts"

                    updateUnit('', fname);
>updateUnit('', fname) : 无值
>类型别名 :=> 无值
>updateUnit : (code: 文字, unitName: 文字, setRecovery?: 真假) => 无值
>'' : ""
>fname : 任意
>类型别名 :=> 任意
                    }
            }

            compiler.errorReporter.hasErrors = false;
>compiler.errorReporter.hasErrors = false : 为假
>类型别名 :=> 为假
>compiler.errorReporter.hasErrors : 任意
>类型别名 :=> 任意
>compiler.errorReporter : 任意
>类型别名 :=> 任意
>compiler : 任意
>类型别名 :=> 任意
>errorReporter : 任意
>类型别名 :=> 任意
>hasErrors : 任意
>类型别名 :=> 任意
>false : 为假
>类型别名 :=> 为假
        }

        // Defines functions to invoke before compiling a piece of code and a post compile action intended to clean up the
        // effects of preCompile, preferably with something lighter weight than a full recreate()
        export interface CompilationContext {
>CompilationContext : CompilationContext

            filename: string;
>filename : 文字
>类型别名 :=> 文字

            preCompile: () => void;
>preCompile : () => 无值

            postCompile: () => void;
>postCompile : () => 无值
        }

        export function addUnit(code: string, unitName?: string, isResident?: boolean, isDeclareFile?: boolean, references?: TypeScript.IFileReference[]) {
>addUnit : (code: 文字, unitName?: 文字, isResident?: 真假, isDeclareFile?: 真假, references?: 任意[]) => 任意
>code : 文字
>类型别名 :=> 文字
>unitName : 文字
>类型别名 :=> 文字
>isResident : 真假
>类型别名 :=> 真假
>isDeclareFile : 真假
>类型别名 :=> 真假
>references : 任意[]
>TypeScript : 任意
>类型别名 :=> 任意
>IFileReference : No type information available!

            var script: TypeScript.Script = null;
>script : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>Script : No type information available!
>null : 空值
>类型别名 :=> 空值

            var uName = unitName || '0' + (isDeclareFile ? '.d.ts' : '.ts');
>uName : 文字
>类型别名 :=> 文字
>unitName || '0' + (isDeclareFile ? '.d.ts' : '.ts') : 文字
>类型别名 :=> 文字
>unitName : 文字
>类型别名 :=> 文字
>'0' + (isDeclareFile ? '.d.ts' : '.ts') : 文字
>类型别名 :=> 文字
>'0' : "0"
>(isDeclareFile ? '.d.ts' : '.ts') : ".d.ts" | ".ts"
>isDeclareFile ? '.d.ts' : '.ts' : ".d.ts" | ".ts"
>isDeclareFile : 真假
>类型别名 :=> 真假
>'.d.ts' : ".d.ts"
>'.ts' : ".ts"

            for (var i = 0; i < compiler.units.length; i++) {
>i : 数字
>类型别名 :=> 数字
>0 : 0
>i < compiler.units.length : 真假
>类型别名 :=> 真假
>i : 数字
>类型别名 :=> 数字
>compiler.units.length : 任意
>类型别名 :=> 任意
>compiler.units : 任意
>类型别名 :=> 任意
>compiler : 任意
>类型别名 :=> 任意
>units : 任意
>类型别名 :=> 任意
>length : 任意
>类型别名 :=> 任意
>i++ : 数字
>类型别名 :=> 数字
>i : 数字
>类型别名 :=> 数字

                if (compiler.units[i].filename === uName) {
>compiler.units[i].filename === uName : 真假
>类型别名 :=> 真假
>compiler.units[i].filename : 任意
>类型别名 :=> 任意
>compiler.units[i] : 任意
>类型别名 :=> 任意
>compiler.units : 任意
>类型别名 :=> 任意
>compiler : 任意
>类型别名 :=> 任意
>units : 任意
>类型别名 :=> 任意
>i : 数字
>类型别名 :=> 数字
>filename : 任意
>类型别名 :=> 任意
>uName : 文字
>类型别名 :=> 文字

                    updateUnit(code, uName);
>updateUnit(code, uName) : 无值
>类型别名 :=> 无值
>updateUnit : (code: 文字, unitName: 文字, setRecovery?: 真假) => 无值
>code : 文字
>类型别名 :=> 文字
>uName : 文字
>类型别名 :=> 文字

                    script = <TypeScript.Script>compiler.scripts.members[i];
>script = <TypeScript.Script>compiler.scripts.members[i] : 任意
>类型别名 :=> 任意
>script : 任意
>类型别名 :=> 任意
><TypeScript.Script>compiler.scripts.members[i] : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>Script : No type information available!
>compiler.scripts.members[i] : 任意
>类型别名 :=> 任意
>compiler.scripts.members : 任意
>类型别名 :=> 任意
>compiler.scripts : 任意
>类型别名 :=> 任意
>compiler : 任意
>类型别名 :=> 任意
>scripts : 任意
>类型别名 :=> 任意
>members : 任意
>类型别名 :=> 任意
>i : 数字
>类型别名 :=> 数字
                }
            }
            if (!script) {
>!script : 真假
>类型别名 :=> 真假
>script : 任意
>类型别名 :=> 任意

                // TODO: make this toggleable, shouldn't be necessary once typecheck bugs are cleaned up
                // but without it subsequent tests are treated as edits, making for somewhat useful stress testing
                // of persistent typecheck state
                //compiler.addUnit("", uName, isResident, references); // equivalent to compiler.deleteUnit(...)
                script = compiler.addUnit(code, uName, isResident, references);
>script = compiler.addUnit(code, uName, isResident, references) : 任意
>类型别名 :=> 任意
>script : 任意
>类型别名 :=> 任意
>compiler.addUnit(code, uName, isResident, references) : 任意
>类型别名 :=> 任意
>compiler.addUnit : 任意
>类型别名 :=> 任意
>compiler : 任意
>类型别名 :=> 任意
>addUnit : 任意
>类型别名 :=> 任意
>code : 文字
>类型别名 :=> 文字
>uName : 文字
>类型别名 :=> 文字
>isResident : 真假
>类型别名 :=> 真假
>references : 任意[]

                needsFullTypeCheck = true;
>needsFullTypeCheck = true : 为真
>类型别名 :=> 为真
>needsFullTypeCheck : 真假
>类型别名 :=> 真假
>true : 为真
>类型别名 :=> 为真
            }

            return script;
>script : 任意
>类型别名 :=> 任意
        }

        export function updateUnit(code: string, unitName: string, setRecovery?: boolean) {
>updateUnit : (code: 文字, unitName: 文字, setRecovery?: 真假) => 无值
>code : 文字
>类型别名 :=> 文字
>unitName : 文字
>类型别名 :=> 文字
>setRecovery : 真假
>类型别名 :=> 真假

            if (Harness.usePull) {
>Harness.usePull : 真假
>类型别名 :=> 真假
>Harness : 类为 Harness
>usePull : 真假
>类型别名 :=> 真假

                compiler.pullUpdateUnit(new TypeScript.StringSourceText(code), unitName, setRecovery);
>compiler.pullUpdateUnit(new TypeScript.StringSourceText(code), unitName, setRecovery) : 任意
>类型别名 :=> 任意
>compiler.pullUpdateUnit : 任意
>类型别名 :=> 任意
>compiler : 任意
>类型别名 :=> 任意
>pullUpdateUnit : 任意
>类型别名 :=> 任意
>new TypeScript.StringSourceText(code) : 任意
>类型别名 :=> 任意
>TypeScript.StringSourceText : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>StringSourceText : 任意
>类型别名 :=> 任意
>code : 文字
>类型别名 :=> 文字
>unitName : 文字
>类型别名 :=> 文字
>setRecovery : 真假
>类型别名 :=> 真假

            } else {
                compiler.updateUnit(code, unitName, setRecovery);
>compiler.updateUnit(code, unitName, setRecovery) : 任意
>类型别名 :=> 任意
>compiler.updateUnit : 任意
>类型别名 :=> 任意
>compiler : 任意
>类型别名 :=> 任意
>updateUnit : 任意
>类型别名 :=> 任意
>code : 文字
>类型别名 :=> 文字
>unitName : 文字
>类型别名 :=> 文字
>setRecovery : 真假
>类型别名 :=> 真假
            }
        }

        export function compileFile(path: string, callback: (res: CompilerResult) => void , settingsCallback?: (settings?: TypeScript.CompilationSettings) => void , context?: CompilationContext, references?: TypeScript.IFileReference[]) {
>compileFile : (path: 文字, callback: (res: CompilerResult) => 无值, settingsCallback?: (settings?: 任意) => 无值, context?: CompilationContext, references?: 任意[]) => 无值
>path : 文字
>类型别名 :=> 文字
>callback : (res: CompilerResult) => 无值
>res : CompilerResult
>CompilerResult : CompilerResult
>settingsCallback : (settings?: 任意) => 无值
>settings : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>CompilationSettings : No type information available!
>context : CompilationContext
>CompilationContext : CompilationContext
>references : 任意[]
>TypeScript : 任意
>类型别名 :=> 任意
>IFileReference : No type information available!

            path = switchToForwardSlashes(path);
>path = switchToForwardSlashes(path) : 文字
>类型别名 :=> 文字
>path : 文字
>类型别名 :=> 文字
>switchToForwardSlashes(path) : 文字
>类型别名 :=> 文字
>switchToForwardSlashes : (path: 文字) => 文字
>path : 文字
>类型别名 :=> 文字

            var filename = path.match(/[^\/]*$/)[0];
>filename : 文字
>类型别名 :=> 文字
>path.match(/[^\/]*$/)[0] : 文字
>类型别名 :=> 文字
>path.match(/[^\/]*$/) : RegExpMatchArray
>path.match : (regexp: 文字 | RegExp) => RegExpMatchArray
>path : 文字
>类型别名 :=> 文字
>match : (regexp: 文字 | RegExp) => RegExpMatchArray
>/[^\/]*$/ : RegExp
>0 : 0

            var code = readFile(path);
>code : 任意
>类型别名 :=> 任意
>readFile(path) : 任意
>类型别名 :=> 任意
>readFile : (path: 文字) => 任意
>path : 文字
>类型别名 :=> 文字

            compileUnit(code, filename, callback, settingsCallback, context, references);
>compileUnit(code, filename, callback, settingsCallback, context, references) : 无值
>类型别名 :=> 无值
>compileUnit : (code: 文字, filename: 文字, callback: (res: CompilerResult) => 无值, settingsCallback?: (settings?: 任意) => 无值, context?: CompilationContext, references?: 任意[]) => 无值
>code : 任意
>类型别名 :=> 任意
>filename : 文字
>类型别名 :=> 文字
>callback : (res: CompilerResult) => 无值
>settingsCallback : (settings?: 任意) => 无值
>context : CompilationContext
>references : 任意[]
        }

        export function compileUnit(code: string, filename: string, callback: (res: CompilerResult) => void , settingsCallback?: (settings?: TypeScript.CompilationSettings) => void , context?: CompilationContext, references?: TypeScript.IFileReference[]) {
>compileUnit : (code: 文字, filename: 文字, callback: (res: CompilerResult) => 无值, settingsCallback?: (settings?: 任意) => 无值, context?: CompilationContext, references?: 任意[]) => 无值
>code : 文字
>类型别名 :=> 文字
>filename : 文字
>类型别名 :=> 文字
>callback : (res: CompilerResult) => 无值
>res : CompilerResult
>CompilerResult : CompilerResult
>settingsCallback : (settings?: 任意) => 无值
>settings : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>CompilationSettings : No type information available!
>context : CompilationContext
>CompilationContext : CompilationContext
>references : 任意[]
>TypeScript : 任意
>类型别名 :=> 任意
>IFileReference : No type information available!

            // not recursive
            function clone/* <T> */(source: any, target: any) {
>clone : (source: 任意, target: 任意) => 无值
>source : 任意
>类型别名 :=> 任意
>target : 任意
>类型别名 :=> 任意

                for (var prop in source) {
>prop : 文字
>类型别名 :=> 文字
>source : 任意
>类型别名 :=> 任意

                    target[prop] = source[prop];
>target[prop] = source[prop] : 任意
>类型别名 :=> 任意
>target[prop] : 任意
>类型别名 :=> 任意
>target : 任意
>类型别名 :=> 任意
>prop : 文字
>类型别名 :=> 文字
>source[prop] : 任意
>类型别名 :=> 任意
>source : 任意
>类型别名 :=> 任意
>prop : 文字
>类型别名 :=> 文字
                }
            }

            var oldCompilerSettings = new TypeScript.CompilationSettings();
>oldCompilerSettings : 任意
>类型别名 :=> 任意
>new TypeScript.CompilationSettings() : 任意
>类型别名 :=> 任意
>TypeScript.CompilationSettings : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>CompilationSettings : 任意
>类型别名 :=> 任意

            clone(compiler.settings, oldCompilerSettings);
>clone(compiler.settings, oldCompilerSettings) : 无值
>类型别名 :=> 无值
>clone : (source: 任意, target: 任意) => 无值
>compiler.settings : 任意
>类型别名 :=> 任意
>compiler : 任意
>类型别名 :=> 任意
>settings : 任意
>类型别名 :=> 任意
>oldCompilerSettings : 任意
>类型别名 :=> 任意

            var oldEmitSettings = new TypeScript.EmitOptions(compiler.settings);
>oldEmitSettings : 任意
>类型别名 :=> 任意
>new TypeScript.EmitOptions(compiler.settings) : 任意
>类型别名 :=> 任意
>TypeScript.EmitOptions : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>EmitOptions : 任意
>类型别名 :=> 任意
>compiler.settings : 任意
>类型别名 :=> 任意
>compiler : 任意
>类型别名 :=> 任意
>settings : 任意
>类型别名 :=> 任意

            clone(compiler.emitSettings, oldEmitSettings);
>clone(compiler.emitSettings, oldEmitSettings) : 无值
>类型别名 :=> 无值
>clone : (source: 任意, target: 任意) => 无值
>compiler.emitSettings : 任意
>类型别名 :=> 任意
>compiler : 任意
>类型别名 :=> 任意
>emitSettings : 任意
>类型别名 :=> 任意
>oldEmitSettings : 任意
>类型别名 :=> 任意

            var oldModuleGenTarget = TypeScript.moduleGenTarget;
>oldModuleGenTarget : 任意
>类型别名 :=> 任意
>TypeScript.moduleGenTarget : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>moduleGenTarget : 任意
>类型别名 :=> 任意

            if (settingsCallback) {
>settingsCallback : (settings?: 任意) => 无值

                settingsCallback(compiler.settings);
>settingsCallback(compiler.settings) : 无值
>类型别名 :=> 无值
>settingsCallback : (settings?: 任意) => 无值
>compiler.settings : 任意
>类型别名 :=> 任意
>compiler : 任意
>类型别名 :=> 任意
>settings : 任意
>类型别名 :=> 任意

                compiler.emitSettings = new TypeScript.EmitOptions(compiler.settings);
>compiler.emitSettings = new TypeScript.EmitOptions(compiler.settings) : 任意
>类型别名 :=> 任意
>compiler.emitSettings : 任意
>类型别名 :=> 任意
>compiler : 任意
>类型别名 :=> 任意
>emitSettings : 任意
>类型别名 :=> 任意
>new TypeScript.EmitOptions(compiler.settings) : 任意
>类型别名 :=> 任意
>TypeScript.EmitOptions : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>EmitOptions : 任意
>类型别名 :=> 任意
>compiler.settings : 任意
>类型别名 :=> 任意
>compiler : 任意
>类型别名 :=> 任意
>settings : 任意
>类型别名 :=> 任意
            }
            try {
                compileString(code, filename, callback, context, references);
>compileString(code, filename, callback, context, references) : 无值
>类型别名 :=> 无值
>compileString : (code: 文字, unitName: 文字, callback: (res: CompilerResult) => 无值, context?: CompilationContext, references?: 任意[]) => 无值
>code : 文字
>类型别名 :=> 文字
>filename : 文字
>类型别名 :=> 文字
>callback : (res: CompilerResult) => 无值
>context : CompilationContext
>references : 任意[]

            } finally {
                // If settingsCallback exists, assume that it modified the global compiler instance's settings in some way.
                // So that a test doesn't have side effects for tests run after it, restore the compiler settings to their previous state.
                if (settingsCallback) {
>settingsCallback : (settings?: 任意) => 无值

                    compiler.settings = oldCompilerSettings;
>compiler.settings = oldCompilerSettings : 任意
>类型别名 :=> 任意
>compiler.settings : 任意
>类型别名 :=> 任意
>compiler : 任意
>类型别名 :=> 任意
>settings : 任意
>类型别名 :=> 任意
>oldCompilerSettings : 任意
>类型别名 :=> 任意

                    compiler.emitSettings = oldEmitSettings;
>compiler.emitSettings = oldEmitSettings : 任意
>类型别名 :=> 任意
>compiler.emitSettings : 任意
>类型别名 :=> 任意
>compiler : 任意
>类型别名 :=> 任意
>emitSettings : 任意
>类型别名 :=> 任意
>oldEmitSettings : 任意
>类型别名 :=> 任意

                    TypeScript.moduleGenTarget = oldModuleGenTarget;
>TypeScript.moduleGenTarget = oldModuleGenTarget : 任意
>类型别名 :=> 任意
>TypeScript.moduleGenTarget : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>moduleGenTarget : 任意
>类型别名 :=> 任意
>oldModuleGenTarget : 任意
>类型别名 :=> 任意
                }
            }
        }

        export function compileUnits(units: TestCaseParser.TestUnitData[], callback: (res: Compiler.CompilerResult) => void , settingsCallback?: () => void ) {
>compileUnits : (units: TestCaseParser.TestUnitData[], callback: (res: CompilerResult) => 无值, settingsCallback?: () => 无值) => 无值
>units : TestCaseParser.TestUnitData[]
>TestCaseParser : 任意
>类型别名 :=> 任意
>TestUnitData : TestCaseParser.TestUnitData
>callback : (res: CompilerResult) => 无值
>res : CompilerResult
>Compiler : 任意
>类型别名 :=> 任意
>CompilerResult : CompilerResult
>settingsCallback : () => 无值

            var lastUnit = units[units.length - 1];
>lastUnit : TestCaseParser.TestUnitData
>units[units.length - 1] : TestCaseParser.TestUnitData
>units : TestCaseParser.TestUnitData[]
>units.length - 1 : 数字
>类型别名 :=> 数字
>units.length : 数字
>类型别名 :=> 数字
>units : TestCaseParser.TestUnitData[]
>length : 数字
>类型别名 :=> 数字
>1 : 1

            var unitName = switchToForwardSlashes(lastUnit.name).match(/[^\/]*$/)[0];
>unitName : 文字
>类型别名 :=> 文字
>switchToForwardSlashes(lastUnit.name).match(/[^\/]*$/)[0] : 文字
>类型别名 :=> 文字
>switchToForwardSlashes(lastUnit.name).match(/[^\/]*$/) : RegExpMatchArray
>switchToForwardSlashes(lastUnit.name).match : (regexp: 文字 | RegExp) => RegExpMatchArray
>switchToForwardSlashes(lastUnit.name) : 文字
>类型别名 :=> 文字
>switchToForwardSlashes : (path: 文字) => 文字
>lastUnit.name : 文字
>类型别名 :=> 文字
>lastUnit : TestCaseParser.TestUnitData
>name : 文字
>类型别名 :=> 文字
>match : (regexp: 文字 | RegExp) => RegExpMatchArray
>/[^\/]*$/ : RegExp
>0 : 0

            var dependencies = units.slice(0, units.length - 1);
>dependencies : TestCaseParser.TestUnitData[]
>units.slice(0, units.length - 1) : TestCaseParser.TestUnitData[]
>units.slice : (start?: 数字, end?: 数字) => TestCaseParser.TestUnitData[]
>units : TestCaseParser.TestUnitData[]
>slice : (start?: 数字, end?: 数字) => TestCaseParser.TestUnitData[]
>0 : 0
>units.length - 1 : 数字
>类型别名 :=> 数字
>units.length : 数字
>类型别名 :=> 数字
>units : TestCaseParser.TestUnitData[]
>length : 数字
>类型别名 :=> 数字
>1 : 1

            var compilationContext = Harness.Compiler.defineCompilationContextForTest(unitName, dependencies);
>compilationContext : CompilationContext
>Harness.Compiler.defineCompilationContextForTest(unitName, dependencies) : CompilationContext
>Harness.Compiler.defineCompilationContextForTest : (filename: 文字, dependencies: TestCaseParser.TestUnitData[]) => CompilationContext
>Harness.Compiler : 类为 Compiler
>Harness : 类为 Harness
>Compiler : 类为 Compiler
>defineCompilationContextForTest : (filename: 文字, dependencies: TestCaseParser.TestUnitData[]) => CompilationContext
>unitName : 文字
>类型别名 :=> 文字
>dependencies : TestCaseParser.TestUnitData[]

            compileUnit(lastUnit.content, unitName, callback, settingsCallback, compilationContext, lastUnit.references);
>compileUnit(lastUnit.content, unitName, callback, settingsCallback, compilationContext, lastUnit.references) : 无值
>类型别名 :=> 无值
>compileUnit : (code: 文字, filename: 文字, callback: (res: CompilerResult) => 无值, settingsCallback?: (settings?: 任意) => 无值, context?: CompilationContext, references?: 任意[]) => 无值
>lastUnit.content : 文字
>类型别名 :=> 文字
>lastUnit : TestCaseParser.TestUnitData
>content : 文字
>类型别名 :=> 文字
>unitName : 文字
>类型别名 :=> 文字
>callback : (res: CompilerResult) => 无值
>settingsCallback : () => 无值
>compilationContext : CompilationContext
>lastUnit.references : 任意[]
>lastUnit : TestCaseParser.TestUnitData
>references : 任意[]
        }

        export function emitToOutfile(outfile: WriterAggregator) {
>emitToOutfile : (outfile: WriterAggregator) => 无值
>outfile : WriterAggregator
>WriterAggregator : WriterAggregator

            compiler.emitToOutfile(outfile);
>compiler.emitToOutfile(outfile) : 任意
>类型别名 :=> 任意
>compiler.emitToOutfile : 任意
>类型别名 :=> 任意
>compiler : 任意
>类型别名 :=> 任意
>emitToOutfile : 任意
>类型别名 :=> 任意
>outfile : WriterAggregator
        }

        export function emit(ioHost: TypeScript.EmitterIOHost, usePullEmitter?: boolean) {
>emit : (ioHost: 任意, usePullEmitter?: 真假) => 无值
>ioHost : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>EmitterIOHost : No type information available!
>usePullEmitter : 真假
>类型别名 :=> 真假

            compiler.emit(ioHost, usePullEmitter);
>compiler.emit(ioHost, usePullEmitter) : 任意
>类型别名 :=> 任意
>compiler.emit : 任意
>类型别名 :=> 任意
>compiler : 任意
>类型别名 :=> 任意
>emit : 任意
>类型别名 :=> 任意
>ioHost : 任意
>类型别名 :=> 任意
>usePullEmitter : 真假
>类型别名 :=> 真假
        }

        export function compileString(code: string, unitName: string, callback: (res: Compiler.CompilerResult) => void , context?: CompilationContext, references?: TypeScript.IFileReference[]) {
>compileString : (code: 文字, unitName: 文字, callback: (res: CompilerResult) => 无值, context?: CompilationContext, references?: 任意[]) => 无值
>code : 文字
>类型别名 :=> 文字
>unitName : 文字
>类型别名 :=> 文字
>callback : (res: CompilerResult) => 无值
>res : CompilerResult
>Compiler : 任意
>类型别名 :=> 任意
>CompilerResult : CompilerResult
>context : CompilationContext
>CompilationContext : CompilationContext
>references : 任意[]
>TypeScript : 任意
>类型别名 :=> 任意
>IFileReference : No type information available!

            var scripts: TypeScript.Script[] = [];
>scripts : 任意[]
>TypeScript : 任意
>类型别名 :=> 任意
>Script : No type information available!
>[] : 未定[]

            reset();
>reset() : 无值
>类型别名 :=> 无值
>reset : () => 无值

            if (context) {
>context : CompilationContext

                context.preCompile();
>context.preCompile() : 无值
>类型别名 :=> 无值
>context.preCompile : () => 无值
>context : CompilationContext
>preCompile : () => 无值
            }

            var isDeclareFile = Harness.Compiler.isDeclareFile(unitName);
>isDeclareFile : 真假
>类型别名 :=> 真假
>Harness.Compiler.isDeclareFile(unitName) : 真假
>类型别名 :=> 真假
>Harness.Compiler.isDeclareFile : (filename: 文字) => 真假
>Harness.Compiler : 类为 Compiler
>Harness : 类为 Harness
>Compiler : 类为 Compiler
>isDeclareFile : (filename: 文字) => 真假
>unitName : 文字
>类型别名 :=> 文字

            // for single file tests just add them as using the old '0.ts' naming scheme
            var uName = context ? unitName : ((isDeclareFile) ? '0.d.ts' : '0.ts');
>uName : 文字
>类型别名 :=> 文字
>context ? unitName : ((isDeclareFile) ? '0.d.ts' : '0.ts') : 文字
>类型别名 :=> 文字
>context : CompilationContext
>unitName : 文字
>类型别名 :=> 文字
>((isDeclareFile) ? '0.d.ts' : '0.ts') : "0.ts" | "0.d.ts"
>(isDeclareFile) ? '0.d.ts' : '0.ts' : "0.ts" | "0.d.ts"
>(isDeclareFile) : 真假
>类型别名 :=> 真假
>isDeclareFile : 真假
>类型别名 :=> 真假
>'0.d.ts' : "0.d.ts"
>'0.ts' : "0.ts"

            scripts.push(addUnit(code, uName, false, isDeclareFile, references));
>scripts.push(addUnit(code, uName, false, isDeclareFile, references)) : 数字
>类型别名 :=> 数字
>scripts.push : (...items: 任意[]) => 数字
>scripts : 任意[]
>push : (...items: 任意[]) => 数字
>addUnit(code, uName, false, isDeclareFile, references) : 任意
>类型别名 :=> 任意
>addUnit : (code: 文字, unitName?: 文字, isResident?: 真假, isDeclareFile?: 真假, references?: 任意[]) => 任意
>code : 文字
>类型别名 :=> 文字
>uName : 文字
>类型别名 :=> 文字
>false : 为假
>类型别名 :=> 为假
>isDeclareFile : 真假
>类型别名 :=> 真假
>references : 任意[]

            compile(code, uName);
>compile(code, uName) : 无值
>类型别名 :=> 无值
>compile : (code?: 文字, filename?: 文字) => 无值
>code : 文字
>类型别名 :=> 文字
>uName : 文字
>类型别名 :=> 文字

            var errors;
>errors : 任意
>类型别名 :=> 任意

            if (usePull) {
>usePull : 真假
>类型别名 :=> 真假

                // TODO: no emit support with pull yet
                errors = compiler.pullGetErrorsForFile(uName);
>errors = compiler.pullGetErrorsForFile(uName) : 任意
>类型别名 :=> 任意
>errors : 任意
>类型别名 :=> 任意
>compiler.pullGetErrorsForFile(uName) : 任意
>类型别名 :=> 任意
>compiler.pullGetErrorsForFile : 任意
>类型别名 :=> 任意
>compiler : 任意
>类型别名 :=> 任意
>pullGetErrorsForFile : 任意
>类型别名 :=> 任意
>uName : 文字
>类型别名 :=> 文字

                emit(stdout, true);
>emit(stdout, true) : 无值
>类型别名 :=> 无值
>emit : (ioHost: 任意, usePullEmitter?: 真假) => 无值
>stdout : EmitterIOHost
>true : 为真
>类型别名 :=> 为真
            }
            else {
                errors = stderr.lines;
>errors = stderr.lines : 文字[]
>errors : 任意
>类型别名 :=> 任意
>stderr.lines : 文字[]
>stderr : WriterAggregator
>lines : 文字[]

                emit(stdout, false);
>emit(stdout, false) : 无值
>类型别名 :=> 无值
>emit : (ioHost: 任意, usePullEmitter?: 真假) => 无值
>stdout : EmitterIOHost
>false : 为假
>类型别名 :=> 为假

                //output decl file
                compiler.emitDeclarations();
>compiler.emitDeclarations() : 任意
>类型别名 :=> 任意
>compiler.emitDeclarations : 任意
>类型别名 :=> 任意
>compiler : 任意
>类型别名 :=> 任意
>emitDeclarations : 任意
>类型别名 :=> 任意
            }

            if (context) {
>context : CompilationContext

                context.postCompile();
>context.postCompile() : 无值
>类型别名 :=> 无值
>context.postCompile : () => 无值
>context : CompilationContext
>postCompile : () => 无值
            }

            callback(new CompilerResult(stdout.toArray(), errors, scripts));
>callback(new CompilerResult(stdout.toArray(), errors, scripts)) : 无值
>类型别名 :=> 无值
>callback : (res: CompilerResult) => 无值
>new CompilerResult(stdout.toArray(), errors, scripts) : CompilerResult
>CompilerResult : 类为 CompilerResult
>stdout.toArray() : { filename: 文字; file: WriterAggregator; }[]
>stdout.toArray : () => { filename: 文字; file: WriterAggregator; }[]
>stdout : EmitterIOHost
>toArray : () => { filename: 文字; file: WriterAggregator; }[]
>errors : 任意
>类型别名 :=> 任意
>scripts : 任意[]
        }

        /** Returns a set of functions which can be later executed to add and remove given dependencies to the compiler so that
         *  a file can be successfully compiled. These functions will add/remove named units and code to the compiler for each dependency. 
         */
        export function defineCompilationContextForTest(filename: string, dependencies: TestCaseParser.TestUnitData[]): CompilationContext {
>defineCompilationContextForTest : (filename: 文字, dependencies: TestCaseParser.TestUnitData[]) => CompilationContext
>filename : 文字
>类型别名 :=> 文字
>dependencies : TestCaseParser.TestUnitData[]
>TestCaseParser : 任意
>类型别名 :=> 任意
>TestUnitData : TestCaseParser.TestUnitData
>CompilationContext : CompilationContext

            // if the given file has no dependencies, there is no context to return, it can be compiled without additional work
            if (dependencies.length == 0) {
>dependencies.length == 0 : 真假
>类型别名 :=> 真假
>dependencies.length : 数字
>类型别名 :=> 数字
>dependencies : TestCaseParser.TestUnitData[]
>length : 数字
>类型别名 :=> 数字
>0 : 0

                return null;
>null : 空值
>类型别名 :=> 空值

            } else {
                var addedFiles = [];
>addedFiles : 任意[]
>[] : 未定[]

                var precompile = () => {
>precompile : () => 无值
>() => {                    // REVIEW: if any dependency has a triple slash reference then does postCompile potentially have to do a recreate since we can't update references with updateUnit?                    // easy enough to do if so, prefer to avoid the recreate cost until it proves to be an issue                    dependencies.forEach(dep => {                        addUnit(dep.content, dep.name, false, Harness.Compiler.isDeclareFile(dep.name));                        addedFiles.push(dep.name);                    });                } : () => 无值

                    // REVIEW: if any dependency has a triple slash reference then does postCompile potentially have to do a recreate since we can't update references with updateUnit?
                    // easy enough to do if so, prefer to avoid the recreate cost until it proves to be an issue
                    dependencies.forEach(dep => {
>dependencies.forEach(dep => {                        addUnit(dep.content, dep.name, false, Harness.Compiler.isDeclareFile(dep.name));                        addedFiles.push(dep.name);                    }) : 无值
>类型别名 :=> 无值
>dependencies.forEach : (callbackfn: (value: TestCaseParser.TestUnitData, index: 数字, array: TestCaseParser.TestUnitData[]) => 无值, thisArg?: 任意) => 无值
>dependencies : TestCaseParser.TestUnitData[]
>forEach : (callbackfn: (value: TestCaseParser.TestUnitData, index: 数字, array: TestCaseParser.TestUnitData[]) => 无值, thisArg?: 任意) => 无值
>dep => {                        addUnit(dep.content, dep.name, false, Harness.Compiler.isDeclareFile(dep.name));                        addedFiles.push(dep.name);                    } : (dep: TestCaseParser.TestUnitData) => 无值
>dep : TestCaseParser.TestUnitData

                        addUnit(dep.content, dep.name, false, Harness.Compiler.isDeclareFile(dep.name));
>addUnit(dep.content, dep.name, false, Harness.Compiler.isDeclareFile(dep.name)) : 任意
>类型别名 :=> 任意
>addUnit : (code: 文字, unitName?: 文字, isResident?: 真假, isDeclareFile?: 真假, references?: 任意[]) => 任意
>dep.content : 文字
>类型别名 :=> 文字
>dep : TestCaseParser.TestUnitData
>content : 文字
>类型别名 :=> 文字
>dep.name : 文字
>类型别名 :=> 文字
>dep : TestCaseParser.TestUnitData
>name : 文字
>类型别名 :=> 文字
>false : 为假
>类型别名 :=> 为假
>Harness.Compiler.isDeclareFile(dep.name) : 真假
>类型别名 :=> 真假
>Harness.Compiler.isDeclareFile : (filename: 文字) => 真假
>Harness.Compiler : 类为 Compiler
>Harness : 类为 Harness
>Compiler : 类为 Compiler
>isDeclareFile : (filename: 文字) => 真假
>dep.name : 文字
>类型别名 :=> 文字
>dep : TestCaseParser.TestUnitData
>name : 文字
>类型别名 :=> 文字

                        addedFiles.push(dep.name);
>addedFiles.push(dep.name) : 数字
>类型别名 :=> 数字
>addedFiles.push : (...items: 任意[]) => 数字
>addedFiles : 任意[]
>push : (...items: 任意[]) => 数字
>dep.name : 文字
>类型别名 :=> 文字
>dep : TestCaseParser.TestUnitData
>name : 文字
>类型别名 :=> 文字

                    });
                };
                var postcompile = () => {
>postcompile : () => 无值
>() => {                    addedFiles.forEach(file => {                        updateUnit('', file);                    });                } : () => 无值

                    addedFiles.forEach(file => {
>addedFiles.forEach(file => {                        updateUnit('', file);                    }) : 无值
>类型别名 :=> 无值
>addedFiles.forEach : (callbackfn: (value: 任意, index: 数字, array: 任意[]) => 无值, thisArg?: 任意) => 无值
>addedFiles : 任意[]
>forEach : (callbackfn: (value: 任意, index: 数字, array: 任意[]) => 无值, thisArg?: 任意) => 无值
>file => {                        updateUnit('', file);                    } : (file: 任意) => 无值
>file : 任意
>类型别名 :=> 任意

                        updateUnit('', file);
>updateUnit('', file) : 无值
>类型别名 :=> 无值
>updateUnit : (code: 文字, unitName: 文字, setRecovery?: 真假) => 无值
>'' : ""
>file : 任意
>类型别名 :=> 任意

                    });
                };
                var context = {
>context : { filename: 文字; preCompile: () => 无值; postCompile: () => 无值; }
>{                    filename: filename,                    preCompile: precompile,                    postCompile: postcompile                } : { filename: 文字; preCompile: () => 无值; postCompile: () => 无值; }

                    filename: filename,
>filename : 文字
>类型别名 :=> 文字
>filename : 文字
>类型别名 :=> 文字

                    preCompile: precompile,
>preCompile : () => 无值
>precompile : () => 无值

                    postCompile: postcompile
>postCompile : () => 无值
>postcompile : () => 无值

                };
                return context;
>context : { filename: 文字; preCompile: () => 无值; postCompile: () => 无值; }
            }
        }
    }

    /** Parses the test cases files 
     *  extracts options and individual files in a multifile test
     */
    export module TestCaseParser {
>TestCaseParser : 类为 TestCaseParser

        /** all the necesarry information to set the right compiler settings */
        export interface CompilerSetting {
>CompilerSetting : CompilerSetting

            flag: string;
>flag : 文字
>类型别名 :=> 文字

            value: string;
>value : 文字
>类型别名 :=> 文字
        }

        /** All the necessary information to turn a multi file test into useful units for later compilation */
        export interface TestUnitData {
>TestUnitData : TestUnitData

            content: string;
>content : 文字
>类型别名 :=> 文字

            name: string;
>name : 文字
>类型别名 :=> 文字

            originalFilePath: string;
>originalFilePath : 文字
>类型别名 :=> 文字

            references: TypeScript.IFileReference[];
>references : 任意[]
>TypeScript : 任意
>类型别名 :=> 任意
>IFileReference : No type information available!
        }

        // Regex for parsing options in the format "@Alpha: Value of any sort"
        private optionRegex = /^[\/]{2}\s*@(\w+):\s*(\S*)/gm;  // multiple matches on multiple lines
>optionRegex = /^[\/]{2}\s*@(\w+):\s*(\S*)/gm : RegExp
>optionRegex : 任意
>类型别名 :=> 任意
>/^[\/]{2}\s*@(\w+):\s*(\S*)/gm : RegExp

        // List of allowed metadata names
        var fileMetadataNames = ["filename", "comments", "declaration", "module", "nolib", "sourcemap", "target", "out"];
>fileMetadataNames : 文字[]
>["filename", "comments", "declaration", "module", "nolib", "sourcemap", "target", "out"] : 文字[]
>"filename" : "filename"
>"comments" : "comments"
>"declaration" : "declaration"
>"module" : "module"
>"nolib" : "nolib"
>"sourcemap" : "sourcemap"
>"target" : "target"
>"out" : "out"

        function extractCompilerSettings(content: string): CompilerSetting[] {
>extractCompilerSettings : (content: 文字) => CompilerSetting[]
>content : 文字
>类型别名 :=> 文字
>CompilerSetting : CompilerSetting

            var opts = [];
>opts : 任意[]
>[] : 未定[]

            var match;
>match : 任意
>类型别名 :=> 任意

            while ((match = optionRegex.exec(content)) != null) {
>(match = optionRegex.exec(content)) != null : 真假
>类型别名 :=> 真假
>(match = optionRegex.exec(content)) : 任意
>类型别名 :=> 任意
>match = optionRegex.exec(content) : 任意
>类型别名 :=> 任意
>match : 任意
>类型别名 :=> 任意
>optionRegex.exec(content) : 任意
>类型别名 :=> 任意
>optionRegex.exec : 任意
>类型别名 :=> 任意
>optionRegex : 任意
>类型别名 :=> 任意
>exec : 任意
>类型别名 :=> 任意
>content : 文字
>类型别名 :=> 文字
>null : 空值
>类型别名 :=> 空值

                opts.push({ flag: match[1], value: match[2] });
>opts.push({ flag: match[1], value: match[2] }) : 数字
>类型别名 :=> 数字
>opts.push : (...items: 任意[]) => 数字
>opts : 任意[]
>push : (...items: 任意[]) => 数字
>{ flag: match[1], value: match[2] } : { flag: 任意; value: 任意; }
>flag : 任意
>类型别名 :=> 任意
>match[1] : 任意
>类型别名 :=> 任意
>match : 任意
>类型别名 :=> 任意
>1 : 1
>value : 任意
>类型别名 :=> 任意
>match[2] : 任意
>类型别名 :=> 任意
>match : 任意
>类型别名 :=> 任意
>2 : 2
            }

            return opts;
>opts : 任意[]
        }

        /** Given a test file containing // @Filename directives, return an array of named units of code to be added to an existing compiler instance */
        export function makeUnitsFromTest(code: string, filename: string): { settings: CompilerSetting[]; testUnitData: TestUnitData[]; } {
>makeUnitsFromTest : (code: 文字, filename: 文字) => { settings: CompilerSetting[]; testUnitData: TestUnitData[]; }
>code : 文字
>类型别名 :=> 文字
>filename : 文字
>类型别名 :=> 文字
>settings : CompilerSetting[]
>CompilerSetting : CompilerSetting
>testUnitData : TestUnitData[]
>TestUnitData : TestUnitData

            var settings = extractCompilerSettings(code);
>settings : CompilerSetting[]
>extractCompilerSettings(code) : CompilerSetting[]
>extractCompilerSettings : (content: 文字) => CompilerSetting[]
>code : 文字
>类型别名 :=> 文字

            // List of all the subfiles we've parsed out
            var files: TestUnitData[] = [];
>files : TestUnitData[]
>TestUnitData : TestUnitData
>[] : 未定[]

            var lines = splitContentByNewlines(code);
>lines : 文字[]
>splitContentByNewlines(code) : 文字[]
>splitContentByNewlines : (content: 文字) => 文字[]
>code : 文字
>类型别名 :=> 文字

            // Stuff related to the subfile we're parsing
            var currentFileContent: string = null;
>currentFileContent : 文字
>类型别名 :=> 文字
>null : 空值
>类型别名 :=> 空值

            var currentFileOptions = {};
>currentFileOptions : {}
>{} : {}

            var currentFileName = null;
>currentFileName : 任意
>类型别名 :=> 任意
>null : 空值
>类型别名 :=> 空值

            var refs: TypeScript.IFileReference[] = [];
>refs : 任意[]
>TypeScript : 任意
>类型别名 :=> 任意
>IFileReference : No type information available!
>[] : 未定[]

            for (var i = 0; i < lines.length; i++) {
>i : 数字
>类型别名 :=> 数字
>0 : 0
>i < lines.length : 真假
>类型别名 :=> 真假
>i : 数字
>类型别名 :=> 数字
>lines.length : 数字
>类型别名 :=> 数字
>lines : 文字[]
>length : 数字
>类型别名 :=> 数字
>i++ : 数字
>类型别名 :=> 数字
>i : 数字
>类型别名 :=> 数字

                var line = lines[i];
>line : 文字
>类型别名 :=> 文字
>lines[i] : 文字
>类型别名 :=> 文字
>lines : 文字[]
>i : 数字
>类型别名 :=> 数字

                var isTripleSlashReference = /[\/]{3}\s*<reference path/.test(line);
>isTripleSlashReference : 真假
>类型别名 :=> 真假
>/[\/]{3}\s*<reference path/.test(line) : 真假
>类型别名 :=> 真假
>/[\/]{3}\s*<reference path/.test : (string: 文字) => 真假
>/[\/]{3}\s*<reference path/ : RegExp
>test : (string: 文字) => 真假
>line : 文字
>类型别名 :=> 文字

                var testMetaData = optionRegex.exec(line);
>testMetaData : 任意
>类型别名 :=> 任意
>optionRegex.exec(line) : 任意
>类型别名 :=> 任意
>optionRegex.exec : 任意
>类型别名 :=> 任意
>optionRegex : 任意
>类型别名 :=> 任意
>exec : 任意
>类型别名 :=> 任意
>line : 文字
>类型别名 :=> 文字

                // Triple slash references need to be tracked as they are added to the compiler as an additional parameter to addUnit
                if (isTripleSlashReference) {
>isTripleSlashReference : 真假
>类型别名 :=> 真假

                    var isRef = line.match(/reference\spath='(\w*_?\w*\.?d?\.ts)'/);
>isRef : RegExpMatchArray
>line.match(/reference\spath='(\w*_?\w*\.?d?\.ts)'/) : RegExpMatchArray
>line.match : (regexp: 文字 | RegExp) => RegExpMatchArray
>line : 文字
>类型别名 :=> 文字
>match : (regexp: 文字 | RegExp) => RegExpMatchArray
>/reference\spath='(\w*_?\w*\.?d?\.ts)'/ : RegExp

                    if (isRef) {
>isRef : RegExpMatchArray

                        var ref = {
>ref : { minChar: 数字; limChar: 数字; startLine: 数字; startCol: 数字; path: 文字; isResident: 真假; }
>{                            minChar: 0,                            limChar: 0,                            startLine:0,                            startCol:0,                            path: isRef[1],                            isResident: false                        } : { minChar: 数字; limChar: 数字; startLine: 数字; startCol: 数字; path: 文字; isResident: 真假; }

                            minChar: 0,
>minChar : 数字
>类型别名 :=> 数字
>0 : 0

                            limChar: 0,
>limChar : 数字
>类型别名 :=> 数字
>0 : 0

                            startLine:0,
>startLine : 数字
>类型别名 :=> 数字
>0 : 0

                            startCol:0,
>startCol : 数字
>类型别名 :=> 数字
>0 : 0

                            path: isRef[1],
>path : 文字
>类型别名 :=> 文字
>isRef[1] : 文字
>类型别名 :=> 文字
>isRef : RegExpMatchArray
>1 : 1

                            isResident: false
>isResident : 真假
>类型别名 :=> 真假
>false : 为假
>类型别名 :=> 为假

                        };

                        refs.push(ref);
>refs.push(ref) : 数字
>类型别名 :=> 数字
>refs.push : (...items: 任意[]) => 数字
>refs : 任意[]
>push : (...items: 任意[]) => 数字
>ref : { minChar: 数字; limChar: 数字; startLine: 数字; startCol: 数字; path: 文字; isResident: 真假; }
                    }
                } else if (testMetaData) {
>testMetaData : 任意
>类型别名 :=> 任意

                    // Comment line, check for global/file @options and record them
                    optionRegex.lastIndex = 0;
>optionRegex.lastIndex = 0 : 0
>optionRegex.lastIndex : 任意
>类型别名 :=> 任意
>optionRegex : 任意
>类型别名 :=> 任意
>lastIndex : 任意
>类型别名 :=> 任意
>0 : 0

                    var fileNameIndex = fileMetadataNames.indexOf(testMetaData[1].toLowerCase());
>fileNameIndex : 数字
>类型别名 :=> 数字
>fileMetadataNames.indexOf(testMetaData[1].toLowerCase()) : 数字
>类型别名 :=> 数字
>fileMetadataNames.indexOf : (searchElement: 文字, fromIndex?: 数字) => 数字
>fileMetadataNames : 文字[]
>indexOf : (searchElement: 文字, fromIndex?: 数字) => 数字
>testMetaData[1].toLowerCase() : 任意
>类型别名 :=> 任意
>testMetaData[1].toLowerCase : 任意
>类型别名 :=> 任意
>testMetaData[1] : 任意
>类型别名 :=> 任意
>testMetaData : 任意
>类型别名 :=> 任意
>1 : 1
>toLowerCase : 任意
>类型别名 :=> 任意

                    if (fileNameIndex == -1) {
>fileNameIndex == -1 : 真假
>类型别名 :=> 真假
>fileNameIndex : 数字
>类型别名 :=> 数字
>-1 : -1
>1 : 1

                        throw new Error('Unrecognized metadata name "' + testMetaData[1] + '". Available file metadata names are: ' + fileMetadataNames.join(', '));
>new Error('Unrecognized metadata name "' + testMetaData[1] + '". Available file metadata names are: ' + fileMetadataNames.join(', ')) : Error
>Error : ErrorConstructor
>'Unrecognized metadata name "' + testMetaData[1] + '". Available file metadata names are: ' + fileMetadataNames.join(', ') : 文字
>类型别名 :=> 文字
>'Unrecognized metadata name "' + testMetaData[1] + '". Available file metadata names are: ' : 文字
>类型别名 :=> 文字
>'Unrecognized metadata name "' + testMetaData[1] : 文字
>类型别名 :=> 文字
>'Unrecognized metadata name "' : "Unrecognized metadata name \""
>testMetaData[1] : 任意
>类型别名 :=> 任意
>testMetaData : 任意
>类型别名 :=> 任意
>1 : 1
>'". Available file metadata names are: ' : "\". Available file metadata names are: "
>fileMetadataNames.join(', ') : 文字
>类型别名 :=> 文字
>fileMetadataNames.join : (separator?: 文字) => 文字
>fileMetadataNames : 文字[]
>join : (separator?: 文字) => 文字
>', ' : ", "

                    } else if (fileNameIndex == 0) {
>fileNameIndex == 0 : 真假
>类型别名 :=> 真假
>fileNameIndex : 数字
>类型别名 :=> 数字
>0 : 0

                        currentFileOptions[testMetaData[1]] = testMetaData[2];
>currentFileOptions[testMetaData[1]] = testMetaData[2] : 任意
>类型别名 :=> 任意
>currentFileOptions[testMetaData[1]] : 任意
>类型别名 :=> 任意
>currentFileOptions : {}
>testMetaData[1] : 任意
>类型别名 :=> 任意
>testMetaData : 任意
>类型别名 :=> 任意
>1 : 1
>testMetaData[2] : 任意
>类型别名 :=> 任意
>testMetaData : 任意
>类型别名 :=> 任意
>2 : 2

                    } else {
                        continue;
                    }

                    // New metadata statement after having collected some code to go with the previous metadata
                    if (currentFileName) {
>currentFileName : 任意
>类型别名 :=> 任意

                        // Store result file
                        var newTestFile =
>newTestFile : { content: 文字; name: 任意; fileOptions: {}; originalFilePath: 文字; references: 任意[]; }
                            {
>{                                content: currentFileContent,                                name: currentFileName,                                fileOptions: currentFileOptions,                                originalFilePath: filename,                                references: refs                            } : { content: 文字; name: 任意; fileOptions: {}; originalFilePath: 文字; references: 任意[]; }

                                content: currentFileContent,
>content : 文字
>类型别名 :=> 文字
>currentFileContent : 文字
>类型别名 :=> 文字

                                name: currentFileName,
>name : 任意
>类型别名 :=> 任意
>currentFileName : 任意
>类型别名 :=> 任意

                                fileOptions: currentFileOptions,
>fileOptions : {}
>currentFileOptions : {}

                                originalFilePath: filename,
>originalFilePath : 文字
>类型别名 :=> 文字
>filename : 文字
>类型别名 :=> 文字

                                references: refs
>references : 任意[]
>refs : 任意[]

                            };
                        files.push(newTestFile);
>files.push(newTestFile) : 数字
>类型别名 :=> 数字
>files.push : (...items: TestUnitData[]) => 数字
>files : TestUnitData[]
>push : (...items: TestUnitData[]) => 数字
>newTestFile : { content: 文字; name: 任意; fileOptions: {}; originalFilePath: 文字; references: 任意[]; }

                        // Reset local data
                        currentFileContent = null;
>currentFileContent = null : 空值
>类型别名 :=> 空值
>currentFileContent : 文字
>类型别名 :=> 文字
>null : 空值
>类型别名 :=> 空值

                        currentFileOptions = {};
>currentFileOptions = {} : {}
>currentFileOptions : {}
>{} : {}

                        currentFileName = testMetaData[2];
>currentFileName = testMetaData[2] : 任意
>类型别名 :=> 任意
>currentFileName : 任意
>类型别名 :=> 任意
>testMetaData[2] : 任意
>类型别名 :=> 任意
>testMetaData : 任意
>类型别名 :=> 任意
>2 : 2

                        refs = [];
>refs = [] : 未定[]
>refs : 任意[]
>[] : 未定[]

                    } else {
                        // First metadata marker in the file
                        currentFileName = testMetaData[2];
>currentFileName = testMetaData[2] : 任意
>类型别名 :=> 任意
>currentFileName : 任意
>类型别名 :=> 任意
>testMetaData[2] : 任意
>类型别名 :=> 任意
>testMetaData : 任意
>类型别名 :=> 任意
>2 : 2
                    }
                } else {
                    // Subfile content line
                    // Append to the current subfile content, inserting a newline needed
                    if (currentFileContent === null) {
>currentFileContent === null : 真假
>类型别名 :=> 真假
>currentFileContent : 文字
>类型别名 :=> 文字
>null : 空值
>类型别名 :=> 空值

                        currentFileContent = '';
>currentFileContent = '' : ""
>currentFileContent : 文字
>类型别名 :=> 文字
>'' : ""

                    } else {
                        // End-of-line
                        currentFileContent = currentFileContent + '\n';
>currentFileContent = currentFileContent + '\n' : 文字
>类型别名 :=> 文字
>currentFileContent : 文字
>类型别名 :=> 文字
>currentFileContent + '\n' : 文字
>类型别名 :=> 文字
>currentFileContent : 文字
>类型别名 :=> 文字
>'\n' : "\n"
                    }
                    currentFileContent = currentFileContent + line;
>currentFileContent = currentFileContent + line : 文字
>类型别名 :=> 文字
>currentFileContent : 文字
>类型别名 :=> 文字
>currentFileContent + line : 文字
>类型别名 :=> 文字
>currentFileContent : 文字
>类型别名 :=> 文字
>line : 文字
>类型别名 :=> 文字
                }
            }

            // normalize the filename for the single file case
            currentFileName = files.length > 0 ? currentFileName : '0.ts';
>currentFileName = files.length > 0 ? currentFileName : '0.ts' : 任意
>类型别名 :=> 任意
>currentFileName : 任意
>类型别名 :=> 任意
>files.length > 0 ? currentFileName : '0.ts' : 任意
>类型别名 :=> 任意
>files.length > 0 : 真假
>类型别名 :=> 真假
>files.length : 数字
>类型别名 :=> 数字
>files : TestUnitData[]
>length : 数字
>类型别名 :=> 数字
>0 : 0
>currentFileName : 任意
>类型别名 :=> 任意
>'0.ts' : "0.ts"

            // EOF, push whatever remains
            var newTestFile = {
>newTestFile : { content: 文字; name: 任意; fileOptions: {}; originalFilePath: 文字; references: 任意[]; }
>{                content: currentFileContent || '',                name: currentFileName,                fileOptions: currentFileOptions,                originalFilePath: filename,                references: refs            } : { content: 文字; name: 任意; fileOptions: {}; originalFilePath: 文字; references: 任意[]; }

                content: currentFileContent || '',
>content : 文字
>类型别名 :=> 文字
>currentFileContent || '' : 文字
>类型别名 :=> 文字
>currentFileContent : 文字
>类型别名 :=> 文字
>'' : ""

                name: currentFileName,
>name : 任意
>类型别名 :=> 任意
>currentFileName : 任意
>类型别名 :=> 任意

                fileOptions: currentFileOptions,
>fileOptions : {}
>currentFileOptions : {}

                originalFilePath: filename,
>originalFilePath : 文字
>类型别名 :=> 文字
>filename : 文字
>类型别名 :=> 文字

                references: refs
>references : 任意[]
>refs : 任意[]

            };
            files.push(newTestFile);
>files.push(newTestFile) : 数字
>类型别名 :=> 数字
>files.push : (...items: TestUnitData[]) => 数字
>files : TestUnitData[]
>push : (...items: TestUnitData[]) => 数字
>newTestFile : { content: 文字; name: 任意; fileOptions: {}; originalFilePath: 文字; references: 任意[]; }

            return { settings: settings, testUnitData: files };
>{ settings: settings, testUnitData: files } : { settings: CompilerSetting[]; testUnitData: TestUnitData[]; }
>settings : CompilerSetting[]
>settings : CompilerSetting[]
>testUnitData : TestUnitData[]
>files : TestUnitData[]
        }
    }

    export class ScriptInfo {
>ScriptInfo : ScriptInfo

        public version: number;
>version : 数字
>类型别名 :=> 数字

        public editRanges: { length: number; editRange: TypeScript.ScriptEditRange; }[] = [];
>editRanges : { length: 数字; editRange: 任意; }[]
>length : 数字
>类型别名 :=> 数字
>editRange : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>ScriptEditRange : No type information available!
>[] : 未定[]

        constructor(public name: string, public content: string, public isResident: boolean, public maxScriptVersions: number) {
>name : 文字
>类型别名 :=> 文字
>content : 文字
>类型别名 :=> 文字
>isResident : 真假
>类型别名 :=> 真假
>maxScriptVersions : 数字
>类型别名 :=> 数字

            this.version = 1;
>this.version = 1 : 1
>this.version : 数字
>类型别名 :=> 数字
>this : 本体
>version : 数字
>类型别名 :=> 数字
>1 : 1
        }

        public updateContent(content: string, isResident: boolean) {
>updateContent : (content: 文字, isResident: 真假) => 无值
>content : 文字
>类型别名 :=> 文字
>isResident : 真假
>类型别名 :=> 真假

            this.editRanges = [];
>this.editRanges = [] : 未定[]
>this.editRanges : { length: 数字; editRange: 任意; }[]
>this : 本体
>editRanges : { length: 数字; editRange: 任意; }[]
>[] : 未定[]

            this.content = content;
>this.content = content : 文字
>类型别名 :=> 文字
>this.content : 文字
>类型别名 :=> 文字
>this : 本体
>content : 文字
>类型别名 :=> 文字
>content : 文字
>类型别名 :=> 文字

            this.isResident = isResident;
>this.isResident = isResident : 真假
>类型别名 :=> 真假
>this.isResident : 真假
>类型别名 :=> 真假
>this : 本体
>isResident : 真假
>类型别名 :=> 真假
>isResident : 真假
>类型别名 :=> 真假

            this.version++;
>this.version++ : 数字
>类型别名 :=> 数字
>this.version : 数字
>类型别名 :=> 数字
>this : 本体
>version : 数字
>类型别名 :=> 数字
        }

        public editContent(minChar: number, limChar: number, newText: string) {
>editContent : (minChar: 数字, limChar: 数字, newText: 文字) => 无值
>minChar : 数字
>类型别名 :=> 数字
>limChar : 数字
>类型别名 :=> 数字
>newText : 文字
>类型别名 :=> 文字

            // Apply edits
            var prefix = this.content.substring(0, minChar);
>prefix : 文字
>类型别名 :=> 文字
>this.content.substring(0, minChar) : 文字
>类型别名 :=> 文字
>this.content.substring : (start: 数字, end?: 数字) => 文字
>this.content : 文字
>类型别名 :=> 文字
>this : 本体
>content : 文字
>类型别名 :=> 文字
>substring : (start: 数字, end?: 数字) => 文字
>0 : 0
>minChar : 数字
>类型别名 :=> 数字

            var middle = newText;
>middle : 文字
>类型别名 :=> 文字
>newText : 文字
>类型别名 :=> 文字

            var suffix = this.content.substring(limChar);
>suffix : 文字
>类型别名 :=> 文字
>this.content.substring(limChar) : 文字
>类型别名 :=> 文字
>this.content.substring : (start: 数字, end?: 数字) => 文字
>this.content : 文字
>类型别名 :=> 文字
>this : 本体
>content : 文字
>类型别名 :=> 文字
>substring : (start: 数字, end?: 数字) => 文字
>limChar : 数字
>类型别名 :=> 数字

            this.content = prefix + middle + suffix;
>this.content = prefix + middle + suffix : 文字
>类型别名 :=> 文字
>this.content : 文字
>类型别名 :=> 文字
>this : 本体
>content : 文字
>类型别名 :=> 文字
>prefix + middle + suffix : 文字
>类型别名 :=> 文字
>prefix + middle : 文字
>类型别名 :=> 文字
>prefix : 文字
>类型别名 :=> 文字
>middle : 文字
>类型别名 :=> 文字
>suffix : 文字
>类型别名 :=> 文字

            // Store edit range + new length of script
            this.editRanges.push({
>this.editRanges.push({                length: this.content.length,                editRange: new TypeScript.ScriptEditRange(minChar, limChar, (limChar - minChar) + newText.length)            }) : 数字
>类型别名 :=> 数字
>this.editRanges.push : (...items: { length: 数字; editRange: 任意; }[]) => 数字
>this.editRanges : { length: 数字; editRange: 任意; }[]
>this : 本体
>editRanges : { length: 数字; editRange: 任意; }[]
>push : (...items: { length: 数字; editRange: 任意; }[]) => 数字
>{                length: this.content.length,                editRange: new TypeScript.ScriptEditRange(minChar, limChar, (limChar - minChar) + newText.length)            } : { length: 数字; editRange: 任意; }

                length: this.content.length,
>length : 数字
>类型别名 :=> 数字
>this.content.length : 数字
>类型别名 :=> 数字
>this.content : 文字
>类型别名 :=> 文字
>this : 本体
>content : 文字
>类型别名 :=> 文字
>length : 数字
>类型别名 :=> 数字

                editRange: new TypeScript.ScriptEditRange(minChar, limChar, (limChar - minChar) + newText.length)
>editRange : 任意
>类型别名 :=> 任意
>new TypeScript.ScriptEditRange(minChar, limChar, (limChar - minChar) + newText.length) : 任意
>类型别名 :=> 任意
>TypeScript.ScriptEditRange : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>ScriptEditRange : 任意
>类型别名 :=> 任意
>minChar : 数字
>类型别名 :=> 数字
>limChar : 数字
>类型别名 :=> 数字
>(limChar - minChar) + newText.length : 数字
>类型别名 :=> 数字
>(limChar - minChar) : 数字
>类型别名 :=> 数字
>limChar - minChar : 数字
>类型别名 :=> 数字
>limChar : 数字
>类型别名 :=> 数字
>minChar : 数字
>类型别名 :=> 数字
>newText.length : 数字
>类型别名 :=> 数字
>newText : 文字
>类型别名 :=> 文字
>length : 数字
>类型别名 :=> 数字

            });

            if (this.editRanges.length > this.maxScriptVersions) {
>this.editRanges.length > this.maxScriptVersions : 真假
>类型别名 :=> 真假
>this.editRanges.length : 数字
>类型别名 :=> 数字
>this.editRanges : { length: 数字; editRange: 任意; }[]
>this : 本体
>editRanges : { length: 数字; editRange: 任意; }[]
>length : 数字
>类型别名 :=> 数字
>this.maxScriptVersions : 数字
>类型别名 :=> 数字
>this : 本体
>maxScriptVersions : 数字
>类型别名 :=> 数字

                this.editRanges.splice(0, this.maxScriptVersions - this.editRanges.length);
>this.editRanges.splice(0, this.maxScriptVersions - this.editRanges.length) : { length: 数字; editRange: 任意; }[]
>this.editRanges.splice : { (start: 数字, deleteCount?: 数字): { length: 数字; editRange: 任意; }[]; (start: 数字, deleteCount: 数字, ...items: { length: 数字; editRange: 任意; }[]): { length: 数字; editRange: 任意; }[]; }
>this.editRanges : { length: 数字; editRange: 任意; }[]
>this : 本体
>editRanges : { length: 数字; editRange: 任意; }[]
>splice : { (start: 数字, deleteCount?: 数字): { length: 数字; editRange: 任意; }[]; (start: 数字, deleteCount: 数字, ...items: { length: 数字; editRange: 任意; }[]): { length: 数字; editRange: 任意; }[]; }
>0 : 0
>this.maxScriptVersions - this.editRanges.length : 数字
>类型别名 :=> 数字
>this.maxScriptVersions : 数字
>类型别名 :=> 数字
>this : 本体
>maxScriptVersions : 数字
>类型别名 :=> 数字
>this.editRanges.length : 数字
>类型别名 :=> 数字
>this.editRanges : { length: 数字; editRange: 任意; }[]
>this : 本体
>editRanges : { length: 数字; editRange: 任意; }[]
>length : 数字
>类型别名 :=> 数字
            }

            // Update version #
            this.version++;
>this.version++ : 数字
>类型别名 :=> 数字
>this.version : 数字
>类型别名 :=> 数字
>this : 本体
>version : 数字
>类型别名 :=> 数字
        }

        public getEditRangeSinceVersion(version: number): TypeScript.ScriptEditRange {
>getEditRangeSinceVersion : (version: 数字) => 任意
>version : 数字
>类型别名 :=> 数字
>TypeScript : 任意
>类型别名 :=> 任意
>ScriptEditRange : No type information available!

            if (this.version == version) {
>this.version == version : 真假
>类型别名 :=> 真假
>this.version : 数字
>类型别名 :=> 数字
>this : 本体
>version : 数字
>类型别名 :=> 数字
>version : 数字
>类型别名 :=> 数字

                // No edits!
                return null;
>null : 空值
>类型别名 :=> 空值
            }

            var initialEditRangeIndex = this.editRanges.length - (this.version - version);
>initialEditRangeIndex : 数字
>类型别名 :=> 数字
>this.editRanges.length - (this.version - version) : 数字
>类型别名 :=> 数字
>this.editRanges.length : 数字
>类型别名 :=> 数字
>this.editRanges : { length: 数字; editRange: 任意; }[]
>this : 本体
>editRanges : { length: 数字; editRange: 任意; }[]
>length : 数字
>类型别名 :=> 数字
>(this.version - version) : 数字
>类型别名 :=> 数字
>this.version - version : 数字
>类型别名 :=> 数字
>this.version : 数字
>类型别名 :=> 数字
>this : 本体
>version : 数字
>类型别名 :=> 数字
>version : 数字
>类型别名 :=> 数字

            if (initialEditRangeIndex < 0 || initialEditRangeIndex >= this.editRanges.length) {
>initialEditRangeIndex < 0 || initialEditRangeIndex >= this.editRanges.length : 真假
>类型别名 :=> 真假
>initialEditRangeIndex < 0 : 真假
>类型别名 :=> 真假
>initialEditRangeIndex : 数字
>类型别名 :=> 数字
>0 : 0
>initialEditRangeIndex >= this.editRanges.length : 真假
>类型别名 :=> 真假
>initialEditRangeIndex : 数字
>类型别名 :=> 数字
>this.editRanges.length : 数字
>类型别名 :=> 数字
>this.editRanges : { length: 数字; editRange: 任意; }[]
>this : 本体
>editRanges : { length: 数字; editRange: 任意; }[]
>length : 数字
>类型别名 :=> 数字

                // Too far away from what we know
                return TypeScript.ScriptEditRange.unknown();
>TypeScript.ScriptEditRange.unknown() : 任意
>类型别名 :=> 任意
>TypeScript.ScriptEditRange.unknown : 任意
>类型别名 :=> 任意
>TypeScript.ScriptEditRange : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>ScriptEditRange : 任意
>类型别名 :=> 任意
>unknown : 任意
>类型别名 :=> 任意
            }

            var entries = this.editRanges.slice(initialEditRangeIndex);
>entries : { length: 数字; editRange: 任意; }[]
>this.editRanges.slice(initialEditRangeIndex) : { length: 数字; editRange: 任意; }[]
>this.editRanges.slice : (start?: 数字, end?: 数字) => { length: 数字; editRange: 任意; }[]
>this.editRanges : { length: 数字; editRange: 任意; }[]
>this : 本体
>editRanges : { length: 数字; editRange: 任意; }[]
>slice : (start?: 数字, end?: 数字) => { length: 数字; editRange: 任意; }[]
>initialEditRangeIndex : 数字
>类型别名 :=> 数字

            var minDistFromStart = entries.map(x => x.editRange.minChar).reduce((prev, current) => Math.min(prev, current));
>minDistFromStart : 任意
>类型别名 :=> 任意
>entries.map(x => x.editRange.minChar).reduce((prev, current) => Math.min(prev, current)) : 任意
>类型别名 :=> 任意
>entries.map(x => x.editRange.minChar).reduce : { (callbackfn: (previousValue: 任意, currentValue: 任意, currentIndex: 数字, array: 任意[]) => 任意): 任意; (callbackfn: (previousValue: 任意, currentValue: 任意, currentIndex: 数字, array: 任意[]) => 任意, initialValue: 任意): 任意; <U>(callbackfn: (previousValue: U, currentValue: 任意, currentIndex: 数字, array: 任意[]) => U, initialValue: U): U; }
>entries.map(x => x.editRange.minChar) : 任意[]
>entries.map : <U>(callbackfn: (value: { length: 数字; editRange: 任意; }, index: 数字, array: { length: 数字; editRange: 任意; }[]) => U, thisArg?: 任意) => U[]
>entries : { length: 数字; editRange: 任意; }[]
>map : <U>(callbackfn: (value: { length: 数字; editRange: 任意; }, index: 数字, array: { length: 数字; editRange: 任意; }[]) => U, thisArg?: 任意) => U[]
>x => x.editRange.minChar : (x: { length: 数字; editRange: 任意; }) => 任意
>x : { length: 数字; editRange: 任意; }
>x.editRange.minChar : 任意
>类型别名 :=> 任意
>x.editRange : 任意
>类型别名 :=> 任意
>x : { length: 数字; editRange: 任意; }
>editRange : 任意
>类型别名 :=> 任意
>minChar : 任意
>类型别名 :=> 任意
>reduce : { (callbackfn: (previousValue: 任意, currentValue: 任意, currentIndex: 数字, array: 任意[]) => 任意): 任意; (callbackfn: (previousValue: 任意, currentValue: 任意, currentIndex: 数字, array: 任意[]) => 任意, initialValue: 任意): 任意; <U>(callbackfn: (previousValue: U, currentValue: 任意, currentIndex: 数字, array: 任意[]) => U, initialValue: U): U; }
>(prev, current) => Math.min(prev, current) : (prev: 任意, current: 任意) => 数字
>prev : 任意
>类型别名 :=> 任意
>current : 任意
>类型别名 :=> 任意
>Math.min(prev, current) : 数字
>类型别名 :=> 数字
>Math.min : (...values: 数字[]) => 数字
>Math : Math
>min : (...values: 数字[]) => 数字
>prev : 任意
>类型别名 :=> 任意
>current : 任意
>类型别名 :=> 任意

            var minDistFromEnd = entries.map(x => x.length - x.editRange.limChar).reduce((prev, current) => Math.min(prev, current));
>minDistFromEnd : 数字
>类型别名 :=> 数字
>entries.map(x => x.length - x.editRange.limChar).reduce((prev, current) => Math.min(prev, current)) : 数字
>类型别名 :=> 数字
>entries.map(x => x.length - x.editRange.limChar).reduce : { (callbackfn: (previousValue: 数字, currentValue: 数字, currentIndex: 数字, array: 数字[]) => 数字): 数字; (callbackfn: (previousValue: 数字, currentValue: 数字, currentIndex: 数字, array: 数字[]) => 数字, initialValue: 数字): 数字; <U>(callbackfn: (previousValue: U, currentValue: 数字, currentIndex: 数字, array: 数字[]) => U, initialValue: U): U; }
>entries.map(x => x.length - x.editRange.limChar) : 数字[]
>entries.map : <U>(callbackfn: (value: { length: 数字; editRange: 任意; }, index: 数字, array: { length: 数字; editRange: 任意; }[]) => U, thisArg?: 任意) => U[]
>entries : { length: 数字; editRange: 任意; }[]
>map : <U>(callbackfn: (value: { length: 数字; editRange: 任意; }, index: 数字, array: { length: 数字; editRange: 任意; }[]) => U, thisArg?: 任意) => U[]
>x => x.length - x.editRange.limChar : (x: { length: 数字; editRange: 任意; }) => 数字
>x : { length: 数字; editRange: 任意; }
>x.length - x.editRange.limChar : 数字
>类型别名 :=> 数字
>x.length : 数字
>类型别名 :=> 数字
>x : { length: 数字; editRange: 任意; }
>length : 数字
>类型别名 :=> 数字
>x.editRange.limChar : 任意
>类型别名 :=> 任意
>x.editRange : 任意
>类型别名 :=> 任意
>x : { length: 数字; editRange: 任意; }
>editRange : 任意
>类型别名 :=> 任意
>limChar : 任意
>类型别名 :=> 任意
>reduce : { (callbackfn: (previousValue: 数字, currentValue: 数字, currentIndex: 数字, array: 数字[]) => 数字): 数字; (callbackfn: (previousValue: 数字, currentValue: 数字, currentIndex: 数字, array: 数字[]) => 数字, initialValue: 数字): 数字; <U>(callbackfn: (previousValue: U, currentValue: 数字, currentIndex: 数字, array: 数字[]) => U, initialValue: U): U; }
>(prev, current) => Math.min(prev, current) : (prev: 数字, current: 数字) => 数字
>prev : 数字
>类型别名 :=> 数字
>current : 数字
>类型别名 :=> 数字
>Math.min(prev, current) : 数字
>类型别名 :=> 数字
>Math.min : (...values: 数字[]) => 数字
>Math : Math
>min : (...values: 数字[]) => 数字
>prev : 数字
>类型别名 :=> 数字
>current : 数字
>类型别名 :=> 数字

            var aggDelta = entries.map(x => x.editRange.delta).reduce((prev, current) => prev + current);
>aggDelta : 任意
>类型别名 :=> 任意
>entries.map(x => x.editRange.delta).reduce((prev, current) => prev + current) : 任意
>类型别名 :=> 任意
>entries.map(x => x.editRange.delta).reduce : { (callbackfn: (previousValue: 任意, currentValue: 任意, currentIndex: 数字, array: 任意[]) => 任意): 任意; (callbackfn: (previousValue: 任意, currentValue: 任意, currentIndex: 数字, array: 任意[]) => 任意, initialValue: 任意): 任意; <U>(callbackfn: (previousValue: U, currentValue: 任意, currentIndex: 数字, array: 任意[]) => U, initialValue: U): U; }
>entries.map(x => x.editRange.delta) : 任意[]
>entries.map : <U>(callbackfn: (value: { length: 数字; editRange: 任意; }, index: 数字, array: { length: 数字; editRange: 任意; }[]) => U, thisArg?: 任意) => U[]
>entries : { length: 数字; editRange: 任意; }[]
>map : <U>(callbackfn: (value: { length: 数字; editRange: 任意; }, index: 数字, array: { length: 数字; editRange: 任意; }[]) => U, thisArg?: 任意) => U[]
>x => x.editRange.delta : (x: { length: 数字; editRange: 任意; }) => 任意
>x : { length: 数字; editRange: 任意; }
>x.editRange.delta : 任意
>类型别名 :=> 任意
>x.editRange : 任意
>类型别名 :=> 任意
>x : { length: 数字; editRange: 任意; }
>editRange : 任意
>类型别名 :=> 任意
>delta : 任意
>类型别名 :=> 任意
>reduce : { (callbackfn: (previousValue: 任意, currentValue: 任意, currentIndex: 数字, array: 任意[]) => 任意): 任意; (callbackfn: (previousValue: 任意, currentValue: 任意, currentIndex: 数字, array: 任意[]) => 任意, initialValue: 任意): 任意; <U>(callbackfn: (previousValue: U, currentValue: 任意, currentIndex: 数字, array: 任意[]) => U, initialValue: U): U; }
>(prev, current) => prev + current : (prev: 任意, current: 任意) => 任意
>prev : 任意
>类型别名 :=> 任意
>current : 任意
>类型别名 :=> 任意
>prev + current : 任意
>类型别名 :=> 任意
>prev : 任意
>类型别名 :=> 任意
>current : 任意
>类型别名 :=> 任意

            return new TypeScript.ScriptEditRange(minDistFromStart, entries[0].length - minDistFromEnd, aggDelta);
>new TypeScript.ScriptEditRange(minDistFromStart, entries[0].length - minDistFromEnd, aggDelta) : 任意
>类型别名 :=> 任意
>TypeScript.ScriptEditRange : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>ScriptEditRange : 任意
>类型别名 :=> 任意
>minDistFromStart : 任意
>类型别名 :=> 任意
>entries[0].length - minDistFromEnd : 数字
>类型别名 :=> 数字
>entries[0].length : 数字
>类型别名 :=> 数字
>entries[0] : { length: 数字; editRange: 任意; }
>entries : { length: 数字; editRange: 任意; }[]
>0 : 0
>length : 数字
>类型别名 :=> 数字
>minDistFromEnd : 数字
>类型别名 :=> 数字
>aggDelta : 任意
>类型别名 :=> 任意
        }
    }

    export class TypeScriptLS implements Services.ILanguageServiceShimHost {
>TypeScriptLS : TypeScriptLS
>Services.ILanguageServiceShimHost : 任意
>类型别名 :=> 任意
>Services : 任意
>类型别名 :=> 任意
>ILanguageServiceShimHost : No type information available!

        private ls: Services.ILanguageServiceShim = null;
>ls : 任意
>类型别名 :=> 任意
>Services : 任意
>类型别名 :=> 任意
>ILanguageServiceShim : No type information available!
>null : 空值
>类型别名 :=> 空值

        public scripts: ScriptInfo[] = [];
>scripts : ScriptInfo[]
>ScriptInfo : ScriptInfo
>[] : 未定[]

        public maxScriptVersions = 100;
>maxScriptVersions : 数字
>类型别名 :=> 数字
>100 : 100

        public addDefaultLibrary() {
>addDefaultLibrary : () => 无值

            this.addScript("lib.d.ts", Harness.Compiler.libText, true);
>this.addScript("lib.d.ts", Harness.Compiler.libText, true) : 无值
>类型别名 :=> 无值
>this.addScript : (name: 文字, content: 文字, isResident?: 真假) => 无值
>this : 本体
>addScript : (name: 文字, content: 文字, isResident?: 真假) => 无值
>"lib.d.ts" : "lib.d.ts"
>Harness.Compiler.libText : 任意
>类型别名 :=> 任意
>Harness.Compiler : 类为 Compiler
>Harness : 类为 Harness
>Compiler : 类为 Compiler
>libText : 任意
>类型别名 :=> 任意
>true : 为真
>类型别名 :=> 为真
        }

        public addFile(name: string, isResident = false) {
>addFile : (name: 文字, isResident?: 真假) => 无值
>name : 文字
>类型别名 :=> 文字
>isResident : 真假
>类型别名 :=> 真假
>false : 为假
>类型别名 :=> 为假

            var code: string = readFile(name);
>code : 文字
>类型别名 :=> 文字
>readFile(name) : 任意
>类型别名 :=> 任意
>readFile : (path: 文字) => 任意
>name : 文字
>类型别名 :=> 文字

            this.addScript(name, code, isResident);
>this.addScript(name, code, isResident) : 无值
>类型别名 :=> 无值
>this.addScript : (name: 文字, content: 文字, isResident?: 真假) => 无值
>this : 本体
>addScript : (name: 文字, content: 文字, isResident?: 真假) => 无值
>name : 文字
>类型别名 :=> 文字
>code : 文字
>类型别名 :=> 文字
>isResident : 真假
>类型别名 :=> 真假
        }

        public addScript(name: string, content: string, isResident = false) {
>addScript : (name: 文字, content: 文字, isResident?: 真假) => 无值
>name : 文字
>类型别名 :=> 文字
>content : 文字
>类型别名 :=> 文字
>isResident : 真假
>类型别名 :=> 真假
>false : 为假
>类型别名 :=> 为假

            var script = new ScriptInfo(name, content, isResident, this.maxScriptVersions);
>script : ScriptInfo
>new ScriptInfo(name, content, isResident, this.maxScriptVersions) : ScriptInfo
>ScriptInfo : 类为 ScriptInfo
>name : 文字
>类型别名 :=> 文字
>content : 文字
>类型别名 :=> 文字
>isResident : 真假
>类型别名 :=> 真假
>this.maxScriptVersions : 数字
>类型别名 :=> 数字
>this : 本体
>maxScriptVersions : 数字
>类型别名 :=> 数字

            this.scripts.push(script);
>this.scripts.push(script) : 数字
>类型别名 :=> 数字
>this.scripts.push : (...items: ScriptInfo[]) => 数字
>this.scripts : ScriptInfo[]
>this : 本体
>scripts : ScriptInfo[]
>push : (...items: ScriptInfo[]) => 数字
>script : ScriptInfo
        }

        public updateScript(name: string, content: string, isResident = false) {
>updateScript : (name: 文字, content: 文字, isResident?: 真假) => 无值
>name : 文字
>类型别名 :=> 文字
>content : 文字
>类型别名 :=> 文字
>isResident : 真假
>类型别名 :=> 真假
>false : 为假
>类型别名 :=> 为假

            for (var i = 0; i < this.scripts.length; i++) {
>i : 数字
>类型别名 :=> 数字
>0 : 0
>i < this.scripts.length : 真假
>类型别名 :=> 真假
>i : 数字
>类型别名 :=> 数字
>this.scripts.length : 数字
>类型别名 :=> 数字
>this.scripts : ScriptInfo[]
>this : 本体
>scripts : ScriptInfo[]
>length : 数字
>类型别名 :=> 数字
>i++ : 数字
>类型别名 :=> 数字
>i : 数字
>类型别名 :=> 数字

                if (this.scripts[i].name == name) {
>this.scripts[i].name == name : 真假
>类型别名 :=> 真假
>this.scripts[i].name : 文字
>类型别名 :=> 文字
>this.scripts[i] : ScriptInfo
>this.scripts : ScriptInfo[]
>this : 本体
>scripts : ScriptInfo[]
>i : 数字
>类型别名 :=> 数字
>name : 文字
>类型别名 :=> 文字
>name : 文字
>类型别名 :=> 文字

                    this.scripts[i].updateContent(content, isResident);
>this.scripts[i].updateContent(content, isResident) : 无值
>类型别名 :=> 无值
>this.scripts[i].updateContent : (content: 文字, isResident: 真假) => 无值
>this.scripts[i] : ScriptInfo
>this.scripts : ScriptInfo[]
>this : 本体
>scripts : ScriptInfo[]
>i : 数字
>类型别名 :=> 数字
>updateContent : (content: 文字, isResident: 真假) => 无值
>content : 文字
>类型别名 :=> 文字
>isResident : 真假
>类型别名 :=> 真假

                    return;
                }
            }

            this.addScript(name, content, isResident);
>this.addScript(name, content, isResident) : 无值
>类型别名 :=> 无值
>this.addScript : (name: 文字, content: 文字, isResident?: 真假) => 无值
>this : 本体
>addScript : (name: 文字, content: 文字, isResident?: 真假) => 无值
>name : 文字
>类型别名 :=> 文字
>content : 文字
>类型别名 :=> 文字
>isResident : 真假
>类型别名 :=> 真假
        }

        public editScript(name: string, minChar: number, limChar: number, newText: string) {
>editScript : (name: 文字, minChar: 数字, limChar: 数字, newText: 文字) => 无值
>name : 文字
>类型别名 :=> 文字
>minChar : 数字
>类型别名 :=> 数字
>limChar : 数字
>类型别名 :=> 数字
>newText : 文字
>类型别名 :=> 文字

            for (var i = 0; i < this.scripts.length; i++) {
>i : 数字
>类型别名 :=> 数字
>0 : 0
>i < this.scripts.length : 真假
>类型别名 :=> 真假
>i : 数字
>类型别名 :=> 数字
>this.scripts.length : 数字
>类型别名 :=> 数字
>this.scripts : ScriptInfo[]
>this : 本体
>scripts : ScriptInfo[]
>length : 数字
>类型别名 :=> 数字
>i++ : 数字
>类型别名 :=> 数字
>i : 数字
>类型别名 :=> 数字

                if (this.scripts[i].name == name) {
>this.scripts[i].name == name : 真假
>类型别名 :=> 真假
>this.scripts[i].name : 文字
>类型别名 :=> 文字
>this.scripts[i] : ScriptInfo
>this.scripts : ScriptInfo[]
>this : 本体
>scripts : ScriptInfo[]
>i : 数字
>类型别名 :=> 数字
>name : 文字
>类型别名 :=> 文字
>name : 文字
>类型别名 :=> 文字

                    this.scripts[i].editContent(minChar, limChar, newText);
>this.scripts[i].editContent(minChar, limChar, newText) : 无值
>类型别名 :=> 无值
>this.scripts[i].editContent : (minChar: 数字, limChar: 数字, newText: 文字) => 无值
>this.scripts[i] : ScriptInfo
>this.scripts : ScriptInfo[]
>this : 本体
>scripts : ScriptInfo[]
>i : 数字
>类型别名 :=> 数字
>editContent : (minChar: 数字, limChar: 数字, newText: 文字) => 无值
>minChar : 数字
>类型别名 :=> 数字
>limChar : 数字
>类型别名 :=> 数字
>newText : 文字
>类型别名 :=> 文字

                    return;
                }
            }

            throw new Error("No script with name '" + name + "'");
>new Error("No script with name '" + name + "'") : Error
>Error : ErrorConstructor
>"No script with name '" + name + "'" : 文字
>类型别名 :=> 文字
>"No script with name '" + name : 文字
>类型别名 :=> 文字
>"No script with name '" : "No script with name '"
>name : 文字
>类型别名 :=> 文字
>"'" : "'"
        }

        public getScriptContent(scriptIndex: number): string {
>getScriptContent : (scriptIndex: 数字) => 文字
>scriptIndex : 数字
>类型别名 :=> 数字

            return this.scripts[scriptIndex].content;
>this.scripts[scriptIndex].content : 文字
>类型别名 :=> 文字
>this.scripts[scriptIndex] : ScriptInfo
>this.scripts : ScriptInfo[]
>this : 本体
>scripts : ScriptInfo[]
>scriptIndex : 数字
>类型别名 :=> 数字
>content : 文字
>类型别名 :=> 文字
        }

        //////////////////////////////////////////////////////////////////////
        // ILogger implementation
        //
        public information(): boolean { return false; }
>information : () => 真假
>false : 为假
>类型别名 :=> 为假

        public debug(): boolean { return true; }
>debug : () => 真假
>true : 为真
>类型别名 :=> 为真

        public warning(): boolean { return true; }
>warning : () => 真假
>true : 为真
>类型别名 :=> 为真

        public error(): boolean { return true; }
>error : () => 真假
>true : 为真
>类型别名 :=> 为真

        public fatal(): boolean { return true; }
>fatal : () => 真假
>true : 为真
>类型别名 :=> 为真

        public log(s: string): void {
>log : (s: 文字) => 无值
>s : 文字
>类型别名 :=> 文字

            // For debugging...
            //IO.printLine("TypeScriptLS:" + s);
        }

        //////////////////////////////////////////////////////////////////////
        // ILanguageServiceShimHost implementation
        //

        public getCompilationSettings(): string/*json for Tools.CompilationSettings*/ {
>getCompilationSettings : () => 文字

            return ""; // i.e. default settings
>"" : ""
        }

        public getScriptCount(): number {
>getScriptCount : () => 数字

            return this.scripts.length;
>this.scripts.length : 数字
>类型别名 :=> 数字
>this.scripts : ScriptInfo[]
>this : 本体
>scripts : ScriptInfo[]
>length : 数字
>类型别名 :=> 数字
        }

        public getScriptSourceText(scriptIndex: number, start: number, end: number): string {
>getScriptSourceText : (scriptIndex: 数字, start: 数字, end: 数字) => 文字
>scriptIndex : 数字
>类型别名 :=> 数字
>start : 数字
>类型别名 :=> 数字
>end : 数字
>类型别名 :=> 数字

            return this.scripts[scriptIndex].content.substring(start, end);
>this.scripts[scriptIndex].content.substring(start, end) : 文字
>类型别名 :=> 文字
>this.scripts[scriptIndex].content.substring : (start: 数字, end?: 数字) => 文字
>this.scripts[scriptIndex].content : 文字
>类型别名 :=> 文字
>this.scripts[scriptIndex] : ScriptInfo
>this.scripts : ScriptInfo[]
>this : 本体
>scripts : ScriptInfo[]
>scriptIndex : 数字
>类型别名 :=> 数字
>content : 文字
>类型别名 :=> 文字
>substring : (start: 数字, end?: 数字) => 文字
>start : 数字
>类型别名 :=> 数字
>end : 数字
>类型别名 :=> 数字
        }

        public getScriptSourceLength(scriptIndex: number): number {
>getScriptSourceLength : (scriptIndex: 数字) => 数字
>scriptIndex : 数字
>类型别名 :=> 数字

            return this.scripts[scriptIndex].content.length;
>this.scripts[scriptIndex].content.length : 数字
>类型别名 :=> 数字
>this.scripts[scriptIndex].content : 文字
>类型别名 :=> 文字
>this.scripts[scriptIndex] : ScriptInfo
>this.scripts : ScriptInfo[]
>this : 本体
>scripts : ScriptInfo[]
>scriptIndex : 数字
>类型别名 :=> 数字
>content : 文字
>类型别名 :=> 文字
>length : 数字
>类型别名 :=> 数字
        }

        public getScriptId(scriptIndex: number): string {
>getScriptId : (scriptIndex: 数字) => 文字
>scriptIndex : 数字
>类型别名 :=> 数字

            return this.scripts[scriptIndex].name;
>this.scripts[scriptIndex].name : 文字
>类型别名 :=> 文字
>this.scripts[scriptIndex] : ScriptInfo
>this.scripts : ScriptInfo[]
>this : 本体
>scripts : ScriptInfo[]
>scriptIndex : 数字
>类型别名 :=> 数字
>name : 文字
>类型别名 :=> 文字
        }

        public getScriptIsResident(scriptIndex: number): boolean {
>getScriptIsResident : (scriptIndex: 数字) => 真假
>scriptIndex : 数字
>类型别名 :=> 数字

            return this.scripts[scriptIndex].isResident;
>this.scripts[scriptIndex].isResident : 真假
>类型别名 :=> 真假
>this.scripts[scriptIndex] : ScriptInfo
>this.scripts : ScriptInfo[]
>this : 本体
>scripts : ScriptInfo[]
>scriptIndex : 数字
>类型别名 :=> 数字
>isResident : 真假
>类型别名 :=> 真假
        }

        public getScriptVersion(scriptIndex: number): number {
>getScriptVersion : (scriptIndex: 数字) => 数字
>scriptIndex : 数字
>类型别名 :=> 数字

            return this.scripts[scriptIndex].version;
>this.scripts[scriptIndex].version : 数字
>类型别名 :=> 数字
>this.scripts[scriptIndex] : ScriptInfo
>this.scripts : ScriptInfo[]
>this : 本体
>scripts : ScriptInfo[]
>scriptIndex : 数字
>类型别名 :=> 数字
>version : 数字
>类型别名 :=> 数字
        }

        public getScriptEditRangeSinceVersion(scriptIndex: number, scriptVersion: number): string {
>getScriptEditRangeSinceVersion : (scriptIndex: 数字, scriptVersion: 数字) => 文字
>scriptIndex : 数字
>类型别名 :=> 数字
>scriptVersion : 数字
>类型别名 :=> 数字

            var range = this.scripts[scriptIndex].getEditRangeSinceVersion(scriptVersion);
>range : 任意
>类型别名 :=> 任意
>this.scripts[scriptIndex].getEditRangeSinceVersion(scriptVersion) : 任意
>类型别名 :=> 任意
>this.scripts[scriptIndex].getEditRangeSinceVersion : (version: 数字) => 任意
>this.scripts[scriptIndex] : ScriptInfo
>this.scripts : ScriptInfo[]
>this : 本体
>scripts : ScriptInfo[]
>scriptIndex : 数字
>类型别名 :=> 数字
>getEditRangeSinceVersion : (version: 数字) => 任意
>scriptVersion : 数字
>类型别名 :=> 数字

            var result = (range.minChar + "," + range.limChar + "," + range.delta);
>result : 文字
>类型别名 :=> 文字
>(range.minChar + "," + range.limChar + "," + range.delta) : 文字
>类型别名 :=> 文字
>range.minChar + "," + range.limChar + "," + range.delta : 文字
>类型别名 :=> 文字
>range.minChar + "," + range.limChar + "," : 文字
>类型别名 :=> 文字
>range.minChar + "," + range.limChar : 文字
>类型别名 :=> 文字
>range.minChar + "," : 文字
>类型别名 :=> 文字
>range.minChar : 任意
>类型别名 :=> 任意
>range : 任意
>类型别名 :=> 任意
>minChar : 任意
>类型别名 :=> 任意
>"," : ","
>range.limChar : 任意
>类型别名 :=> 任意
>range : 任意
>类型别名 :=> 任意
>limChar : 任意
>类型别名 :=> 任意
>"," : ","
>range.delta : 任意
>类型别名 :=> 任意
>range : 任意
>类型别名 :=> 任意
>delta : 任意
>类型别名 :=> 任意

            return result;
>result : 文字
>类型别名 :=> 文字
        }

        /** Return a new instance of the language service shim, up-to-date wrt to typecheck.
         *  To access the non-shim (i.e. actual) language service, use the "ls.languageService" property.
         */
        public getLanguageService(): Services.ILanguageServiceShim {
>getLanguageService : () => 任意
>Services : 任意
>类型别名 :=> 任意
>ILanguageServiceShim : No type information available!

            var ls = new Services.TypeScriptServicesFactory().createLanguageServiceShim(this);
>ls : 任意
>类型别名 :=> 任意
>new Services.TypeScriptServicesFactory().createLanguageServiceShim(this) : 任意
>类型别名 :=> 任意
>new Services.TypeScriptServicesFactory().createLanguageServiceShim : 任意
>类型别名 :=> 任意
>new Services.TypeScriptServicesFactory() : 任意
>类型别名 :=> 任意
>Services.TypeScriptServicesFactory : 任意
>类型别名 :=> 任意
>Services : 任意
>类型别名 :=> 任意
>TypeScriptServicesFactory : 任意
>类型别名 :=> 任意
>createLanguageServiceShim : 任意
>类型别名 :=> 任意
>this : 本体

            ls.refresh(true);
>ls.refresh(true) : 任意
>类型别名 :=> 任意
>ls.refresh : 任意
>类型别名 :=> 任意
>ls : 任意
>类型别名 :=> 任意
>refresh : 任意
>类型别名 :=> 任意
>true : 为真
>类型别名 :=> 为真

            this.ls = ls;
>this.ls = ls : 任意
>类型别名 :=> 任意
>this.ls : 任意
>类型别名 :=> 任意
>this : 本体
>ls : 任意
>类型别名 :=> 任意
>ls : 任意
>类型别名 :=> 任意

            return ls;
>ls : 任意
>类型别名 :=> 任意
        }

        /** Parse file given its source text */
        public parseSourceText(fileName: string, sourceText: TypeScript.ISourceText): TypeScript.Script {
>parseSourceText : (fileName: 文字, sourceText: 任意) => 任意
>fileName : 文字
>类型别名 :=> 文字
>sourceText : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>ISourceText : No type information available!
>TypeScript : 任意
>类型别名 :=> 任意
>Script : No type information available!

            var parser = new TypeScript.Parser();
>parser : 任意
>类型别名 :=> 任意
>new TypeScript.Parser() : 任意
>类型别名 :=> 任意
>TypeScript.Parser : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>Parser : 任意
>类型别名 :=> 任意

            parser.setErrorRecovery(null);
>parser.setErrorRecovery(null) : 任意
>类型别名 :=> 任意
>parser.setErrorRecovery : 任意
>类型别名 :=> 任意
>parser : 任意
>类型别名 :=> 任意
>setErrorRecovery : 任意
>类型别名 :=> 任意
>null : 空值
>类型别名 :=> 空值

            parser.errorCallback = (a, b, c, d) => { };
>parser.errorCallback = (a, b, c, d) => { } : (a: 任意, b: 任意, c: 任意, d: 任意) => 无值
>parser.errorCallback : 任意
>类型别名 :=> 任意
>parser : 任意
>类型别名 :=> 任意
>errorCallback : 任意
>类型别名 :=> 任意
>(a, b, c, d) => { } : (a: 任意, b: 任意, c: 任意, d: 任意) => 无值
>a : 任意
>类型别名 :=> 任意
>b : 任意
>类型别名 :=> 任意
>c : 任意
>类型别名 :=> 任意
>d : 任意
>类型别名 :=> 任意

            var script = parser.parse(sourceText, fileName, 0);
>script : 任意
>类型别名 :=> 任意
>parser.parse(sourceText, fileName, 0) : 任意
>类型别名 :=> 任意
>parser.parse : 任意
>类型别名 :=> 任意
>parser : 任意
>类型别名 :=> 任意
>parse : 任意
>类型别名 :=> 任意
>sourceText : 任意
>类型别名 :=> 任意
>fileName : 文字
>类型别名 :=> 文字
>0 : 0

            return script;
>script : 任意
>类型别名 :=> 任意
        }

        /** Parse a file on disk given its filename */
        public parseFile(fileName: string) {
>parseFile : (fileName: 文字) => 任意
>fileName : 文字
>类型别名 :=> 文字

            var sourceText = new TypeScript.StringSourceText(IO.readFile(fileName))
>sourceText : 任意
>类型别名 :=> 任意
>new TypeScript.StringSourceText(IO.readFile(fileName)) : 任意
>类型别名 :=> 任意
>TypeScript.StringSourceText : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>StringSourceText : 任意
>类型别名 :=> 任意
>IO.readFile(fileName) : 任意
>类型别名 :=> 任意
>IO.readFile : 任意
>类型别名 :=> 任意
>IO : 任意
>类型别名 :=> 任意
>readFile : 任意
>类型别名 :=> 任意
>fileName : 文字
>类型别名 :=> 文字

            return this.parseSourceText(fileName, sourceText);
>this.parseSourceText(fileName, sourceText) : 任意
>类型别名 :=> 任意
>this.parseSourceText : (fileName: 文字, sourceText: 任意) => 任意
>this : 本体
>parseSourceText : (fileName: 文字, sourceText: 任意) => 任意
>fileName : 文字
>类型别名 :=> 文字
>sourceText : 任意
>类型别名 :=> 任意
        }
        
        /**
         * @param line 1 based index
         * @param col 1 based index
        */
        public lineColToPosition(fileName: string, line: number, col: number): number {
>lineColToPosition : (fileName: 文字, line: 数字, col: 数字) => 数字
>fileName : 文字
>类型别名 :=> 文字
>line : 数字
>类型别名 :=> 数字
>col : 数字
>类型别名 :=> 数字

            var script = this.ls.languageService.getScriptAST(fileName);
>script : 任意
>类型别名 :=> 任意
>this.ls.languageService.getScriptAST(fileName) : 任意
>类型别名 :=> 任意
>this.ls.languageService.getScriptAST : 任意
>类型别名 :=> 任意
>this.ls.languageService : 任意
>类型别名 :=> 任意
>this.ls : 任意
>类型别名 :=> 任意
>this : 本体
>ls : 任意
>类型别名 :=> 任意
>languageService : 任意
>类型别名 :=> 任意
>getScriptAST : 任意
>类型别名 :=> 任意
>fileName : 文字
>类型别名 :=> 文字

            assert.notNull(script);
>assert.notNull(script) : 任意
>类型别名 :=> 任意
>assert.notNull : 任意
>类型别名 :=> 任意
>assert : 任意
>类型别名 :=> 任意
>notNull : 任意
>类型别名 :=> 任意
>script : 任意
>类型别名 :=> 任意

            assert.is(line >= 1);
>assert.is(line >= 1) : 任意
>类型别名 :=> 任意
>assert.is : 任意
>类型别名 :=> 任意
>assert : 任意
>类型别名 :=> 任意
>is : 任意
>类型别名 :=> 任意
>line >= 1 : 真假
>类型别名 :=> 真假
>line : 数字
>类型别名 :=> 数字
>1 : 1

            assert.is(col >= 1);
>assert.is(col >= 1) : 任意
>类型别名 :=> 任意
>assert.is : 任意
>类型别名 :=> 任意
>assert : 任意
>类型别名 :=> 任意
>is : 任意
>类型别名 :=> 任意
>col >= 1 : 真假
>类型别名 :=> 真假
>col : 数字
>类型别名 :=> 数字
>1 : 1

            assert.is(line <= script.locationInfo.lineMap.length);
>assert.is(line <= script.locationInfo.lineMap.length) : 任意
>类型别名 :=> 任意
>assert.is : 任意
>类型别名 :=> 任意
>assert : 任意
>类型别名 :=> 任意
>is : 任意
>类型别名 :=> 任意
>line <= script.locationInfo.lineMap.length : 真假
>类型别名 :=> 真假
>line : 数字
>类型别名 :=> 数字
>script.locationInfo.lineMap.length : 任意
>类型别名 :=> 任意
>script.locationInfo.lineMap : 任意
>类型别名 :=> 任意
>script.locationInfo : 任意
>类型别名 :=> 任意
>script : 任意
>类型别名 :=> 任意
>locationInfo : 任意
>类型别名 :=> 任意
>lineMap : 任意
>类型别名 :=> 任意
>length : 任意
>类型别名 :=> 任意

            return TypeScript.getPositionFromZeroBasedLineColumn(script, line - 1, col - 1);
>TypeScript.getPositionFromZeroBasedLineColumn(script, line - 1, col - 1) : 任意
>类型别名 :=> 任意
>TypeScript.getPositionFromZeroBasedLineColumn : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>getPositionFromZeroBasedLineColumn : 任意
>类型别名 :=> 任意
>script : 任意
>类型别名 :=> 任意
>line - 1 : 数字
>类型别名 :=> 数字
>line : 数字
>类型别名 :=> 数字
>1 : 1
>col - 1 : 数字
>类型别名 :=> 数字
>col : 数字
>类型别名 :=> 数字
>1 : 1
        }

        /**
         * @param line 0 based index
         * @param col 0 based index
        */
        public positionToZeroBasedLineCol(fileName: string, position: number): TypeScript.ILineCol {
>positionToZeroBasedLineCol : (fileName: 文字, position: 数字) => 任意
>fileName : 文字
>类型别名 :=> 文字
>position : 数字
>类型别名 :=> 数字
>TypeScript : 任意
>类型别名 :=> 任意
>ILineCol : No type information available!

            var script = this.ls.languageService.getScriptAST(fileName);
>script : 任意
>类型别名 :=> 任意
>this.ls.languageService.getScriptAST(fileName) : 任意
>类型别名 :=> 任意
>this.ls.languageService.getScriptAST : 任意
>类型别名 :=> 任意
>this.ls.languageService : 任意
>类型别名 :=> 任意
>this.ls : 任意
>类型别名 :=> 任意
>this : 本体
>ls : 任意
>类型别名 :=> 任意
>languageService : 任意
>类型别名 :=> 任意
>getScriptAST : 任意
>类型别名 :=> 任意
>fileName : 文字
>类型别名 :=> 文字

            assert.notNull(script);
>assert.notNull(script) : 任意
>类型别名 :=> 任意
>assert.notNull : 任意
>类型别名 :=> 任意
>assert : 任意
>类型别名 :=> 任意
>notNull : 任意
>类型别名 :=> 任意
>script : 任意
>类型别名 :=> 任意

            var result = TypeScript.getZeroBasedLineColumnFromPosition(script, position);
>result : 任意
>类型别名 :=> 任意
>TypeScript.getZeroBasedLineColumnFromPosition(script, position) : 任意
>类型别名 :=> 任意
>TypeScript.getZeroBasedLineColumnFromPosition : 任意
>类型别名 :=> 任意
>TypeScript : 任意
>类型别名 :=> 任意
>getZeroBasedLineColumnFromPosition : 任意
>类型别名 :=> 任意
>script : 任意
>类型别名 :=> 任意
>position : 数字
>类型别名 :=> 数字

            assert.is(result.line >= 0);
>assert.is(result.line >= 0) : 任意
>类型别名 :=> 任意
>assert.is : 任意
>类型别名 :=> 任意
>assert : 任意
>类型别名 :=> 任意
>is : 任意
>类型别名 :=> 任意
>result.line >= 0 : 真假
>类型别名 :=> 真假
>result.line : 任意
>类型别名 :=> 任意
>result : 任意
>类型别名 :=> 任意
>line : 任意
>类型别名 :=> 任意
>0 : 0

            assert.is(result.col >= 0);
>assert.is(result.col >= 0) : 任意
>类型别名 :=> 任意
>assert.is : 任意
>类型别名 :=> 任意
>assert : 任意
>类型别名 :=> 任意
>is : 任意
>类型别名 :=> 任意
>result.col >= 0 : 真假
>类型别名 :=> 真假
>result.col : 任意
>类型别名 :=> 任意
>result : 任意
>类型别名 :=> 任意
>col : 任意
>类型别名 :=> 任意
>0 : 0

            return result;
>result : 任意
>类型别名 :=> 任意
        }

        /** Verify that applying edits to sourceFileName result in the content of the file baselineFileName */
        public checkEdits(sourceFileName: string, baselineFileName: string, edits: Services.TextEdit[]) {
>checkEdits : (sourceFileName: 文字, baselineFileName: 文字, edits: 任意[]) => 无值
>sourceFileName : 文字
>类型别名 :=> 文字
>baselineFileName : 文字
>类型别名 :=> 文字
>edits : 任意[]
>Services : 任意
>类型别名 :=> 任意
>TextEdit : No type information available!

            var script = readFile(sourceFileName);
>script : 任意
>类型别名 :=> 任意
>readFile(sourceFileName) : 任意
>类型别名 :=> 任意
>readFile : (path: 文字) => 任意
>sourceFileName : 文字
>类型别名 :=> 文字

            var formattedScript = this.applyEdits(script, edits);
>formattedScript : 文字
>类型别名 :=> 文字
>this.applyEdits(script, edits) : 文字
>类型别名 :=> 文字
>this.applyEdits : (content: 文字, edits: 任意[]) => 文字
>this : 本体
>applyEdits : (content: 文字, edits: 任意[]) => 文字
>script : 任意
>类型别名 :=> 任意
>edits : 任意[]

            var baseline = readFile(baselineFileName);
>baseline : 任意
>类型别名 :=> 任意
>readFile(baselineFileName) : 任意
>类型别名 :=> 任意
>readFile : (path: 文字) => 任意
>baselineFileName : 文字
>类型别名 :=> 文字

            assert.noDiff(formattedScript, baseline);
>assert.noDiff(formattedScript, baseline) : 任意
>类型别名 :=> 任意
>assert.noDiff : 任意
>类型别名 :=> 任意
>assert : 任意
>类型别名 :=> 任意
>noDiff : 任意
>类型别名 :=> 任意
>formattedScript : 文字
>类型别名 :=> 文字
>baseline : 任意
>类型别名 :=> 任意

            assert.equal(formattedScript, baseline);
>assert.equal(formattedScript, baseline) : 任意
>类型别名 :=> 任意
>assert.equal : 任意
>类型别名 :=> 任意
>assert : 任意
>类型别名 :=> 任意
>equal : 任意
>类型别名 :=> 任意
>formattedScript : 文字
>类型别名 :=> 文字
>baseline : 任意
>类型别名 :=> 任意
        }


        /** Apply an array of text edits to a string, and return the resulting string. */
        public applyEdits(content: string, edits: Services.TextEdit[]): string {
>applyEdits : (content: 文字, edits: 任意[]) => 文字
>content : 文字
>类型别名 :=> 文字
>edits : 任意[]
>Services : 任意
>类型别名 :=> 任意
>TextEdit : No type information available!

            var result = content;
>result : 文字
>类型别名 :=> 文字
>content : 文字
>类型别名 :=> 文字

            edits = this.normalizeEdits(edits);
>edits = this.normalizeEdits(edits) : 任意[]
>edits : 任意[]
>this.normalizeEdits(edits) : 任意[]
>this.normalizeEdits : (edits: 任意[]) => 任意[]
>this : 本体
>normalizeEdits : (edits: 任意[]) => 任意[]
>edits : 任意[]

            for (var i = edits.length - 1; i >= 0; i--) {
>i : 数字
>类型别名 :=> 数字
>edits.length - 1 : 数字
>类型别名 :=> 数字
>edits.length : 数字
>类型别名 :=> 数字
>edits : 任意[]
>length : 数字
>类型别名 :=> 数字
>1 : 1
>i >= 0 : 真假
>类型别名 :=> 真假
>i : 数字
>类型别名 :=> 数字
>0 : 0
>i-- : 数字
>类型别名 :=> 数字
>i : 数字
>类型别名 :=> 数字

                var edit = edits[i];
>edit : 任意
>类型别名 :=> 任意
>edits[i] : 任意
>类型别名 :=> 任意
>edits : 任意[]
>i : 数字
>类型别名 :=> 数字

                var prefix = result.substring(0, edit.minChar);
>prefix : 文字
>类型别名 :=> 文字
>result.substring(0, edit.minChar) : 文字
>类型别名 :=> 文字
>result.substring : (start: 数字, end?: 数字) => 文字
>result : 文字
>类型别名 :=> 文字
>substring : (start: 数字, end?: 数字) => 文字
>0 : 0
>edit.minChar : 任意
>类型别名 :=> 任意
>edit : 任意
>类型别名 :=> 任意
>minChar : 任意
>类型别名 :=> 任意

                var middle = edit.text;
>middle : 任意
>类型别名 :=> 任意
>edit.text : 任意
>类型别名 :=> 任意
>edit : 任意
>类型别名 :=> 任意
>text : 任意
>类型别名 :=> 任意

                var suffix = result.substring(edit.limChar);
>suffix : 文字
>类型别名 :=> 文字
>result.substring(edit.limChar) : 文字
>类型别名 :=> 文字
>result.substring : (start: 数字, end?: 数字) => 文字
>result : 文字
>类型别名 :=> 文字
>substring : (start: 数字, end?: 数字) => 文字
>edit.limChar : 任意
>类型别名 :=> 任意
>edit : 任意
>类型别名 :=> 任意
>limChar : 任意
>类型别名 :=> 任意

                result = prefix + middle + suffix;
>result = prefix + middle + suffix : 文字
>类型别名 :=> 文字
>result : 文字
>类型别名 :=> 文字
>prefix + middle + suffix : 文字
>类型别名 :=> 文字
>prefix + middle : 文字
>类型别名 :=> 文字
>prefix : 文字
>类型别名 :=> 文字
>middle : 任意
>类型别名 :=> 任意
>suffix : 文字
>类型别名 :=> 文字
            }
            return result;
>result : 文字
>类型别名 :=> 文字
        }

        /** Normalize an array of edits by removing overlapping entries and sorting entries on the minChar position. */
        private normalizeEdits(edits: Services.TextEdit[]): Services.TextEdit[] {
>normalizeEdits : (edits: 任意[]) => 任意[]
>edits : 任意[]
>Services : 任意
>类型别名 :=> 任意
>TextEdit : No type information available!
>Services : 任意
>类型别名 :=> 任意
>TextEdit : No type information available!

            var result: Services.TextEdit[] = [];
>result : 任意[]
>Services : 任意
>类型别名 :=> 任意
>TextEdit : No type information available!
>[] : 未定[]

            function mapEdits(edits: Services.TextEdit[]): { edit: Services.TextEdit; index: number; }[] {
>mapEdits : (edits: 任意[]) => { edit: 任意; index: 数字; }[]
>edits : 任意[]
>Services : 任意
>类型别名 :=> 任意
>TextEdit : No type information available!
>edit : 任意
>类型别名 :=> 任意
>Services : 任意
>类型别名 :=> 任意
>TextEdit : No type information available!
>index : 数字
>类型别名 :=> 数字

                var result = [];
>result : 任意[]
>[] : 未定[]

                for (var i = 0; i < edits.length; i++) {
>i : 数字
>类型别名 :=> 数字
>0 : 0
>i < edits.length : 真假
>类型别名 :=> 真假
>i : 数字
>类型别名 :=> 数字
>edits.length : 数字
>类型别名 :=> 数字
>edits : 任意[]
>length : 数字
>类型别名 :=> 数字
>i++ : 数字
>类型别名 :=> 数字
>i : 数字
>类型别名 :=> 数字

                    result.push({ edit: edits[i], index: i });
>result.push({ edit: edits[i], index: i }) : 数字
>类型别名 :=> 数字
>result.push : (...items: 任意[]) => 数字
>result : 任意[]
>push : (...items: 任意[]) => 数字
>{ edit: edits[i], index: i } : { edit: 任意; index: 数字; }
>edit : 任意
>类型别名 :=> 任意
>edits[i] : 任意
>类型别名 :=> 任意
>edits : 任意[]
>i : 数字
>类型别名 :=> 数字
>index : 数字
>类型别名 :=> 数字
>i : 数字
>类型别名 :=> 数字
                }
                return result;
>result : 任意[]
            }

            var temp = mapEdits(edits).sort(function (a, b) {
>temp : { edit: 任意; index: 数字; }[]
>mapEdits(edits).sort(function (a, b) {                var result = a.edit.minChar - b.edit.minChar;                if (result == 0)                    result = a.index - b.index;                return result;            }) : { edit: 任意; index: 数字; }[]
>mapEdits(edits).sort : (compareFn?: (a: { edit: 任意; index: 数字; }, b: { edit: 任意; index: 数字; }) => 数字) => { edit: 任意; index: 数字; }[]
>mapEdits(edits) : { edit: 任意; index: 数字; }[]
>mapEdits : (edits: 任意[]) => { edit: 任意; index: 数字; }[]
>edits : 任意[]
>sort : (compareFn?: (a: { edit: 任意; index: 数字; }, b: { edit: 任意; index: 数字; }) => 数字) => { edit: 任意; index: 数字; }[]
>function (a, b) {                var result = a.edit.minChar - b.edit.minChar;                if (result == 0)                    result = a.index - b.index;                return result;            } : (a: { edit: 任意; index: 数字; }, b: { edit: 任意; index: 数字; }) => 数字
>a : { edit: 任意; index: 数字; }
>b : { edit: 任意; index: 数字; }

                var result = a.edit.minChar - b.edit.minChar;
>result : 数字
>类型别名 :=> 数字
>a.edit.minChar - b.edit.minChar : 数字
>类型别名 :=> 数字
>a.edit.minChar : 任意
>类型别名 :=> 任意
>a.edit : 任意
>类型别名 :=> 任意
>a : { edit: 任意; index: 数字; }
>edit : 任意
>类型别名 :=> 任意
>minChar : 任意
>类型别名 :=> 任意
>b.edit.minChar : 任意
>类型别名 :=> 任意
>b.edit : 任意
>类型别名 :=> 任意
>b : { edit: 任意; index: 数字; }
>edit : 任意
>类型别名 :=> 任意
>minChar : 任意
>类型别名 :=> 任意

                if (result == 0)
>result == 0 : 真假
>类型别名 :=> 真假
>result : 数字
>类型别名 :=> 数字
>0 : 0

                    result = a.index - b.index;
>result = a.index - b.index : 数字
>类型别名 :=> 数字
>result : 数字
>类型别名 :=> 数字
>a.index - b.index : 数字
>类型别名 :=> 数字
>a.index : 数字
>类型别名 :=> 数字
>a : { edit: 任意; index: 数字; }
>index : 数字
>类型别名 :=> 数字
>b.index : 数字
>类型别名 :=> 数字
>b : { edit: 任意; index: 数字; }
>index : 数字
>类型别名 :=> 数字

                return result;
>result : 数字
>类型别名 :=> 数字

            });

            var current = 0;
>current : 数字
>类型别名 :=> 数字
>0 : 0

            var next = 1;
>next : 数字
>类型别名 :=> 数字
>1 : 1

            while (current < temp.length) {
>current < temp.length : 真假
>类型别名 :=> 真假
>current : 数字
>类型别名 :=> 数字
>temp.length : 数字
>类型别名 :=> 数字
>temp : { edit: 任意; index: 数字; }[]
>length : 数字
>类型别名 :=> 数字

                var currentEdit = temp[current].edit;
>currentEdit : 任意
>类型别名 :=> 任意
>temp[current].edit : 任意
>类型别名 :=> 任意
>temp[current] : { edit: 任意; index: 数字; }
>temp : { edit: 任意; index: 数字; }[]
>current : 数字
>类型别名 :=> 数字
>edit : 任意
>类型别名 :=> 任意

                // Last edit
                if (next >= temp.length) {
>next >= temp.length : 真假
>类型别名 :=> 真假
>next : 数字
>类型别名 :=> 数字
>temp.length : 数字
>类型别名 :=> 数字
>temp : { edit: 任意; index: 数字; }[]
>length : 数字
>类型别名 :=> 数字

                    result.push(currentEdit);
>result.push(currentEdit) : 数字
>类型别名 :=> 数字
>result.push : (...items: 任意[]) => 数字
>result : 任意[]
>push : (...items: 任意[]) => 数字
>currentEdit : 任意
>类型别名 :=> 任意

                    current++;
>current++ : 数字
>类型别名 :=> 数字
>current : 数字
>类型别名 :=> 数字

                    continue;
                }
                var nextEdit = temp[next].edit;
>nextEdit : 任意
>类型别名 :=> 任意
>temp[next].edit : 任意
>类型别名 :=> 任意
>temp[next] : { edit: 任意; index: 数字; }
>temp : { edit: 任意; index: 数字; }[]
>next : 数字
>类型别名 :=> 数字
>edit : 任意
>类型别名 :=> 任意

                var gap = nextEdit.minChar - currentEdit.limChar;
>gap : 数字
>类型别名 :=> 数字
>nextEdit.minChar - currentEdit.limChar : 数字
>类型别名 :=> 数字
>nextEdit.minChar : 任意
>类型别名 :=> 任意
>nextEdit : 任意
>类型别名 :=> 任意
>minChar : 任意
>类型别名 :=> 任意
>currentEdit.limChar : 任意
>类型别名 :=> 任意
>currentEdit : 任意
>类型别名 :=> 任意
>limChar : 任意
>类型别名 :=> 任意

                // non-overlapping edits
                if (gap >= 0) {
>gap >= 0 : 真假
>类型别名 :=> 真假
>gap : 数字
>类型别名 :=> 数字
>0 : 0

                    result.push(currentEdit);
>result.push(currentEdit) : 数字
>类型别名 :=> 数字
>result.push : (...items: 任意[]) => 数字
>result : 任意[]
>push : (...items: 任意[]) => 数字
>currentEdit : 任意
>类型别名 :=> 任意

                    current = next;
>current = next : 数字
>类型别名 :=> 数字
>current : 数字
>类型别名 :=> 数字
>next : 数字
>类型别名 :=> 数字

                    next++;
>next++ : 数字
>类型别名 :=> 数字
>next : 数字
>类型别名 :=> 数字

                    continue;
                }

                // overlapping edits: for now, we only support ignoring an next edit 
                // entirely contained in the current edit.
                if (currentEdit.limChar >= nextEdit.limChar) {
>currentEdit.limChar >= nextEdit.limChar : 真假
>类型别名 :=> 真假
>currentEdit.limChar : 任意
>类型别名 :=> 任意
>currentEdit : 任意
>类型别名 :=> 任意
>limChar : 任意
>类型别名 :=> 任意
>nextEdit.limChar : 任意
>类型别名 :=> 任意
>nextEdit : 任意
>类型别名 :=> 任意
>limChar : 任意
>类型别名 :=> 任意

                    next++;
>next++ : 数字
>类型别名 :=> 数字
>next : 数字
>类型别名 :=> 数字

                    continue;
                }
                else {
                    throw new Error("Trying to apply overlapping edits");
>new Error("Trying to apply overlapping edits") : Error
>Error : ErrorConstructor
>"Trying to apply overlapping edits" : "Trying to apply overlapping edits"
                }
            }

            return result;
>result : 任意[]
        }

        public getHostSettings(): string {
>getHostSettings : () => 文字

            return JSON.stringify({ usePullLanguageService: usePull });
>JSON.stringify({ usePullLanguageService: usePull }) : 文字
>类型别名 :=> 文字
>JSON.stringify : { (value: 任意, replacer?: (key: 文字, value: 任意) => 任意, space?: 文字 | 数字): 文字; (value: 任意, replacer?: (文字 | 数字)[], space?: 文字 | 数字): 文字; }
>JSON : JSON
>stringify : { (value: 任意, replacer?: (key: 文字, value: 任意) => 任意, space?: 文字 | 数字): 文字; (value: 任意, replacer?: (文字 | 数字)[], space?: 文字 | 数字): 文字; }
>{ usePullLanguageService: usePull } : { usePullLanguageService: 真假; }
>usePullLanguageService : 真假
>类型别名 :=> 真假
>usePull : 真假
>类型别名 :=> 真假
        }
    }

    // Describe/it definitions
    export function describe(description: string, block: () => any) {
>describe : (description: 文字, block: () => 任意) => 无值
>description : 文字
>类型别名 :=> 文字
>block : () => 任意

        var newScenario = new Scenario(description, block);
>newScenario : Scenario
>new Scenario(description, block) : Scenario
>Scenario : 类为 Scenario
>description : 文字
>类型别名 :=> 文字
>block : () => 任意

        if (Runnable.currentStack.length === 0) {
>Runnable.currentStack.length === 0 : 真假
>类型别名 :=> 真假
>Runnable.currentStack.length : 数字
>类型别名 :=> 数字
>Runnable.currentStack : Runnable[]
>Runnable : 类为 Runnable
>currentStack : Runnable[]
>length : 数字
>类型别名 :=> 数字
>0 : 0

            Runnable.currentStack.push(currentRun);
>Runnable.currentStack.push(currentRun) : 数字
>类型别名 :=> 数字
>Runnable.currentStack.push : (...items: Runnable[]) => 数字
>Runnable.currentStack : Runnable[]
>Runnable : 类为 Runnable
>currentStack : Runnable[]
>push : (...items: Runnable[]) => 数字
>currentRun : Run
        }

        Runnable.currentStack[Runnable.currentStack.length - 1].addChild(newScenario);
>Runnable.currentStack[Runnable.currentStack.length - 1].addChild(newScenario) : 无值
>类型别名 :=> 无值
>Runnable.currentStack[Runnable.currentStack.length - 1].addChild : (child: Runnable) => 无值
>Runnable.currentStack[Runnable.currentStack.length - 1] : Runnable
>Runnable.currentStack : Runnable[]
>Runnable : 类为 Runnable
>currentStack : Runnable[]
>Runnable.currentStack.length - 1 : 数字
>类型别名 :=> 数字
>Runnable.currentStack.length : 数字
>类型别名 :=> 数字
>Runnable.currentStack : Runnable[]
>Runnable : 类为 Runnable
>currentStack : Runnable[]
>length : 数字
>类型别名 :=> 数字
>1 : 1
>addChild : (child: Runnable) => 无值
>newScenario : Scenario
    }
    export function it(description: string, block: () => void ) {
>it : (description: 文字, block: () => 无值) => 无值
>description : 文字
>类型别名 :=> 文字
>block : () => 无值

        var testCase = new TestCase(description, block);
>testCase : TestCase
>new TestCase(description, block) : TestCase
>TestCase : 类为 TestCase
>description : 文字
>类型别名 :=> 文字
>block : () => 无值

        Runnable.currentStack[Runnable.currentStack.length - 1].addChild(testCase);
>Runnable.currentStack[Runnable.currentStack.length - 1].addChild(testCase) : 无值
>类型别名 :=> 无值
>Runnable.currentStack[Runnable.currentStack.length - 1].addChild : (child: Runnable) => 无值
>Runnable.currentStack[Runnable.currentStack.length - 1] : Runnable
>Runnable.currentStack : Runnable[]
>Runnable : 类为 Runnable
>currentStack : Runnable[]
>Runnable.currentStack.length - 1 : 数字
>类型别名 :=> 数字
>Runnable.currentStack.length : 数字
>类型别名 :=> 数字
>Runnable.currentStack : Runnable[]
>Runnable : 类为 Runnable
>currentStack : Runnable[]
>length : 数字
>类型别名 :=> 数字
>1 : 1
>addChild : (child: Runnable) => 无值
>testCase : TestCase
    }

    export function run() {
>run : () => 无值

        if (typeof process !== "undefined") {
>typeof process !== "undefined" : 真假
>类型别名 :=> 真假
>typeof process : "string" | "number" | "boolean" | "symbol" | "undefined" | "object" | "function" | "文字" | "数字" | "真假" | "符号" | "未定" | "对象" | "函数"
>process : 类为 process
>"undefined" : "undefined"

            process.on('uncaughtException', Runnable.handleError);
>process.on('uncaughtException', Runnable.handleError) : 任意
>类型别名 :=> 任意
>process.on : (event: 文字, listener: Function) => 任意
>process : 类为 process
>on : (event: 文字, listener: Function) => 任意
>'uncaughtException' : "uncaughtException"
>Runnable.handleError : (e: Error) => 无值
>Runnable : 类为 Runnable
>handleError : (e: Error) => 无值
        }

        Baseline.reset();
>Baseline.reset() : 无值
>类型别名 :=> 无值
>Baseline.reset : () => 无值
>Baseline : 类为 Baseline
>reset : () => 无值

        currentRun.run();
>currentRun.run() : 无值
>类型别名 :=> 无值
>currentRun.run : () => 无值
>currentRun : Run
>run : () => 无值
    }

    /** Runs TypeScript or Javascript code. */
    export module Runner {
>Runner : 类为 Runner

        export function runCollateral(path: string, callback: (error: Error, result: any) => void ) {
>runCollateral : (path: 文字, callback: (error: Error, result: 任意) => 无值) => 无值
>path : 文字
>类型别名 :=> 文字
>callback : (error: Error, result: 任意) => 无值
>error : Error
>Error : Error
>result : 任意
>类型别名 :=> 任意

            path = switchToForwardSlashes(path);
>path = switchToForwardSlashes(path) : 文字
>类型别名 :=> 文字
>path : 文字
>类型别名 :=> 文字
>switchToForwardSlashes(path) : 文字
>类型别名 :=> 文字
>switchToForwardSlashes : (path: 文字) => 文字
>path : 文字
>类型别名 :=> 文字

            runString(readFile(path), path.match(/[^\/]*$/)[0], callback);
>runString(readFile(path), path.match(/[^\/]*$/)[0], callback) : 无值
>类型别名 :=> 无值
>runString : (code: 文字, unitName: 文字, callback: (error: Error, result: 任意) => 无值) => 无值
>readFile(path) : 任意
>类型别名 :=> 任意
>readFile : (path: 文字) => 任意
>path : 文字
>类型别名 :=> 文字
>path.match(/[^\/]*$/)[0] : 文字
>类型别名 :=> 文字
>path.match(/[^\/]*$/) : RegExpMatchArray
>path.match : (regexp: 文字 | RegExp) => RegExpMatchArray
>path : 文字
>类型别名 :=> 文字
>match : (regexp: 文字 | RegExp) => RegExpMatchArray
>/[^\/]*$/ : RegExp
>0 : 0
>callback : (error: Error, result: 任意) => 无值
        }

        export function runJSString(code: string, callback: (error: Error, result: any) => void ) {
>runJSString : (code: 文字, callback: (error: Error, result: 任意) => 无值) => 无值
>code : 文字
>类型别名 :=> 文字
>callback : (error: Error, result: 任意) => 无值
>error : Error
>Error : Error
>result : 任意
>类型别名 :=> 任意

            // List of names that get overriden by various test code we eval
            var dangerNames: any = ['Array'];
>dangerNames : 任意
>类型别名 :=> 任意
>['Array'] : 文字[]
>'Array' : "Array"

            var globalBackup: any = {};
>globalBackup : 任意
>类型别名 :=> 任意
>{} : {}

            var n: string = null;
>n : 文字
>类型别名 :=> 文字
>null : 空值
>类型别名 :=> 空值

            for (n in dangerNames) {
>n : 文字
>类型别名 :=> 文字
>dangerNames : 任意
>类型别名 :=> 任意

                globalBackup[dangerNames[n]] = global[dangerNames[n]];
>globalBackup[dangerNames[n]] = global[dangerNames[n]] : 任意
>类型别名 :=> 任意
>globalBackup[dangerNames[n]] : 任意
>类型别名 :=> 任意
>globalBackup : 任意
>类型别名 :=> 任意
>dangerNames[n] : 任意
>类型别名 :=> 任意
>dangerNames : 任意
>类型别名 :=> 任意
>n : 文字
>类型别名 :=> 文字
>global[dangerNames[n]] : 任意
>类型别名 :=> 任意
>global : 任意
>类型别名 :=> 任意
>dangerNames[n] : 任意
>类型别名 :=> 任意
>dangerNames : 任意
>类型别名 :=> 任意
>n : 文字
>类型别名 :=> 文字
            }

            try {
                var res = eval(code);
>res : 任意
>类型别名 :=> 任意
>eval(code) : 任意
>类型别名 :=> 任意
>eval : (x: 文字) => 任意
>code : 文字
>类型别名 :=> 文字

                for (n in dangerNames) {
>n : 文字
>类型别名 :=> 文字
>dangerNames : 任意
>类型别名 :=> 任意

                    global[dangerNames[n]] = globalBackup[dangerNames[n]];
>global[dangerNames[n]] = globalBackup[dangerNames[n]] : 任意
>类型别名 :=> 任意
>global[dangerNames[n]] : 任意
>类型别名 :=> 任意
>global : 任意
>类型别名 :=> 任意
>dangerNames[n] : 任意
>类型别名 :=> 任意
>dangerNames : 任意
>类型别名 :=> 任意
>n : 文字
>类型别名 :=> 文字
>globalBackup[dangerNames[n]] : 任意
>类型别名 :=> 任意
>globalBackup : 任意
>类型别名 :=> 任意
>dangerNames[n] : 任意
>类型别名 :=> 任意
>dangerNames : 任意
>类型别名 :=> 任意
>n : 文字
>类型别名 :=> 文字
                }

                callback(null, res);
>callback(null, res) : 无值
>类型别名 :=> 无值
>callback : (error: Error, result: 任意) => 无值
>null : 空值
>类型别名 :=> 空值
>res : 任意
>类型别名 :=> 任意

            } catch (e) {
>e : 任意
>类型别名 :=> 任意

                for (n in dangerNames) {
>n : 文字
>类型别名 :=> 文字
>dangerNames : 任意
>类型别名 :=> 任意

                    global[dangerNames[n]] = globalBackup[dangerNames[n]];
>global[dangerNames[n]] = globalBackup[dangerNames[n]] : 任意
>类型别名 :=> 任意
>global[dangerNames[n]] : 任意
>类型别名 :=> 任意
>global : 任意
>类型别名 :=> 任意
>dangerNames[n] : 任意
>类型别名 :=> 任意
>dangerNames : 任意
>类型别名 :=> 任意
>n : 文字
>类型别名 :=> 文字
>globalBackup[dangerNames[n]] : 任意
>类型别名 :=> 任意
>globalBackup : 任意
>类型别名 :=> 任意
>dangerNames[n] : 任意
>类型别名 :=> 任意
>dangerNames : 任意
>类型别名 :=> 任意
>n : 文字
>类型别名 :=> 文字
                }

                callback(e, null);
>callback(e, null) : 无值
>类型别名 :=> 无值
>callback : (error: Error, result: 任意) => 无值
>e : 任意
>类型别名 :=> 任意
>null : 空值
>类型别名 :=> 空值
            }
        }

        export function runString(code: string, unitName: string, callback: (error: Error, result: any) => void ) {
>runString : (code: 文字, unitName: 文字, callback: (error: Error, result: 任意) => 无值) => 无值
>code : 文字
>类型别名 :=> 文字
>unitName : 文字
>类型别名 :=> 文字
>callback : (error: Error, result: 任意) => 无值
>error : Error
>Error : Error
>result : 任意
>类型别名 :=> 任意

            Compiler.compileString(code, unitName, function (res) {
>Compiler.compileString(code, unitName, function (res) {                runJSString(res.code, callback);            }) : 无值
>类型别名 :=> 无值
>Compiler.compileString : (code: 文字, unitName: 文字, callback: (res: Compiler.CompilerResult) => 无值, context?: Compiler.CompilationContext, references?: 任意[]) => 无值
>Compiler : 类为 Compiler
>compileString : (code: 文字, unitName: 文字, callback: (res: Compiler.CompilerResult) => 无值, context?: Compiler.CompilationContext, references?: 任意[]) => 无值
>code : 文字
>类型别名 :=> 文字
>unitName : 文字
>类型别名 :=> 文字
>function (res) {                runJSString(res.code, callback);            } : (res: Compiler.CompilerResult) => 无值
>res : Compiler.CompilerResult

                runJSString(res.code, callback);
>runJSString(res.code, callback) : 无值
>类型别名 :=> 无值
>runJSString : (code: 文字, callback: (error: Error, result: 任意) => 无值) => 无值
>res.code : 文字
>类型别名 :=> 文字
>res : Compiler.CompilerResult
>code : 文字
>类型别名 :=> 文字
>callback : (error: Error, result: 任意) => 无值

            });
        }
    }

    /** Support class for baseline files */
    export module Baseline {
>Baseline : 类为 Baseline

        var reportFilename = 'baseline-report.html';
>reportFilename : 文字
>类型别名 :=> 文字
>'baseline-report.html' : "baseline-report.html"

        var firstRun = true;
>firstRun : 真假
>类型别名 :=> 真假
>true : 为真
>类型别名 :=> 为真

        var htmlTrailer = '</body></html>';
>htmlTrailer : 文字
>类型别名 :=> 文字
>'</body></html>' : "</body></html>"

        var htmlLeader = '<html><head><title>Baseline Report</title>';
>htmlLeader : 文字
>类型别名 :=> 文字
>'<html><head><title>Baseline Report</title>' : "<html><head><title>Baseline Report</title>"

        htmlLeader += ("<style>");
>htmlLeader += ("<style>") : 文字
>类型别名 :=> 文字
>htmlLeader : 文字
>类型别名 :=> 文字
>("<style>") : "<style>"
>"<style>" : "<style>"

        htmlLeader += '\r\n' + (".code { font: 9pt 'Courier New'; }");
>htmlLeader += '\r\n' + (".code { font: 9pt 'Courier New'; }") : 文字
>类型别名 :=> 文字
>htmlLeader : 文字
>类型别名 :=> 文字
>'\r\n' + (".code { font: 9pt 'Courier New'; }") : 文字
>类型别名 :=> 文字
>'\r\n' : "\r\n"
>(".code { font: 9pt 'Courier New'; }") : ".code { font: 9pt 'Courier New'; }"
>".code { font: 9pt 'Courier New'; }" : ".code { font: 9pt 'Courier New'; }"

        htmlLeader += '\r\n' + (".old { background-color: #EE1111; }");
>htmlLeader += '\r\n' + (".old { background-color: #EE1111; }") : 文字
>类型别名 :=> 文字
>htmlLeader : 文字
>类型别名 :=> 文字
>'\r\n' + (".old { background-color: #EE1111; }") : 文字
>类型别名 :=> 文字
>'\r\n' : "\r\n"
>(".old { background-color: #EE1111; }") : ".old { background-color: #EE1111; }"
>".old { background-color: #EE1111; }" : ".old { background-color: #EE1111; }"

        htmlLeader += '\r\n' + (".new { background-color: #FFFF11; }");
>htmlLeader += '\r\n' + (".new { background-color: #FFFF11; }") : 文字
>类型别名 :=> 文字
>htmlLeader : 文字
>类型别名 :=> 文字
>'\r\n' + (".new { background-color: #FFFF11; }") : 文字
>类型别名 :=> 文字
>'\r\n' : "\r\n"
>(".new { background-color: #FFFF11; }") : ".new { background-color: #FFFF11; }"
>".new { background-color: #FFFF11; }" : ".new { background-color: #FFFF11; }"

        htmlLeader += '\r\n' + (".from { background-color: #EE1111; color: #1111EE; }");
>htmlLeader += '\r\n' + (".from { background-color: #EE1111; color: #1111EE; }") : 文字
>类型别名 :=> 文字
>htmlLeader : 文字
>类型别名 :=> 文字
>'\r\n' + (".from { background-color: #EE1111; color: #1111EE; }") : 文字
>类型别名 :=> 文字
>'\r\n' : "\r\n"
>(".from { background-color: #EE1111; color: #1111EE; }") : ".from { background-color: #EE1111; color: #1111EE; }"
>".from { background-color: #EE1111; color: #1111EE; }" : ".from { background-color: #EE1111; color: #1111EE; }"

        htmlLeader += '\r\n' + (".to { background-color: #EEEE11; color: #1111EE; }");
>htmlLeader += '\r\n' + (".to { background-color: #EEEE11; color: #1111EE; }") : 文字
>类型别名 :=> 文字
>htmlLeader : 文字
>类型别名 :=> 文字
>'\r\n' + (".to { background-color: #EEEE11; color: #1111EE; }") : 文字
>类型别名 :=> 文字
>'\r\n' : "\r\n"
>(".to { background-color: #EEEE11; color: #1111EE; }") : ".to { background-color: #EEEE11; color: #1111EE; }"
>".to { background-color: #EEEE11; color: #1111EE; }" : ".to { background-color: #EEEE11; color: #1111EE; }"

        htmlLeader += '\r\n' + ("h2 { margin-bottom: 0px; }");
>htmlLeader += '\r\n' + ("h2 { margin-bottom: 0px; }") : 文字
>类型别名 :=> 文字
>htmlLeader : 文字
>类型别名 :=> 文字
>'\r\n' + ("h2 { margin-bottom: 0px; }") : 文字
>类型别名 :=> 文字
>'\r\n' : "\r\n"
>("h2 { margin-bottom: 0px; }") : "h2 { margin-bottom: 0px; }"
>"h2 { margin-bottom: 0px; }" : "h2 { margin-bottom: 0px; }"

        htmlLeader += '\r\n' + ("h2 { padding-bottom: 0px; }");
>htmlLeader += '\r\n' + ("h2 { padding-bottom: 0px; }") : 文字
>类型别名 :=> 文字
>htmlLeader : 文字
>类型别名 :=> 文字
>'\r\n' + ("h2 { padding-bottom: 0px; }") : 文字
>类型别名 :=> 文字
>'\r\n' : "\r\n"
>("h2 { padding-bottom: 0px; }") : "h2 { padding-bottom: 0px; }"
>"h2 { padding-bottom: 0px; }" : "h2 { padding-bottom: 0px; }"

        htmlLeader += '\r\n' + ("h4 { font-weight: normal; }");
>htmlLeader += '\r\n' + ("h4 { font-weight: normal; }") : 文字
>类型别名 :=> 文字
>htmlLeader : 文字
>类型别名 :=> 文字
>'\r\n' + ("h4 { font-weight: normal; }") : 文字
>类型别名 :=> 文字
>'\r\n' : "\r\n"
>("h4 { font-weight: normal; }") : "h4 { font-weight: normal; }"
>"h4 { font-weight: normal; }" : "h4 { font-weight: normal; }"

        htmlLeader += '\r\n' + ("</style>");
>htmlLeader += '\r\n' + ("</style>") : 文字
>类型别名 :=> 文字
>htmlLeader : 文字
>类型别名 :=> 文字
>'\r\n' + ("</style>") : 文字
>类型别名 :=> 文字
>'\r\n' : "\r\n"
>("</style>") : "</style>"
>"</style>" : "</style>"

        export interface BaselineOptions {
>BaselineOptions : BaselineOptions

            LineEndingSensitive?: boolean;
>LineEndingSensitive : 真假
>类型别名 :=> 真假
        }

        function localPath(filename: string) {
>localPath : (filename: 文字) => 文字
>filename : 文字
>类型别名 :=> 文字

            if (global.runners[0].testType === 'prototyping') {
>global.runners[0].testType === 'prototyping' : 真假
>类型别名 :=> 真假
>global.runners[0].testType : 任意
>类型别名 :=> 任意
>global.runners[0] : 任意
>类型别名 :=> 任意
>global.runners : 任意
>类型别名 :=> 任意
>global : 任意
>类型别名 :=> 任意
>runners : 任意
>类型别名 :=> 任意
>0 : 0
>testType : 任意
>类型别名 :=> 任意
>'prototyping' : "prototyping"

                return Harness.userSpecifiedroot + 'tests/baselines/prototyping/local/' + filename;
>Harness.userSpecifiedroot + 'tests/baselines/prototyping/local/' + filename : 文字
>类型别名 :=> 文字
>Harness.userSpecifiedroot + 'tests/baselines/prototyping/local/' : 文字
>类型别名 :=> 文字
>Harness.userSpecifiedroot : 文字
>类型别名 :=> 文字
>Harness : 类为 Harness
>userSpecifiedroot : 文字
>类型别名 :=> 文字
>'tests/baselines/prototyping/local/' : "tests/baselines/prototyping/local/"
>filename : 文字
>类型别名 :=> 文字
            }
            else {
                return Harness.userSpecifiedroot + 'tests/baselines/local/' + filename;
>Harness.userSpecifiedroot + 'tests/baselines/local/' + filename : 文字
>类型别名 :=> 文字
>Harness.userSpecifiedroot + 'tests/baselines/local/' : 文字
>类型别名 :=> 文字
>Harness.userSpecifiedroot : 文字
>类型别名 :=> 文字
>Harness : 类为 Harness
>userSpecifiedroot : 文字
>类型别名 :=> 文字
>'tests/baselines/local/' : "tests/baselines/local/"
>filename : 文字
>类型别名 :=> 文字
            }
        }

        function referencePath(filename: string) {
>referencePath : (filename: 文字) => 文字
>filename : 文字
>类型别名 :=> 文字

            if (global.runners[0].testType === 'prototyping') {
>global.runners[0].testType === 'prototyping' : 真假
>类型别名 :=> 真假
>global.runners[0].testType : 任意
>类型别名 :=> 任意
>global.runners[0] : 任意
>类型别名 :=> 任意
>global.runners : 任意
>类型别名 :=> 任意
>global : 任意
>类型别名 :=> 任意
>runners : 任意
>类型别名 :=> 任意
>0 : 0
>testType : 任意
>类型别名 :=> 任意
>'prototyping' : "prototyping"

                return Harness.userSpecifiedroot + 'tests/baselines/prototyping/reference/' + filename;
>Harness.userSpecifiedroot + 'tests/baselines/prototyping/reference/' + filename : 文字
>类型别名 :=> 文字
>Harness.userSpecifiedroot + 'tests/baselines/prototyping/reference/' : 文字
>类型别名 :=> 文字
>Harness.userSpecifiedroot : 文字
>类型别名 :=> 文字
>Harness : 类为 Harness
>userSpecifiedroot : 文字
>类型别名 :=> 文字
>'tests/baselines/prototyping/reference/' : "tests/baselines/prototyping/reference/"
>filename : 文字
>类型别名 :=> 文字
            }
            else {
                return Harness.userSpecifiedroot + 'tests/baselines/reference/' + filename;
>Harness.userSpecifiedroot + 'tests/baselines/reference/' + filename : 文字
>类型别名 :=> 文字
>Harness.userSpecifiedroot + 'tests/baselines/reference/' : 文字
>类型别名 :=> 文字
>Harness.userSpecifiedroot : 文字
>类型别名 :=> 文字
>Harness : 类为 Harness
>userSpecifiedroot : 文字
>类型别名 :=> 文字
>'tests/baselines/reference/' : "tests/baselines/reference/"
>filename : 文字
>类型别名 :=> 文字
            }
        }

        export function reset() {
>reset : () => 无值

            if (IO.fileExists(reportFilename)) {
>IO.fileExists(reportFilename) : 任意
>类型别名 :=> 任意
>IO.fileExists : 任意
>类型别名 :=> 任意
>IO : 任意
>类型别名 :=> 任意
>fileExists : 任意
>类型别名 :=> 任意
>reportFilename : 文字
>类型别名 :=> 文字

                IO.deleteFile(reportFilename);
>IO.deleteFile(reportFilename) : 任意
>类型别名 :=> 任意
>IO.deleteFile : 任意
>类型别名 :=> 任意
>IO : 任意
>类型别名 :=> 任意
>deleteFile : 任意
>类型别名 :=> 任意
>reportFilename : 文字
>类型别名 :=> 文字
            }
        }

        function prepareBaselineReport(): string {
>prepareBaselineReport : () => 文字

            var reportContent = htmlLeader;
>reportContent : 文字
>类型别名 :=> 文字
>htmlLeader : 文字
>类型别名 :=> 文字

            // Delete the baseline-report.html file if needed
            if (IO.fileExists(reportFilename)) {
>IO.fileExists(reportFilename) : 任意
>类型别名 :=> 任意
>IO.fileExists : 任意
>类型别名 :=> 任意
>IO : 任意
>类型别名 :=> 任意
>fileExists : 任意
>类型别名 :=> 任意
>reportFilename : 文字
>类型别名 :=> 文字

                reportContent = IO.readFile(reportFilename);
>reportContent = IO.readFile(reportFilename) : 任意
>类型别名 :=> 任意
>reportContent : 文字
>类型别名 :=> 文字
>IO.readFile(reportFilename) : 任意
>类型别名 :=> 任意
>IO.readFile : 任意
>类型别名 :=> 任意
>IO : 任意
>类型别名 :=> 任意
>readFile : 任意
>类型别名 :=> 任意
>reportFilename : 文字
>类型别名 :=> 文字

                reportContent = reportContent.replace(htmlTrailer, '');
>reportContent = reportContent.replace(htmlTrailer, '') : 文字
>类型别名 :=> 文字
>reportContent : 文字
>类型别名 :=> 文字
>reportContent.replace(htmlTrailer, '') : 文字
>类型别名 :=> 文字
>reportContent.replace : { (searchValue: 文字 | RegExp, replaceValue: 文字): 文字; (searchValue: 文字 | RegExp, replacer: (substring: 文字, ...args: 任意[]) => 文字): 文字; }
>reportContent : 文字
>类型别名 :=> 文字
>replace : { (searchValue: 文字 | RegExp, replaceValue: 文字): 文字; (searchValue: 文字 | RegExp, replacer: (substring: 文字, ...args: 任意[]) => 文字): 文字; }
>htmlTrailer : 文字
>类型别名 :=> 文字
>'' : ""

            } else {
                reportContent = htmlLeader;
>reportContent = htmlLeader : 文字
>类型别名 :=> 文字
>reportContent : 文字
>类型别名 :=> 文字
>htmlLeader : 文字
>类型别名 :=> 文字
            }
            return reportContent;
>reportContent : 文字
>类型别名 :=> 文字
        }

        function generateActual(actualFilename: string, generateContent: () => string): string {
>generateActual : (actualFilename: 文字, generateContent: () => 文字) => 文字
>actualFilename : 文字
>类型别名 :=> 文字
>generateContent : () => 文字

            // Create folders if needed
            IO.createDirectory(IO.dirName(IO.dirName(actualFilename)));
>IO.createDirectory(IO.dirName(IO.dirName(actualFilename))) : 任意
>类型别名 :=> 任意
>IO.createDirectory : 任意
>类型别名 :=> 任意
>IO : 任意
>类型别名 :=> 任意
>createDirectory : 任意
>类型别名 :=> 任意
>IO.dirName(IO.dirName(actualFilename)) : 任意
>类型别名 :=> 任意
>IO.dirName : 任意
>类型别名 :=> 任意
>IO : 任意
>类型别名 :=> 任意
>dirName : 任意
>类型别名 :=> 任意
>IO.dirName(actualFilename) : 任意
>类型别名 :=> 任意
>IO.dirName : 任意
>类型别名 :=> 任意
>IO : 任意
>类型别名 :=> 任意
>dirName : 任意
>类型别名 :=> 任意
>actualFilename : 文字
>类型别名 :=> 文字

            IO.createDirectory(IO.dirName(actualFilename));
>IO.createDirectory(IO.dirName(actualFilename)) : 任意
>类型别名 :=> 任意
>IO.createDirectory : 任意
>类型别名 :=> 任意
>IO : 任意
>类型别名 :=> 任意
>createDirectory : 任意
>类型别名 :=> 任意
>IO.dirName(actualFilename) : 任意
>类型别名 :=> 任意
>IO.dirName : 任意
>类型别名 :=> 任意
>IO : 任意
>类型别名 :=> 任意
>dirName : 任意
>类型别名 :=> 任意
>actualFilename : 文字
>类型别名 :=> 文字

            // Delete the actual file in case it fails
            if (IO.fileExists(actualFilename)) {
>IO.fileExists(actualFilename) : 任意
>类型别名 :=> 任意
>IO.fileExists : 任意
>类型别名 :=> 任意
>IO : 任意
>类型别名 :=> 任意
>fileExists : 任意
>类型别名 :=> 任意
>actualFilename : 文字
>类型别名 :=> 文字

                IO.deleteFile(actualFilename);
>IO.deleteFile(actualFilename) : 任意
>类型别名 :=> 任意
>IO.deleteFile : 任意
>类型别名 :=> 任意
>IO : 任意
>类型别名 :=> 任意
>deleteFile : 任意
>类型别名 :=> 任意
>actualFilename : 文字
>类型别名 :=> 文字
            }

            var actual = generateContent();
>actual : 文字
>类型别名 :=> 文字
>generateContent() : 文字
>类型别名 :=> 文字
>generateContent : () => 文字

            if (actual === undefined) {
>actual === undefined : 真假
>类型别名 :=> 真假
>actual : 文字
>类型别名 :=> 文字
>undefined : 未定
>类型别名 :=> 未定

                throw new Error('The generated content was "undefined". Return "null" if no baselining is required."');
>new Error('The generated content was "undefined". Return "null" if no baselining is required."') : Error
>Error : ErrorConstructor
>'The generated content was "undefined". Return "null" if no baselining is required."' : "The generated content was \"undefined\". Return \"null\" if no baselining is required.\""
            }

            // Store the content in the 'local' folder so we
            // can accept it later (manually)
            if (actual !== null) {
>actual !== null : 真假
>类型别名 :=> 真假
>actual : 文字
>类型别名 :=> 文字
>null : 空值
>类型别名 :=> 空值

                IO.writeFile(actualFilename, actual);
>IO.writeFile(actualFilename, actual) : 任意
>类型别名 :=> 任意
>IO.writeFile : 任意
>类型别名 :=> 任意
>IO : 任意
>类型别名 :=> 任意
>writeFile : 任意
>类型别名 :=> 任意
>actualFilename : 文字
>类型别名 :=> 文字
>actual : 文字
>类型别名 :=> 文字
            }

            return actual;
>actual : 文字
>类型别名 :=> 文字
        }

        function compareToBaseline(actual: string, relativeFilename: string, opts: BaselineOptions) {
>compareToBaseline : (actual: 文字, relativeFilename: 文字, opts: BaselineOptions) => { expected: 文字; actual: 文字; }
>actual : 文字
>类型别名 :=> 文字
>relativeFilename : 文字
>类型别名 :=> 文字
>opts : BaselineOptions
>BaselineOptions : BaselineOptions

            // actual is now either undefined (the generator had an error), null (no file requested),
            // or some real output of the function
            if (actual === undefined) {
>actual === undefined : 真假
>类型别名 :=> 真假
>actual : 文字
>类型别名 :=> 文字
>undefined : 未定
>类型别名 :=> 未定

                // Nothing to do
                return;
            }

            var refFilename = referencePath(relativeFilename);
>refFilename : 文字
>类型别名 :=> 文字
>referencePath(relativeFilename) : 文字
>类型别名 :=> 文字
>referencePath : (filename: 文字) => 文字
>relativeFilename : 文字
>类型别名 :=> 文字

            if (actual === null) {
>actual === null : 真假
>类型别名 :=> 真假
>actual : 文字
>类型别名 :=> 文字
>null : 空值
>类型别名 :=> 空值

                actual = '<no content>';
>actual = '<no content>' : "<no content>"
>actual : 文字
>类型别名 :=> 文字
>'<no content>' : "<no content>"
            }

            var expected = '<no content>';
>expected : 文字
>类型别名 :=> 文字
>'<no content>' : "<no content>"

            if (IO.fileExists(refFilename)) {
>IO.fileExists(refFilename) : 任意
>类型别名 :=> 任意
>IO.fileExists : 任意
>类型别名 :=> 任意
>IO : 任意
>类型别名 :=> 任意
>fileExists : 任意
>类型别名 :=> 任意
>refFilename : 文字
>类型别名 :=> 文字

                expected = IO.readFile(refFilename);
>expected = IO.readFile(refFilename) : 任意
>类型别名 :=> 任意
>expected : 文字
>类型别名 :=> 文字
>IO.readFile(refFilename) : 任意
>类型别名 :=> 任意
>IO.readFile : 任意
>类型别名 :=> 任意
>IO : 任意
>类型别名 :=> 任意
>readFile : 任意
>类型别名 :=> 任意
>refFilename : 文字
>类型别名 :=> 文字
            }

            var lineEndingSensitive = opts && opts.LineEndingSensitive;
>lineEndingSensitive : 真假
>类型别名 :=> 真假
>opts && opts.LineEndingSensitive : 真假
>类型别名 :=> 真假
>opts : BaselineOptions
>opts.LineEndingSensitive : 真假
>类型别名 :=> 真假
>opts : BaselineOptions
>LineEndingSensitive : 真假
>类型别名 :=> 真假

            if (!lineEndingSensitive) {
>!lineEndingSensitive : 真假
>类型别名 :=> 真假
>lineEndingSensitive : 真假
>类型别名 :=> 真假

                expected = expected.replace(/\r\n?/g, '\n')
>expected = expected.replace(/\r\n?/g, '\n') : 文字
>类型别名 :=> 文字
>expected : 文字
>类型别名 :=> 文字
>expected.replace(/\r\n?/g, '\n') : 文字
>类型别名 :=> 文字
>expected.replace : { (searchValue: 文字 | RegExp, replaceValue: 文字): 文字; (searchValue: 文字 | RegExp, replacer: (substring: 文字, ...args: 任意[]) => 文字): 文字; }
>expected : 文字
>类型别名 :=> 文字
>replace : { (searchValue: 文字 | RegExp, replaceValue: 文字): 文字; (searchValue: 文字 | RegExp, replacer: (substring: 文字, ...args: 任意[]) => 文字): 文字; }
>/\r\n?/g : RegExp
>'\n' : "\n"

                actual = actual.replace(/\r\n?/g, '\n')
>actual = actual.replace(/\r\n?/g, '\n') : 文字
>类型别名 :=> 文字
>actual : 文字
>类型别名 :=> 文字
>actual.replace(/\r\n?/g, '\n') : 文字
>类型别名 :=> 文字
>actual.replace : { (searchValue: 文字 | RegExp, replaceValue: 文字): 文字; (searchValue: 文字 | RegExp, replacer: (substring: 文字, ...args: 任意[]) => 文字): 文字; }
>actual : 文字
>类型别名 :=> 文字
>replace : { (searchValue: 文字 | RegExp, replaceValue: 文字): 文字; (searchValue: 文字 | RegExp, replacer: (substring: 文字, ...args: 任意[]) => 文字): 文字; }
>/\r\n?/g : RegExp
>'\n' : "\n"
            }

            return { expected: expected, actual: actual };
>{ expected: expected, actual: actual } : { expected: 文字; actual: 文字; }
>expected : 文字
>类型别名 :=> 文字
>expected : 文字
>类型别名 :=> 文字
>actual : 文字
>类型别名 :=> 文字
>actual : 文字
>类型别名 :=> 文字
        }

        function writeComparison(expected: string, actual: string, relativeFilename: string, actualFilename: string, descriptionForDescribe: string) {
>writeComparison : (expected: 文字, actual: 文字, relativeFilename: 文字, actualFilename: 文字, descriptionForDescribe: 文字) => 无值
>expected : 文字
>类型别名 :=> 文字
>actual : 文字
>类型别名 :=> 文字
>relativeFilename : 文字
>类型别名 :=> 文字
>actualFilename : 文字
>类型别名 :=> 文字
>descriptionForDescribe : 文字
>类型别名 :=> 文字

            if (expected != actual) {
>expected != actual : 真假
>类型别名 :=> 真假
>expected : 文字
>类型别名 :=> 文字
>actual : 文字
>类型别名 :=> 文字

                // Overwrite & issue error
                var errMsg = 'The baseline file ' + relativeFilename + ' has changed. Please refer to baseline-report.html and ';
>errMsg : 文字
>类型别名 :=> 文字
>'The baseline file ' + relativeFilename + ' has changed. Please refer to baseline-report.html and ' : 文字
>类型别名 :=> 文字
>'The baseline file ' + relativeFilename : 文字
>类型别名 :=> 文字
>'The baseline file ' : "The baseline file "
>relativeFilename : 文字
>类型别名 :=> 文字
>' has changed. Please refer to baseline-report.html and ' : " has changed. Please refer to baseline-report.html and "

                errMsg += 'either fix the regression (if unintended) or run nmake baseline-accept (if intended).'
>errMsg += 'either fix the regression (if unintended) or run nmake baseline-accept (if intended).' : 文字
>类型别名 :=> 文字
>errMsg : 文字
>类型别名 :=> 文字
>'either fix the regression (if unintended) or run nmake baseline-accept (if intended).' : "either fix the regression (if unintended) or run nmake baseline-accept (if intended)."

                var refFilename = referencePath(relativeFilename);
>refFilename : 文字
>类型别名 :=> 文字
>referencePath(relativeFilename) : 文字
>类型别名 :=> 文字
>referencePath : (filename: 文字) => 文字
>relativeFilename : 文字
>类型别名 :=> 文字

                // Append diff to the report
                var diff = new Diff.StringDiff(expected, actual);
>diff : 任意
>类型别名 :=> 任意
>new Diff.StringDiff(expected, actual) : 任意
>类型别名 :=> 任意
>Diff.StringDiff : 任意
>类型别名 :=> 任意
>Diff : 任意
>类型别名 :=> 任意
>StringDiff : 任意
>类型别名 :=> 任意
>expected : 文字
>类型别名 :=> 文字
>actual : 文字
>类型别名 :=> 文字

                var header = '<h2>' + descriptionForDescribe + '</h2>';
>header : 文字
>类型别名 :=> 文字
>'<h2>' + descriptionForDescribe + '</h2>' : 文字
>类型别名 :=> 文字
>'<h2>' + descriptionForDescribe : 文字
>类型别名 :=> 文字
>'<h2>' : "<h2>"
>descriptionForDescribe : 文字
>类型别名 :=> 文字
>'</h2>' : "</h2>"

                header += '<h4>Left file: ' + actualFilename + '; Right file: ' + refFilename + '</h4>';
>header += '<h4>Left file: ' + actualFilename + '; Right file: ' + refFilename + '</h4>' : 文字
>类型别名 :=> 文字
>header : 文字
>类型别名 :=> 文字
>'<h4>Left file: ' + actualFilename + '; Right file: ' + refFilename + '</h4>' : 文字
>类型别名 :=> 文字
>'<h4>Left file: ' + actualFilename + '; Right file: ' + refFilename : 文字
>类型别名 :=> 文字
>'<h4>Left file: ' + actualFilename + '; Right file: ' : 文字
>类型别名 :=> 文字
>'<h4>Left file: ' + actualFilename : 文字
>类型别名 :=> 文字
>'<h4>Left file: ' : "<h4>Left file: "
>actualFilename : 文字
>类型别名 :=> 文字
>'; Right file: ' : "; Right file: "
>refFilename : 文字
>类型别名 :=> 文字
>'</h4>' : "</h4>"

                var trailer = '<hr>';
>trailer : 文字
>类型别名 :=> 文字
>'<hr>' : "<hr>"

                var reportContentSoFar = prepareBaselineReport();
>reportContentSoFar : 文字
>类型别名 :=> 文字
>prepareBaselineReport() : 文字
>类型别名 :=> 文字
>prepareBaselineReport : () => 文字

                reportContentSoFar = reportContentSoFar + header + '<div class="code">' + diff.mergedHtml + '</div>' + trailer + htmlTrailer;
>reportContentSoFar = reportContentSoFar + header + '<div class="code">' + diff.mergedHtml + '</div>' + trailer + htmlTrailer : 文字
>类型别名 :=> 文字
>reportContentSoFar : 文字
>类型别名 :=> 文字
>reportContentSoFar + header + '<div class="code">' + diff.mergedHtml + '</div>' + trailer + htmlTrailer : 文字
>类型别名 :=> 文字
>reportContentSoFar + header + '<div class="code">' + diff.mergedHtml + '</div>' + trailer : 文字
>类型别名 :=> 文字
>reportContentSoFar + header + '<div class="code">' + diff.mergedHtml + '</div>' : 文字
>类型别名 :=> 文字
>reportContentSoFar + header + '<div class="code">' + diff.mergedHtml : 文字
>类型别名 :=> 文字
>reportContentSoFar + header + '<div class="code">' : 文字
>类型别名 :=> 文字
>reportContentSoFar + header : 文字
>类型别名 :=> 文字
>reportContentSoFar : 文字
>类型别名 :=> 文字
>header : 文字
>类型别名 :=> 文字
>'<div class="code">' : "<div class=\"code\">"
>diff.mergedHtml : 任意
>类型别名 :=> 任意
>diff : 任意
>类型别名 :=> 任意
>mergedHtml : 任意
>类型别名 :=> 任意
>'</div>' : "</div>"
>trailer : 文字
>类型别名 :=> 文字
>htmlTrailer : 文字
>类型别名 :=> 文字

                IO.writeFile(reportFilename, reportContentSoFar);
>IO.writeFile(reportFilename, reportContentSoFar) : 任意
>类型别名 :=> 任意
>IO.writeFile : 任意
>类型别名 :=> 任意
>IO : 任意
>类型别名 :=> 任意
>writeFile : 任意
>类型别名 :=> 任意
>reportFilename : 文字
>类型别名 :=> 文字
>reportContentSoFar : 文字
>类型别名 :=> 文字

                throw new Error(errMsg);
>new Error(errMsg) : Error
>Error : ErrorConstructor
>errMsg : 文字
>类型别名 :=> 文字
            }
        }

        export function runBaseline(
>runBaseline : (descriptionForDescribe: 文字, relativeFilename: 文字, generateContent: () => 文字, runImmediately?: 真假, opts?: BaselineOptions) => 无值

            descriptionForDescribe: string,
>descriptionForDescribe : 文字
>类型别名 :=> 文字

            relativeFilename: string,
>relativeFilename : 文字
>类型别名 :=> 文字

            generateContent: () => string,
>generateContent : () => 文字

            runImmediately? = false,
>runImmediately : 真假
>类型别名 :=> 真假
>false : 为假
>类型别名 :=> 为假

            opts?: BaselineOptions) {
>opts : BaselineOptions
>BaselineOptions : BaselineOptions

            var actual = <string>undefined;
>actual : 文字
>类型别名 :=> 文字
><string>undefined : 文字
>类型别名 :=> 文字
>undefined : 未定
>类型别名 :=> 未定

            var actualFilename = localPath(relativeFilename);
>actualFilename : 文字
>类型别名 :=> 文字
>localPath(relativeFilename) : 文字
>类型别名 :=> 文字
>localPath : (filename: 文字) => 文字
>relativeFilename : 文字
>类型别名 :=> 文字

            if (runImmediately) {
>runImmediately : 真假
>类型别名 :=> 真假

                var actual = generateActual(actualFilename, generateContent);
>actual : 文字
>类型别名 :=> 文字
>generateActual(actualFilename, generateContent) : 文字
>类型别名 :=> 文字
>generateActual : (actualFilename: 文字, generateContent: () => 文字) => 文字
>actualFilename : 文字
>类型别名 :=> 文字
>generateContent : () => 文字

                var comparison = compareToBaseline(actual, relativeFilename, opts);
>comparison : { expected: 文字; actual: 文字; }
>compareToBaseline(actual, relativeFilename, opts) : { expected: 文字; actual: 文字; }
>compareToBaseline : (actual: 文字, relativeFilename: 文字, opts: BaselineOptions) => { expected: 文字; actual: 文字; }
>actual : 文字
>类型别名 :=> 文字
>relativeFilename : 文字
>类型别名 :=> 文字
>opts : BaselineOptions

                writeComparison(comparison.expected, comparison.actual, relativeFilename, actualFilename, descriptionForDescribe);
>writeComparison(comparison.expected, comparison.actual, relativeFilename, actualFilename, descriptionForDescribe) : 无值
>类型别名 :=> 无值
>writeComparison : (expected: 文字, actual: 文字, relativeFilename: 文字, actualFilename: 文字, descriptionForDescribe: 文字) => 无值
>comparison.expected : 文字
>类型别名 :=> 文字
>comparison : { expected: 文字; actual: 文字; }
>expected : 文字
>类型别名 :=> 文字
>comparison.actual : 文字
>类型别名 :=> 文字
>comparison : { expected: 文字; actual: 文字; }
>actual : 文字
>类型别名 :=> 文字
>relativeFilename : 文字
>类型别名 :=> 文字
>actualFilename : 文字
>类型别名 :=> 文字
>descriptionForDescribe : 文字
>类型别名 :=> 文字

            } else {
                describe(descriptionForDescribe, () => {
>describe(descriptionForDescribe, () => {                    var actual: string;                    it('Can generate the content without error', () => {                        actual = generateActual(actualFilename, generateContent);                    });                    it('Matches the baseline file', () => {                        var comparison = compareToBaseline(actual, relativeFilename, opts);                        writeComparison(comparison.expected, comparison.actual, relativeFilename, actualFilename, descriptionForDescribe);                    });                }) : 无值
>类型别名 :=> 无值
>describe : (description: 文字, block: () => 任意) => 无值
>descriptionForDescribe : 文字
>类型别名 :=> 文字
>() => {                    var actual: string;                    it('Can generate the content without error', () => {                        actual = generateActual(actualFilename, generateContent);                    });                    it('Matches the baseline file', () => {                        var comparison = compareToBaseline(actual, relativeFilename, opts);                        writeComparison(comparison.expected, comparison.actual, relativeFilename, actualFilename, descriptionForDescribe);                    });                } : () => 无值

                    var actual: string;
>actual : 文字
>类型别名 :=> 文字

                    it('Can generate the content without error', () => {
>it('Can generate the content without error', () => {                        actual = generateActual(actualFilename, generateContent);                    }) : 无值
>类型别名 :=> 无值
>it : (description: 文字, block: () => 无值) => 无值
>'Can generate the content without error' : "Can generate the content without error"
>() => {                        actual = generateActual(actualFilename, generateContent);                    } : () => 无值

                        actual = generateActual(actualFilename, generateContent);
>actual = generateActual(actualFilename, generateContent) : 文字
>类型别名 :=> 文字
>actual : 文字
>类型别名 :=> 文字
>generateActual(actualFilename, generateContent) : 文字
>类型别名 :=> 文字
>generateActual : (actualFilename: 文字, generateContent: () => 文字) => 文字
>actualFilename : 文字
>类型别名 :=> 文字
>generateContent : () => 文字

                    });

                    it('Matches the baseline file', () => {
>it('Matches the baseline file', () => {                        var comparison = compareToBaseline(actual, relativeFilename, opts);                        writeComparison(comparison.expected, comparison.actual, relativeFilename, actualFilename, descriptionForDescribe);                    }) : 无值
>类型别名 :=> 无值
>it : (description: 文字, block: () => 无值) => 无值
>'Matches the baseline file' : "Matches the baseline file"
>() => {                        var comparison = compareToBaseline(actual, relativeFilename, opts);                        writeComparison(comparison.expected, comparison.actual, relativeFilename, actualFilename, descriptionForDescribe);                    } : () => 无值

                        var comparison = compareToBaseline(actual, relativeFilename, opts);
>comparison : { expected: 文字; actual: 文字; }
>compareToBaseline(actual, relativeFilename, opts) : { expected: 文字; actual: 文字; }
>compareToBaseline : (actual: 文字, relativeFilename: 文字, opts: BaselineOptions) => { expected: 文字; actual: 文字; }
>actual : 文字
>类型别名 :=> 文字
>relativeFilename : 文字
>类型别名 :=> 文字
>opts : BaselineOptions

                        writeComparison(comparison.expected, comparison.actual, relativeFilename, actualFilename, descriptionForDescribe);
>writeComparison(comparison.expected, comparison.actual, relativeFilename, actualFilename, descriptionForDescribe) : 无值
>类型别名 :=> 无值
>writeComparison : (expected: 文字, actual: 文字, relativeFilename: 文字, actualFilename: 文字, descriptionForDescribe: 文字) => 无值
>comparison.expected : 文字
>类型别名 :=> 文字
>comparison : { expected: 文字; actual: 文字; }
>expected : 文字
>类型别名 :=> 文字
>comparison.actual : 文字
>类型别名 :=> 文字
>comparison : { expected: 文字; actual: 文字; }
>actual : 文字
>类型别名 :=> 文字
>relativeFilename : 文字
>类型别名 :=> 文字
>actualFilename : 文字
>类型别名 :=> 文字
>descriptionForDescribe : 文字
>类型别名 :=> 文字

                    });
                });
            }
        }
    }

    var currentRun = new Run();
>currentRun : Run
>new Run() : Run
>Run : 类为 Run

    global.describe = describe;
>global.describe = describe : (description: 文字, block: () => 任意) => 无值
>global.describe : 任意
>类型别名 :=> 任意
>global : 任意
>类型别名 :=> 任意
>describe : 任意
>类型别名 :=> 任意
>describe : (description: 文字, block: () => 任意) => 无值

    global.run = run;
>global.run = run : () => 无值
>global.run : 任意
>类型别名 :=> 任意
>global : 任意
>类型别名 :=> 任意
>run : 任意
>类型别名 :=> 任意
>run : () => 无值

    global.it = it;
>global.it = it : (description: 文字, block: () => 无值) => 无值
>global.it : 任意
>类型别名 :=> 任意
>global : 任意
>类型别名 :=> 任意
>it : 任意
>类型别名 :=> 任意
>it : (description: 文字, block: () => 无值) => 无值

    global.assert = Harness.Assert;
>global.assert = Harness.Assert : 类为 Assert
>global.assert : 任意
>类型别名 :=> 任意
>global : 任意
>类型别名 :=> 任意
>assert : 任意
>类型别名 :=> 任意
>Harness.Assert : 类为 Assert
>Harness : 类为 Harness
>Assert : 类为 Assert
}

