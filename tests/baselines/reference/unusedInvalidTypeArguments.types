=== /typeReference.ts ===
// Tests that types are marked as used, even if used in places that don't accept type arguments.


type N = number;
>N : number
>类型别名 :=> 数字

type U = number;
>U : number
>类型别名 :=> 数字

export type Z = U<N>;
>Z : any
>类型别名 :=> 任意
>U : number
>类型别名 :=> 数字
>N : number
>类型别名 :=> 数字

=== /classReference.ts ===
type N = number;
>N : number
>类型别名 :=> 数字

class C { }
>C : C

// This uses getTypeFromClassOrInterfaceReference instead of getTypeFromTypeAliasReference.
export class D extends C<N> {}
>D : D
>C : typeof C
>N : number
>类型别名 :=> 数字

=== /interface.ts ===
import { Foo } from "unknown";
>Foo : any
>类型别名 :=> 任意

export interface I<T> { x: Foo<T>; }
>I : I<T>
>T : T
>x : any
>类型别名 :=> 任意
>Foo : any
>类型别名 :=> 任意
>T : T

=== /call.ts ===
import { foo } from "unknown";
>foo : any
>类型别名 :=> 任意

type T = number;
>T : number
>类型别名 :=> 数字

foo<T>();
>foo<T>() : any
>类型别名 :=> 任意
>foo : any
>类型别名 :=> 任意
>T : number
>类型别名 :=> 数字

=== /new.ts ===
import { Foo } from "unkown";
>Foo : any
>类型别名 :=> 任意

type T = number;
>T : number
>类型别名 :=> 数字

new Foo<T>();
>new Foo<T>() : any
>类型别名 :=> 任意
>Foo : any
>类型别名 :=> 任意
>T : number
>类型别名 :=> 数字

=== /callAny.ts ===
declare var g: any;
>g : any
>类型别名 :=> 任意

type U = number;
>U : number
>类型别名 :=> 数字

g<U>();
>g<U>() : any
>类型别名 :=> 任意
>g : any
>类型别名 :=> 任意
>U : number
>类型别名 :=> 数字

g<InvalidReference>(); // Should get error for type argument
>g<InvalidReference>() : any
>类型别名 :=> 任意
>g : any
>类型别名 :=> 任意
>InvalidReference : No type information available!

=== /super.ts ===
import { A, B } from "unknown";
>A : any
>类型别名 :=> 任意
>B : any
>类型别名 :=> 任意

type T = number;
>T : number
>类型别名 :=> 数字

export class C extends A<B> {
>C : C
>A : any
>类型别名 :=> 任意
>B : any
>类型别名 :=> 任意

    m() {
>m : () => void

        super.m<T>(1);
>super.m<T>(1) : any
>类型别名 :=> 任意
>super.m : any
>类型别名 :=> 任意
>super : any
>类型别名 :=> 任意
>m : any
>类型别名 :=> 任意
>T : number
>类型别名 :=> 数字
>1 : 1

        super.m<InvalidReference>(); // Should get error for type argument
>super.m<InvalidReference>() : any
>类型别名 :=> 任意
>super.m : any
>类型别名 :=> 任意
>super : any
>类型别名 :=> 任意
>m : any
>类型别名 :=> 任意
>InvalidReference : No type information available!
    }
}

