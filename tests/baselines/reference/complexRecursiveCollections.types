=== tests/cases/compiler/complex.ts ===
interface Ara<T> { t: T }
>Ara : Ara<T>
>T : T
>t : T
>T : T

interface Collection<K, V> {
>Collection : Collection<K, V>
>K : K
>V : V

    map<M>(mapper: (value: V, key: K, iter: this) => M): Collection<K, M>;
>map : <M>(mapper: (value: V, key: K, iter: 本体) => M) => Collection<K, M>
>M : M
>mapper : (value: V, key: K, iter: 本体) => M
>value : V
>V : V
>key : K
>K : K
>iter : 本体
>M : M
>Collection : Collection<K, V>
>K : K
>M : M

    flatMap<M>(mapper: (value: V, key: K, iter: this) => Ara<M>, context?: any): Collection<K, M>;
>flatMap : <M>(mapper: (value: V, key: K, iter: 本体) => Ara<M>, context?: 任意) => Collection<K, M>
>M : M
>mapper : (value: V, key: K, iter: 本体) => Ara<M>
>value : V
>V : V
>key : K
>K : K
>iter : 本体
>Ara : Ara<T>
>M : M
>context : 任意
>类型别名 :=> 任意
>Collection : Collection<K, V>
>K : K
>M : M

    // these seem necessary to push it over the top for memory usage
    reduce<R>(reducer: (reduction: R, value: V, key: K, iter: this) => R, initialReduction: R, context?: any): R;
>reduce : { <R>(reducer: (reduction: R, value: V, key: K, iter: 本体) => R, initialReduction: R, context?: 任意): R; <R>(reducer: (reduction: V | R, value: V, key: K, iter: 本体) => R): R; }
>R : R
>reducer : (reduction: R, value: V, key: K, iter: 本体) => R
>reduction : R
>R : R
>value : V
>V : V
>key : K
>K : K
>iter : 本体
>R : R
>initialReduction : R
>R : R
>context : 任意
>类型别名 :=> 任意
>R : R

    reduce<R>(reducer: (reduction: V | R, value: V, key: K, iter: this) => R): R;
>reduce : { <R>(reducer: (reduction: R, value: V, key: K, iter: 本体) => R, initialReduction: R, context?: 任意): R; <R>(reducer: (reduction: V | R, value: V, key: K, iter: 本体) => R): R; }
>R : R
>reducer : (reduction: V | R, value: V, key: K, iter: 本体) => R
>reduction : V | R
>V : V
>R : R
>value : V
>V : V
>key : K
>K : K
>iter : 本体
>R : R
>R : R

    toSeq(): Seq<K, V>;
>toSeq : () => Seq<K, V>
>Seq : Seq<K, V>
>K : K
>V : V
}
interface Seq<K, V> extends Collection<K, V> {
>Seq : Seq<K, V>
>K : K
>V : V
>Collection : Collection<K, V>
>K : K
>V : V
}
interface N1<T> extends Collection<void, T> {
>N1 : N1<T>
>T : T
>Collection : Collection<K, V>
>T : T

    map<M>(mapper: (value: T, key: void, iter: this) => M): N1<M>;
>map : <M>(mapper: (value: T, key: 无值, iter: 本体) => M) => N1<M>
>M : M
>mapper : (value: T, key: 无值, iter: 本体) => M
>value : T
>T : T
>key : 无值
>类型别名 :=> 无值
>iter : 本体
>M : M
>N1 : N1<T>
>M : M

    flatMap<M>(mapper: (value: T, key: void, iter: this) => Ara<M>, context?: any): N1<M>;
>flatMap : <M>(mapper: (value: T, key: 无值, iter: 本体) => Ara<M>, context?: 任意) => N1<M>
>M : M
>mapper : (value: T, key: 无值, iter: 本体) => Ara<M>
>value : T
>T : T
>key : 无值
>类型别名 :=> 无值
>iter : 本体
>Ara : Ara<T>
>M : M
>context : 任意
>类型别名 :=> 任意
>N1 : N1<T>
>M : M
}
interface N2<T> extends N1<T> {
>N2 : N2<T>
>T : T
>N1 : N1<T>
>T : T

    map<M>(mapper: (value: T, key: void, iter: this) => M): N2<M>;
>map : <M>(mapper: (value: T, key: 无值, iter: 本体) => M) => N2<M>
>M : M
>mapper : (value: T, key: 无值, iter: 本体) => M
>value : T
>T : T
>key : 无值
>类型别名 :=> 无值
>iter : 本体
>M : M
>N2 : N2<T>
>M : M

    flatMap<M>(mapper: (value: T, key: void, iter: this) => Ara<M>, context?: any): N2<M>;
>flatMap : <M>(mapper: (value: T, key: 无值, iter: 本体) => Ara<M>, context?: 任意) => N2<M>
>M : M
>mapper : (value: T, key: 无值, iter: 本体) => Ara<M>
>value : T
>T : T
>key : 无值
>类型别名 :=> 无值
>iter : 本体
>Ara : Ara<T>
>M : M
>context : 任意
>类型别名 :=> 任意
>N2 : N2<T>
>M : M

    toSeq(): N2<T>;
>toSeq : () => N2<T>
>N2 : N2<T>
>T : T
}
=== tests/cases/compiler/immutable.ts ===
// Test that complex recursive collections can pass the `extends` assignability check without
// running out of memory. This bug was exposed in Typescript 2.4 when more generic signatures
// started being checked.
declare module Immutable {
>Immutable : 类为 Immutable

  export function fromJS(jsValue: any, reviver?: (key: string | number, sequence: Collection.Keyed<string, any> | Collection.Indexed<any>, path?: Array<string | number>) => any): any;
>fromJS : (jsValue: 任意, reviver?: (key: 文字 | 数字, sequence: Collection.Keyed<文字, 任意> | Collection.Indexed<任意>, path?: (文字 | 数字)[]) => 任意) => 任意
>jsValue : 任意
>类型别名 :=> 任意
>reviver : (key: 文字 | 数字, sequence: Collection.Keyed<文字, 任意> | Collection.Indexed<任意>, path?: (文字 | 数字)[]) => 任意
>key : 文字 | 数字
>sequence : Collection.Keyed<文字, 任意> | Collection.Indexed<任意>
>Collection : 任意
>类型别名 :=> 任意
>Keyed : Collection.Keyed<K, V>
>Collection : 任意
>类型别名 :=> 任意
>Indexed : Collection.Indexed<T>
>path : (文字 | 数字)[]
>Array : T[]

  export function is(first: any, second: any): boolean;
>is : (first: 任意, second: 任意) => 真假
>first : 任意
>类型别名 :=> 任意
>second : 任意
>类型别名 :=> 任意

  export function hash(value: any): number;
>hash : (value: 任意) => 数字
>value : 任意
>类型别名 :=> 任意

  export function isImmutable(maybeImmutable: any): maybeImmutable is Collection<any, any>;
>isImmutable : (maybeImmutable: 任意) => maybeImmutable 作为 Collection<任意, 任意>
>maybeImmutable : 任意
>类型别名 :=> 任意
>maybeImmutable : 任意
>类型别名 :=> 任意
>Collection : Collection<K, V>

  export function isCollection(maybeCollection: any): maybeCollection is Collection<any, any>;
>isCollection : (maybeCollection: 任意) => maybeCollection 作为 Collection<任意, 任意>
>maybeCollection : 任意
>类型别名 :=> 任意
>maybeCollection : 任意
>类型别名 :=> 任意
>Collection : Collection<K, V>

  export function isKeyed(maybeKeyed: any): maybeKeyed is Collection.Keyed<any, any>;
>isKeyed : (maybeKeyed: 任意) => maybeKeyed 作为 Collection.Keyed<任意, 任意>
>maybeKeyed : 任意
>类型别名 :=> 任意
>maybeKeyed : 任意
>类型别名 :=> 任意
>Collection : 任意
>类型别名 :=> 任意
>Keyed : Collection.Keyed<K, V>

  export function isIndexed(maybeIndexed: any): maybeIndexed is Collection.Indexed<any>;
>isIndexed : (maybeIndexed: 任意) => maybeIndexed 作为 Collection.Indexed<任意>
>maybeIndexed : 任意
>类型别名 :=> 任意
>maybeIndexed : 任意
>类型别名 :=> 任意
>Collection : 任意
>类型别名 :=> 任意
>Indexed : Collection.Indexed<T>

  export function isAssociative(maybeAssociative: any): maybeAssociative is Collection.Keyed<any, any> | Collection.Indexed<any>;
>isAssociative : (maybeAssociative: 任意) => maybeAssociative 作为 Collection.Indexed<任意> | Collection.Keyed<任意, 任意>
>maybeAssociative : 任意
>类型别名 :=> 任意
>maybeAssociative : 任意
>类型别名 :=> 任意
>Collection : 任意
>类型别名 :=> 任意
>Keyed : Collection.Keyed<K, V>
>Collection : 任意
>类型别名 :=> 任意
>Indexed : Collection.Indexed<T>

  export function isOrdered(maybeOrdered: any): boolean;
>isOrdered : (maybeOrdered: 任意) => 真假
>maybeOrdered : 任意
>类型别名 :=> 任意

  export function isValueObject(maybeValue: any): maybeValue is ValueObject;
>isValueObject : (maybeValue: 任意) => maybeValue 作为 ValueObject
>maybeValue : 任意
>类型别名 :=> 任意
>maybeValue : 任意
>类型别名 :=> 任意
>ValueObject : ValueObject

  export interface ValueObject {
>ValueObject : ValueObject

    equals(other: any): boolean;
>equals : (other: 任意) => 真假
>other : 任意
>类型别名 :=> 任意

    hashCode(): number;
>hashCode : () => 数字
  }
  export module List {
>List : 类为 List

    function isList(maybeList: any): maybeList is List<any>;
>isList : (maybeList: 任意) => maybeList 作为 List<任意>
>maybeList : 任意
>类型别名 :=> 任意
>maybeList : 任意
>类型别名 :=> 任意
>List : List<T>

    function of<T>(...values: Array<T>): List<T>;
>of : <T>(...values: T[]) => List<T>
>T : T
>values : T[]
>Array : T[]
>T : T
>List : List<T>
>T : T
  }
  export function List(): List<any>;
>List : 类为 List
>List : List<T>

  export function List<T>(): List<T>;
>List : 类为 List
>T : T
>List : List<T>
>T : T

  export function List<T>(collection: Iterable<T>): List<T>;
>List : 类为 List
>T : T
>collection : Iterable<T>
>Iterable : Iterable<T>
>T : T
>List : List<T>
>T : T

  export interface List<T> extends Collection.Indexed<T> {
>List : List<T>
>T : T
>Collection.Indexed : 任意
>类型别名 :=> 任意
>Collection : 类为 Collection
>Indexed : Collection.Indexed<T>
>T : T

    // Persistent changes
    set(index: number, value: T): List<T>;
>set : (index: 数字, value: T) => List<T>
>index : 数字
>类型别名 :=> 数字
>value : T
>T : T
>List : List<T>
>T : T

    delete(index: number): List<T>;
>delete : (index: 数字) => List<T>
>index : 数字
>类型别名 :=> 数字
>List : List<T>
>T : T

    remove(index: number): List<T>;
>remove : (index: 数字) => List<T>
>index : 数字
>类型别名 :=> 数字
>List : List<T>
>T : T

    insert(index: number, value: T): List<T>;
>insert : (index: 数字, value: T) => List<T>
>index : 数字
>类型别名 :=> 数字
>value : T
>T : T
>List : List<T>
>T : T

    clear(): List<T>;
>clear : () => List<T>
>List : List<T>
>T : T

    push(...values: Array<T>): List<T>;
>push : (...values: T[]) => List<T>
>values : T[]
>Array : T[]
>T : T
>List : List<T>
>T : T

    pop(): List<T>;
>pop : () => List<T>
>List : List<T>
>T : T

    unshift(...values: Array<T>): List<T>;
>unshift : (...values: T[]) => List<T>
>values : T[]
>Array : T[]
>T : T
>List : List<T>
>T : T

    shift(): List<T>;
>shift : () => List<T>
>List : List<T>
>T : T

    update(index: number, notSetValue: T, updater: (value: T) => T): this;
>update : { (index: 数字, notSetValue: T, updater: (value: T) => T): 本体; (index: 数字, updater: (value: T) => T): 本体; <R>(updater: (value: 本体) => R): R; }
>index : 数字
>类型别名 :=> 数字
>notSetValue : T
>T : T
>updater : (value: T) => T
>value : T
>T : T
>T : T

    update(index: number, updater: (value: T) => T): this;
>update : { (index: 数字, notSetValue: T, updater: (value: T) => T): 本体; (index: 数字, updater: (value: T) => T): 本体; <R>(updater: (value: 本体) => R): R; }
>index : 数字
>类型别名 :=> 数字
>updater : (value: T) => T
>value : T
>T : T
>T : T

    update<R>(updater: (value: this) => R): R;
>update : { (index: 数字, notSetValue: T, updater: (value: T) => T): 本体; (index: 数字, updater: (value: T) => T): 本体; <R>(updater: (value: 本体) => R): R; }
>R : R
>updater : (value: 本体) => R
>value : 本体
>R : R
>R : R

    merge(...collections: Array<Collection.Indexed<T> | Array<T>>): this;
>merge : (...collections: (Collection.Indexed<T> | T[])[]) => 本体
>collections : (Collection.Indexed<T> | T[])[]
>Array : T[]
>Collection : 任意
>类型别名 :=> 任意
>Indexed : Collection.Indexed<T>
>T : T
>Array : T[]
>T : T

    mergeWith(merger: (oldVal: T, newVal: T, key: number) => T, ...collections: Array<Collection.Indexed<T> | Array<T>>): this;
>mergeWith : (merger: (oldVal: T, newVal: T, key: 数字) => T, ...collections: (Collection.Indexed<T> | T[])[]) => 本体
>merger : (oldVal: T, newVal: T, key: 数字) => T
>oldVal : T
>T : T
>newVal : T
>T : T
>key : 数字
>类型别名 :=> 数字
>T : T
>collections : (Collection.Indexed<T> | T[])[]
>Array : T[]
>Collection : 任意
>类型别名 :=> 任意
>Indexed : Collection.Indexed<T>
>T : T
>Array : T[]
>T : T

    mergeDeep(...collections: Array<Collection.Indexed<T> | Array<T>>): this;
>mergeDeep : (...collections: (Collection.Indexed<T> | T[])[]) => 本体
>collections : (Collection.Indexed<T> | T[])[]
>Array : T[]
>Collection : 任意
>类型别名 :=> 任意
>Indexed : Collection.Indexed<T>
>T : T
>Array : T[]
>T : T

    mergeDeepWith(merger: (oldVal: T, newVal: T, key: number) => T, ...collections: Array<Collection.Indexed<T> | Array<T>>): this;
>mergeDeepWith : (merger: (oldVal: T, newVal: T, key: 数字) => T, ...collections: (Collection.Indexed<T> | T[])[]) => 本体
>merger : (oldVal: T, newVal: T, key: 数字) => T
>oldVal : T
>T : T
>newVal : T
>T : T
>key : 数字
>类型别名 :=> 数字
>T : T
>collections : (Collection.Indexed<T> | T[])[]
>Array : T[]
>Collection : 任意
>类型别名 :=> 任意
>Indexed : Collection.Indexed<T>
>T : T
>Array : T[]
>T : T

    setSize(size: number): List<T>;
>setSize : (size: 数字) => List<T>
>size : 数字
>类型别名 :=> 数字
>List : List<T>
>T : T

    // Deep persistent changes
    setIn(keyPath: Iterable<any>, value: any): this;
>setIn : (keyPath: Iterable<任意>, value: 任意) => 本体
>keyPath : Iterable<任意>
>Iterable : Iterable<T>
>value : 任意
>类型别名 :=> 任意

    deleteIn(keyPath: Iterable<any>): this;
>deleteIn : (keyPath: Iterable<任意>) => 本体
>keyPath : Iterable<任意>
>Iterable : Iterable<T>

    removeIn(keyPath: Iterable<any>): this;
>removeIn : (keyPath: Iterable<任意>) => 本体
>keyPath : Iterable<任意>
>Iterable : Iterable<T>

    updateIn(keyPath: Iterable<any>, notSetValue: any, updater: (value: any) => any): this;
>updateIn : { (keyPath: Iterable<任意>, notSetValue: 任意, updater: (value: 任意) => 任意): 本体; (keyPath: Iterable<任意>, updater: (value: 任意) => 任意): 本体; }
>keyPath : Iterable<任意>
>Iterable : Iterable<T>
>notSetValue : 任意
>类型别名 :=> 任意
>updater : (value: 任意) => 任意
>value : 任意
>类型别名 :=> 任意

    updateIn(keyPath: Iterable<any>, updater: (value: any) => any): this;
>updateIn : { (keyPath: Iterable<任意>, notSetValue: 任意, updater: (value: 任意) => 任意): 本体; (keyPath: Iterable<任意>, updater: (value: 任意) => 任意): 本体; }
>keyPath : Iterable<任意>
>Iterable : Iterable<T>
>updater : (value: 任意) => 任意
>value : 任意
>类型别名 :=> 任意

    mergeIn(keyPath: Iterable<any>, ...collections: Array<any>): this;
>mergeIn : (keyPath: Iterable<任意>, ...collections: 任意[]) => 本体
>keyPath : Iterable<任意>
>Iterable : Iterable<T>
>collections : 任意[]
>Array : T[]

    mergeDeepIn(keyPath: Iterable<any>, ...collections: Array<any>): this;
>mergeDeepIn : (keyPath: Iterable<任意>, ...collections: 任意[]) => 本体
>keyPath : Iterable<任意>
>Iterable : Iterable<T>
>collections : 任意[]
>Array : T[]

    // Transient changes
    withMutations(mutator: (mutable: this) => any): this;
>withMutations : (mutator: (mutable: 本体) => 任意) => 本体
>mutator : (mutable: 本体) => 任意
>mutable : 本体

    asMutable(): this;
>asMutable : () => 本体

    asImmutable(): this;
>asImmutable : () => 本体

    // Sequence algorithms
    concat<C>(...valuesOrCollections: Array<Iterable<C> | C>): List<T | C>;
>concat : <C>(...valuesOrCollections: (C | Iterable<C>)[]) => List<T | C>
>C : C
>valuesOrCollections : (C | Iterable<C>)[]
>Array : T[]
>Iterable : Iterable<T>
>C : C
>C : C
>List : List<T>
>T : T
>C : C

    map<M>(mapper: (value: T, key: number, iter: this) => M, context?: any): List<M>;
>map : <M>(mapper: (value: T, key: 数字, iter: 本体) => M, context?: 任意) => List<M>
>M : M
>mapper : (value: T, key: 数字, iter: 本体) => M
>value : T
>T : T
>key : 数字
>类型别名 :=> 数字
>iter : 本体
>M : M
>context : 任意
>类型别名 :=> 任意
>List : List<T>
>M : M

    flatMap<M>(mapper: (value: T, key: number, iter: this) => Iterable<M>, context?: any): List<M>;
>flatMap : <M>(mapper: (value: T, key: 数字, iter: 本体) => Iterable<M>, context?: 任意) => List<M>
>M : M
>mapper : (value: T, key: 数字, iter: 本体) => Iterable<M>
>value : T
>T : T
>key : 数字
>类型别名 :=> 数字
>iter : 本体
>Iterable : Iterable<T>
>M : M
>context : 任意
>类型别名 :=> 任意
>List : List<T>
>M : M

    filter<F extends T>(predicate: (value: T, index: number, iter: this) => value is F, context?: any): List<F>;
>filter : { <F 扩展 T>(predicate: (value: T, index: 数字, iter: 本体) => value 作为 F, context?: 任意): List<F>; (predicate: (value: T, index: 数字, iter: 本体) => 任意, context?: 任意): 本体; }
>F : F
>T : T
>predicate : (value: T, index: 数字, iter: 本体) => value 作为 F
>value : T
>T : T
>index : 数字
>类型别名 :=> 数字
>iter : 本体
>value : 任意
>类型别名 :=> 任意
>F : F
>context : 任意
>类型别名 :=> 任意
>List : List<T>
>F : F

    filter(predicate: (value: T, index: number, iter: this) => any, context?: any): this;
>filter : { <F 扩展 T>(predicate: (value: T, index: 数字, iter: 本体) => value 作为 F, context?: 任意): List<F>; (predicate: (value: T, index: 数字, iter: 本体) => 任意, context?: 任意): 本体; }
>predicate : (value: T, index: 数字, iter: 本体) => 任意
>value : T
>T : T
>index : 数字
>类型别名 :=> 数字
>iter : 本体
>context : 任意
>类型别名 :=> 任意
  }
  export module Map {
>Map : 类为 Map

    function isMap(maybeMap: any): maybeMap is Map<any, any>;
>isMap : (maybeMap: 任意) => maybeMap 作为 Map<任意, 任意>
>maybeMap : 任意
>类型别名 :=> 任意
>maybeMap : 任意
>类型别名 :=> 任意
>Map : Map<K, V>

    function of(...keyValues: Array<any>): Map<any, any>;
>of : (...keyValues: 任意[]) => Map<任意, 任意>
>keyValues : 任意[]
>Array : T[]
>Map : Map<K, V>
  }
  export function Map<K, V>(collection: Iterable<[K, V]>): Map<K, V>;
>Map : 类为 Map
>K : K
>V : V
>collection : Iterable<[K, V]>
>Iterable : Iterable<T>
>K : K
>V : V
>Map : Map<K, V>
>K : K
>V : V

  export function Map<T>(collection: Iterable<Iterable<T>>): Map<T, T>;
>Map : 类为 Map
>T : T
>collection : Iterable<Iterable<T>>
>Iterable : Iterable<T>
>Iterable : Iterable<T>
>T : T
>Map : Map<K, V>
>T : T
>T : T

  export function Map<V>(obj: {[key: string]: V}): Map<string, V>;
>Map : 类为 Map
>V : V
>obj : { [key: 文字]: V; }
>key : 文字
>类型别名 :=> 文字
>V : V
>Map : Map<K, V>
>V : V

  export function Map<K, V>(): Map<K, V>;
>Map : 类为 Map
>K : K
>V : V
>Map : Map<K, V>
>K : K
>V : V

  export function Map(): Map<any, any>;
>Map : 类为 Map
>Map : Map<K, V>

  export interface Map<K, V> extends Collection.Keyed<K, V> {
>Map : Map<K, V>
>K : K
>V : V
>Collection.Keyed : 任意
>类型别名 :=> 任意
>Collection : 类为 Collection
>Keyed : Collection.Keyed<K, V>
>K : K
>V : V

    // Persistent changes
    set(key: K, value: V): this;
>set : (key: K, value: V) => 本体
>key : K
>K : K
>value : V
>V : V

    delete(key: K): this;
>delete : (key: K) => 本体
>key : K
>K : K

    remove(key: K): this;
>remove : (key: K) => 本体
>key : K
>K : K

    deleteAll(keys: Iterable<K>): this;
>deleteAll : (keys: Iterable<K>) => 本体
>keys : Iterable<K>
>Iterable : Iterable<T>
>K : K

    removeAll(keys: Iterable<K>): this;
>removeAll : (keys: Iterable<K>) => 本体
>keys : Iterable<K>
>Iterable : Iterable<T>
>K : K

    clear(): this;
>clear : () => 本体

    update(key: K, notSetValue: V, updater: (value: V) => V): this;
>update : { (key: K, notSetValue: V, updater: (value: V) => V): 本体; (key: K, updater: (value: V) => V): 本体; <R>(updater: (value: 本体) => R): R; }
>key : K
>K : K
>notSetValue : V
>V : V
>updater : (value: V) => V
>value : V
>V : V
>V : V

    update(key: K, updater: (value: V) => V): this;
>update : { (key: K, notSetValue: V, updater: (value: V) => V): 本体; (key: K, updater: (value: V) => V): 本体; <R>(updater: (value: 本体) => R): R; }
>key : K
>K : K
>updater : (value: V) => V
>value : V
>V : V
>V : V

    update<R>(updater: (value: this) => R): R;
>update : { (key: K, notSetValue: V, updater: (value: V) => V): 本体; (key: K, updater: (value: V) => V): 本体; <R>(updater: (value: 本体) => R): R; }
>R : R
>updater : (value: 本体) => R
>value : 本体
>R : R
>R : R

    merge(...collections: Array<Collection<K, V> | {[key: string]: V}>): this;
>merge : (...collections: (Collection<K, V> | { [key: 文字]: V; })[]) => 本体
>collections : (Collection<K, V> | { [key: 文字]: V; })[]
>Array : T[]
>Collection : Collection<K, V>
>K : K
>V : V
>key : 文字
>类型别名 :=> 文字
>V : V

    mergeWith(merger: (oldVal: V, newVal: V, key: K) => V, ...collections: Array<Collection<K, V> | {[key: string]: V}>): this;
>mergeWith : (merger: (oldVal: V, newVal: V, key: K) => V, ...collections: (Collection<K, V> | { [key: 文字]: V; })[]) => 本体
>merger : (oldVal: V, newVal: V, key: K) => V
>oldVal : V
>V : V
>newVal : V
>V : V
>key : K
>K : K
>V : V
>collections : (Collection<K, V> | { [key: 文字]: V; })[]
>Array : T[]
>Collection : Collection<K, V>
>K : K
>V : V
>key : 文字
>类型别名 :=> 文字
>V : V

    mergeDeep(...collections: Array<Collection<K, V> | {[key: string]: V}>): this;
>mergeDeep : (...collections: (Collection<K, V> | { [key: 文字]: V; })[]) => 本体
>collections : (Collection<K, V> | { [key: 文字]: V; })[]
>Array : T[]
>Collection : Collection<K, V>
>K : K
>V : V
>key : 文字
>类型别名 :=> 文字
>V : V

    mergeDeepWith(merger: (oldVal: V, newVal: V, key: K) => V, ...collections: Array<Collection<K, V> | {[key: string]: V}>): this;
>mergeDeepWith : (merger: (oldVal: V, newVal: V, key: K) => V, ...collections: (Collection<K, V> | { [key: 文字]: V; })[]) => 本体
>merger : (oldVal: V, newVal: V, key: K) => V
>oldVal : V
>V : V
>newVal : V
>V : V
>key : K
>K : K
>V : V
>collections : (Collection<K, V> | { [key: 文字]: V; })[]
>Array : T[]
>Collection : Collection<K, V>
>K : K
>V : V
>key : 文字
>类型别名 :=> 文字
>V : V

    // Deep persistent changes
    setIn(keyPath: Iterable<any>, value: any): this;
>setIn : (keyPath: Iterable<任意>, value: 任意) => 本体
>keyPath : Iterable<任意>
>Iterable : Iterable<T>
>value : 任意
>类型别名 :=> 任意

    deleteIn(keyPath: Iterable<any>): this;
>deleteIn : (keyPath: Iterable<任意>) => 本体
>keyPath : Iterable<任意>
>Iterable : Iterable<T>

    removeIn(keyPath: Iterable<any>): this;
>removeIn : (keyPath: Iterable<任意>) => 本体
>keyPath : Iterable<任意>
>Iterable : Iterable<T>

    updateIn(keyPath: Iterable<any>, notSetValue: any, updater: (value: any) => any): this;
>updateIn : { (keyPath: Iterable<任意>, notSetValue: 任意, updater: (value: 任意) => 任意): 本体; (keyPath: Iterable<任意>, updater: (value: 任意) => 任意): 本体; }
>keyPath : Iterable<任意>
>Iterable : Iterable<T>
>notSetValue : 任意
>类型别名 :=> 任意
>updater : (value: 任意) => 任意
>value : 任意
>类型别名 :=> 任意

    updateIn(keyPath: Iterable<any>, updater: (value: any) => any): this;
>updateIn : { (keyPath: Iterable<任意>, notSetValue: 任意, updater: (value: 任意) => 任意): 本体; (keyPath: Iterable<任意>, updater: (value: 任意) => 任意): 本体; }
>keyPath : Iterable<任意>
>Iterable : Iterable<T>
>updater : (value: 任意) => 任意
>value : 任意
>类型别名 :=> 任意

    mergeIn(keyPath: Iterable<any>, ...collections: Array<any>): this;
>mergeIn : (keyPath: Iterable<任意>, ...collections: 任意[]) => 本体
>keyPath : Iterable<任意>
>Iterable : Iterable<T>
>collections : 任意[]
>Array : T[]

    mergeDeepIn(keyPath: Iterable<any>, ...collections: Array<any>): this;
>mergeDeepIn : (keyPath: Iterable<任意>, ...collections: 任意[]) => 本体
>keyPath : Iterable<任意>
>Iterable : Iterable<T>
>collections : 任意[]
>Array : T[]

    // Transient changes
    withMutations(mutator: (mutable: this) => any): this;
>withMutations : (mutator: (mutable: 本体) => 任意) => 本体
>mutator : (mutable: 本体) => 任意
>mutable : 本体

    asMutable(): this;
>asMutable : () => 本体

    asImmutable(): this;
>asImmutable : () => 本体

    // Sequence algorithms
    concat<KC, VC>(...collections: Array<Iterable<[KC, VC]>>): Map<K | KC, V | VC>;
>concat : { <KC, VC>(...collections: Iterable<[KC, VC]>[]): Map<K | KC, V | VC>; <C>(...collections: { [key: 文字]: C; }[]): Map<文字 | K, V | C>; }
>KC : KC
>VC : VC
>collections : Iterable<[KC, VC]>[]
>Array : T[]
>Iterable : Iterable<T>
>KC : KC
>VC : VC
>Map : Map<K, V>
>K : K
>KC : KC
>V : V
>VC : VC

    concat<C>(...collections: Array<{[key: string]: C}>): Map<K | string, V | C>;
>concat : { <KC, VC>(...collections: Iterable<[KC, VC]>[]): Map<K | KC, V | VC>; <C>(...collections: { [key: 文字]: C; }[]): Map<文字 | K, V | C>; }
>C : C
>collections : { [key: 文字]: C; }[]
>Array : T[]
>key : 文字
>类型别名 :=> 文字
>C : C
>Map : Map<K, V>
>K : K
>V : V
>C : C

    map<M>(mapper: (value: V, key: K, iter: this) => M, context?: any): Map<K, M>;
>map : <M>(mapper: (value: V, key: K, iter: 本体) => M, context?: 任意) => Map<K, M>
>M : M
>mapper : (value: V, key: K, iter: 本体) => M
>value : V
>V : V
>key : K
>K : K
>iter : 本体
>M : M
>context : 任意
>类型别名 :=> 任意
>Map : Map<K, V>
>K : K
>M : M

    mapKeys<M>(mapper: (key: K, value: V, iter: this) => M, context?: any): Map<M, V>;
>mapKeys : <M>(mapper: (key: K, value: V, iter: 本体) => M, context?: 任意) => Map<M, V>
>M : M
>mapper : (key: K, value: V, iter: 本体) => M
>key : K
>K : K
>value : V
>V : V
>iter : 本体
>M : M
>context : 任意
>类型别名 :=> 任意
>Map : Map<K, V>
>M : M
>V : V

    mapEntries<KM, VM>(mapper: (entry: [K, V], index: number, iter: this) => [KM, VM], context?: any): Map<KM, VM>;
>mapEntries : <KM, VM>(mapper: (entry: [K, V], index: 数字, iter: 本体) => [KM, VM], context?: 任意) => Map<KM, VM>
>KM : KM
>VM : VM
>mapper : (entry: [K, V], index: 数字, iter: 本体) => [KM, VM]
>entry : [K, V]
>K : K
>V : V
>index : 数字
>类型别名 :=> 数字
>iter : 本体
>KM : KM
>VM : VM
>context : 任意
>类型别名 :=> 任意
>Map : Map<K, V>
>KM : KM
>VM : VM

    flatMap<M>(mapper: (value: V, key: K, iter: this) => Iterable<M>, context?: any): Map<any, any>;
>flatMap : <M>(mapper: (value: V, key: K, iter: 本体) => Iterable<M>, context?: 任意) => Map<任意, 任意>
>M : M
>mapper : (value: V, key: K, iter: 本体) => Iterable<M>
>value : V
>V : V
>key : K
>K : K
>iter : 本体
>Iterable : Iterable<T>
>M : M
>context : 任意
>类型别名 :=> 任意
>Map : Map<K, V>

    filter<F extends V>(predicate: (value: V, key: K, iter: this) => value is F, context?: any): Map<K, F>;
>filter : { <F 扩展 V>(predicate: (value: V, key: K, iter: 本体) => value 作为 F, context?: 任意): Map<K, F>; (predicate: (value: V, key: K, iter: 本体) => 任意, context?: 任意): 本体; }
>F : F
>V : V
>predicate : (value: V, key: K, iter: 本体) => value 作为 F
>value : V
>V : V
>key : K
>K : K
>iter : 本体
>value : 任意
>类型别名 :=> 任意
>F : F
>context : 任意
>类型别名 :=> 任意
>Map : Map<K, V>
>K : K
>F : F

    filter(predicate: (value: V, key: K, iter: this) => any, context?: any): this;
>filter : { <F 扩展 V>(predicate: (value: V, key: K, iter: 本体) => value 作为 F, context?: 任意): Map<K, F>; (predicate: (value: V, key: K, iter: 本体) => 任意, context?: 任意): 本体; }
>predicate : (value: V, key: K, iter: 本体) => 任意
>value : V
>V : V
>key : K
>K : K
>iter : 本体
>context : 任意
>类型别名 :=> 任意
  }
  export module OrderedMap {
>OrderedMap : 类为 OrderedMap

    function isOrderedMap(maybeOrderedMap: any): maybeOrderedMap is OrderedMap<any, any>;
>isOrderedMap : (maybeOrderedMap: 任意) => maybeOrderedMap 作为 OrderedMap<任意, 任意>
>maybeOrderedMap : 任意
>类型别名 :=> 任意
>maybeOrderedMap : 任意
>类型别名 :=> 任意
>OrderedMap : OrderedMap<K, V>
  }
  export function OrderedMap<K, V>(collection: Iterable<[K, V]>): OrderedMap<K, V>;
>OrderedMap : 类为 OrderedMap
>K : K
>V : V
>collection : Iterable<[K, V]>
>Iterable : Iterable<T>
>K : K
>V : V
>OrderedMap : OrderedMap<K, V>
>K : K
>V : V

  export function OrderedMap<T>(collection: Iterable<Iterable<T>>): OrderedMap<T, T>;
>OrderedMap : 类为 OrderedMap
>T : T
>collection : Iterable<Iterable<T>>
>Iterable : Iterable<T>
>Iterable : Iterable<T>
>T : T
>OrderedMap : OrderedMap<K, V>
>T : T
>T : T

  export function OrderedMap<V>(obj: {[key: string]: V}): OrderedMap<string, V>;
>OrderedMap : 类为 OrderedMap
>V : V
>obj : { [key: 文字]: V; }
>key : 文字
>类型别名 :=> 文字
>V : V
>OrderedMap : OrderedMap<K, V>
>V : V

  export function OrderedMap<K, V>(): OrderedMap<K, V>;
>OrderedMap : 类为 OrderedMap
>K : K
>V : V
>OrderedMap : OrderedMap<K, V>
>K : K
>V : V

  export function OrderedMap(): OrderedMap<any, any>;
>OrderedMap : 类为 OrderedMap
>OrderedMap : OrderedMap<K, V>

  export interface OrderedMap<K, V> extends Map<K, V> {
>OrderedMap : OrderedMap<K, V>
>K : K
>V : V
>Map : Map<K, V>
>K : K
>V : V

    // Sequence algorithms
    concat<KC, VC>(...collections: Array<Iterable<[KC, VC]>>): OrderedMap<K | KC, V | VC>;
>concat : { <KC, VC>(...collections: Iterable<[KC, VC]>[]): OrderedMap<K | KC, V | VC>; <C>(...collections: { [key: 文字]: C; }[]): OrderedMap<文字 | K, V | C>; }
>KC : KC
>VC : VC
>collections : Iterable<[KC, VC]>[]
>Array : T[]
>Iterable : Iterable<T>
>KC : KC
>VC : VC
>OrderedMap : OrderedMap<K, V>
>K : K
>KC : KC
>V : V
>VC : VC

    concat<C>(...collections: Array<{[key: string]: C}>): OrderedMap<K | string, V | C>;
>concat : { <KC, VC>(...collections: Iterable<[KC, VC]>[]): OrderedMap<K | KC, V | VC>; <C>(...collections: { [key: 文字]: C; }[]): OrderedMap<文字 | K, V | C>; }
>C : C
>collections : { [key: 文字]: C; }[]
>Array : T[]
>key : 文字
>类型别名 :=> 文字
>C : C
>OrderedMap : OrderedMap<K, V>
>K : K
>V : V
>C : C

    map<M>(mapper: (value: V, key: K, iter: this) => M, context?: any): OrderedMap<K, M>;
>map : <M>(mapper: (value: V, key: K, iter: 本体) => M, context?: 任意) => OrderedMap<K, M>
>M : M
>mapper : (value: V, key: K, iter: 本体) => M
>value : V
>V : V
>key : K
>K : K
>iter : 本体
>M : M
>context : 任意
>类型别名 :=> 任意
>OrderedMap : OrderedMap<K, V>
>K : K
>M : M

    mapKeys<M>(mapper: (key: K, value: V, iter: this) => M, context?: any): OrderedMap<M, V>;
>mapKeys : <M>(mapper: (key: K, value: V, iter: 本体) => M, context?: 任意) => OrderedMap<M, V>
>M : M
>mapper : (key: K, value: V, iter: 本体) => M
>key : K
>K : K
>value : V
>V : V
>iter : 本体
>M : M
>context : 任意
>类型别名 :=> 任意
>OrderedMap : OrderedMap<K, V>
>M : M
>V : V

    mapEntries<KM, VM>(mapper: (entry: [K, V], index: number, iter: this) => [KM, VM], context?: any): OrderedMap<KM, VM>;
>mapEntries : <KM, VM>(mapper: (entry: [K, V], index: 数字, iter: 本体) => [KM, VM], context?: 任意) => OrderedMap<KM, VM>
>KM : KM
>VM : VM
>mapper : (entry: [K, V], index: 数字, iter: 本体) => [KM, VM]
>entry : [K, V]
>K : K
>V : V
>index : 数字
>类型别名 :=> 数字
>iter : 本体
>KM : KM
>VM : VM
>context : 任意
>类型别名 :=> 任意
>OrderedMap : OrderedMap<K, V>
>KM : KM
>VM : VM

    flatMap<M>(mapper: (value: V, key: K, iter: this) => Iterable<M>, context?: any): OrderedMap<any, any>;
>flatMap : <M>(mapper: (value: V, key: K, iter: 本体) => Iterable<M>, context?: 任意) => OrderedMap<任意, 任意>
>M : M
>mapper : (value: V, key: K, iter: 本体) => Iterable<M>
>value : V
>V : V
>key : K
>K : K
>iter : 本体
>Iterable : Iterable<T>
>M : M
>context : 任意
>类型别名 :=> 任意
>OrderedMap : OrderedMap<K, V>

    filter<F extends V>(predicate: (value: V, key: K, iter: this) => value is F, context?: any): OrderedMap<K, F>;
>filter : { <F 扩展 V>(predicate: (value: V, key: K, iter: 本体) => value 作为 F, context?: 任意): OrderedMap<K, F>; (predicate: (value: V, key: K, iter: 本体) => 任意, context?: 任意): 本体; }
>F : F
>V : V
>predicate : (value: V, key: K, iter: 本体) => value 作为 F
>value : V
>V : V
>key : K
>K : K
>iter : 本体
>value : 任意
>类型别名 :=> 任意
>F : F
>context : 任意
>类型别名 :=> 任意
>OrderedMap : OrderedMap<K, V>
>K : K
>F : F

    filter(predicate: (value: V, key: K, iter: this) => any, context?: any): this;
>filter : { <F 扩展 V>(predicate: (value: V, key: K, iter: 本体) => value 作为 F, context?: 任意): OrderedMap<K, F>; (predicate: (value: V, key: K, iter: 本体) => 任意, context?: 任意): 本体; }
>predicate : (value: V, key: K, iter: 本体) => 任意
>value : V
>V : V
>key : K
>K : K
>iter : 本体
>context : 任意
>类型别名 :=> 任意
  }
  export module Set {
>Set : 类为 Set

    function isSet(maybeSet: any): maybeSet is Set<any>;
>isSet : (maybeSet: 任意) => maybeSet 作为 Set<任意>
>maybeSet : 任意
>类型别名 :=> 任意
>maybeSet : 任意
>类型别名 :=> 任意
>Set : Set<T>

    function of<T>(...values: Array<T>): Set<T>;
>of : <T>(...values: T[]) => Set<T>
>T : T
>values : T[]
>Array : T[]
>T : T
>Set : Set<T>
>T : T

    function fromKeys<T>(iter: Collection<T, any>): Set<T>;
>fromKeys : { <T>(iter: Collection<T, 任意>): Set<T>; (obj: { [key: 文字]: 任意; }): Set<文字>; }
>T : T
>iter : Collection<T, 任意>
>Collection : Collection<K, V>
>T : T
>Set : Set<T>
>T : T

    function fromKeys(obj: {[key: string]: any}): Set<string>;
>fromKeys : { <T>(iter: Collection<T, 任意>): Set<T>; (obj: { [key: 文字]: 任意; }): Set<文字>; }
>obj : { [key: 文字]: 任意; }
>key : 文字
>类型别名 :=> 文字
>Set : Set<T>

    function intersect<T>(sets: Iterable<Iterable<T>>): Set<T>;
>intersect : <T>(sets: Iterable<Iterable<T>>) => Set<T>
>T : T
>sets : Iterable<Iterable<T>>
>Iterable : Iterable<T>
>Iterable : Iterable<T>
>T : T
>Set : Set<T>
>T : T

    function union<T>(sets: Iterable<Iterable<T>>): Set<T>;
>union : <T>(sets: Iterable<Iterable<T>>) => Set<T>
>T : T
>sets : Iterable<Iterable<T>>
>Iterable : Iterable<T>
>Iterable : Iterable<T>
>T : T
>Set : Set<T>
>T : T
  }
  export function Set(): Set<any>;
>Set : 类为 Set
>Set : Set<T>

  export function Set<T>(): Set<T>;
>Set : 类为 Set
>T : T
>Set : Set<T>
>T : T

  export function Set<T>(collection: Iterable<T>): Set<T>;
>Set : 类为 Set
>T : T
>collection : Iterable<T>
>Iterable : Iterable<T>
>T : T
>Set : Set<T>
>T : T

  export interface Set<T> extends Collection.Set<T> {
>Set : Set<T>
>T : T
>Collection.Set : 任意
>类型别名 :=> 任意
>Collection : 类为 Collection
>Set : Collection.Set<T>
>T : T

    // Persistent changes
    add(value: T): this;
>add : (value: T) => 本体
>value : T
>T : T

    delete(value: T): this;
>delete : (value: T) => 本体
>value : T
>T : T

    remove(value: T): this;
>remove : (value: T) => 本体
>value : T
>T : T

    clear(): this;
>clear : () => 本体

    union(...collections: Array<Collection<any, T> | Array<T>>): this;
>union : (...collections: (Collection<任意, T> | T[])[]) => 本体
>collections : (Collection<任意, T> | T[])[]
>Array : T[]
>Collection : Collection<K, V>
>T : T
>Array : T[]
>T : T

    merge(...collections: Array<Collection<any, T> | Array<T>>): this;
>merge : (...collections: (Collection<任意, T> | T[])[]) => 本体
>collections : (Collection<任意, T> | T[])[]
>Array : T[]
>Collection : Collection<K, V>
>T : T
>Array : T[]
>T : T

    intersect(...collections: Array<Collection<any, T> | Array<T>>): this;
>intersect : (...collections: (Collection<任意, T> | T[])[]) => 本体
>collections : (Collection<任意, T> | T[])[]
>Array : T[]
>Collection : Collection<K, V>
>T : T
>Array : T[]
>T : T

    subtract(...collections: Array<Collection<any, T> | Array<T>>): this;
>subtract : (...collections: (Collection<任意, T> | T[])[]) => 本体
>collections : (Collection<任意, T> | T[])[]
>Array : T[]
>Collection : Collection<K, V>
>T : T
>Array : T[]
>T : T

    // Transient changes
    withMutations(mutator: (mutable: this) => any): this;
>withMutations : (mutator: (mutable: 本体) => 任意) => 本体
>mutator : (mutable: 本体) => 任意
>mutable : 本体

    asMutable(): this;
>asMutable : () => 本体

    asImmutable(): this;
>asImmutable : () => 本体

    // Sequence algorithms
    concat<C>(...valuesOrCollections: Array<Iterable<C> | C>): Set<T | C>;
>concat : <C>(...valuesOrCollections: (C | Iterable<C>)[]) => Set<T | C>
>C : C
>valuesOrCollections : (C | Iterable<C>)[]
>Array : T[]
>Iterable : Iterable<T>
>C : C
>C : C
>Set : Set<T>
>T : T
>C : C

    map<M>(mapper: (value: T, key: never, iter: this) => M, context?: any): Set<M>;
>map : <M>(mapper: (value: T, key: 不及, iter: 本体) => M, context?: 任意) => Set<M>
>M : M
>mapper : (value: T, key: 不及, iter: 本体) => M
>value : T
>T : T
>key : 不及
>类型别名 :=> 不及
>iter : 本体
>M : M
>context : 任意
>类型别名 :=> 任意
>Set : Set<T>
>M : M

    flatMap<M>(mapper: (value: T, key: never, iter: this) => Iterable<M>, context?: any): Set<M>;
>flatMap : <M>(mapper: (value: T, key: 不及, iter: 本体) => Iterable<M>, context?: 任意) => Set<M>
>M : M
>mapper : (value: T, key: 不及, iter: 本体) => Iterable<M>
>value : T
>T : T
>key : 不及
>类型别名 :=> 不及
>iter : 本体
>Iterable : Iterable<T>
>M : M
>context : 任意
>类型别名 :=> 任意
>Set : Set<T>
>M : M

    filter<F extends T>(predicate: (value: T, key: never, iter: this) => value is F, context?: any): Set<F>;
>filter : { <F 扩展 T>(predicate: (value: T, key: 不及, iter: 本体) => value 作为 F, context?: 任意): Set<F>; (predicate: (value: T, key: 不及, iter: 本体) => 任意, context?: 任意): 本体; }
>F : F
>T : T
>predicate : (value: T, key: 不及, iter: 本体) => value 作为 F
>value : T
>T : T
>key : 不及
>类型别名 :=> 不及
>iter : 本体
>value : 任意
>类型别名 :=> 任意
>F : F
>context : 任意
>类型别名 :=> 任意
>Set : Set<T>
>F : F

    filter(predicate: (value: T, key: never, iter: this) => any, context?: any): this;
>filter : { <F 扩展 T>(predicate: (value: T, key: 不及, iter: 本体) => value 作为 F, context?: 任意): Set<F>; (predicate: (value: T, key: 不及, iter: 本体) => 任意, context?: 任意): 本体; }
>predicate : (value: T, key: 不及, iter: 本体) => 任意
>value : T
>T : T
>key : 不及
>类型别名 :=> 不及
>iter : 本体
>context : 任意
>类型别名 :=> 任意
  }
  export module OrderedSet {
>OrderedSet : 类为 OrderedSet

    function isOrderedSet(maybeOrderedSet: any): boolean;
>isOrderedSet : (maybeOrderedSet: 任意) => 真假
>maybeOrderedSet : 任意
>类型别名 :=> 任意

    function of<T>(...values: Array<T>): OrderedSet<T>;
>of : <T>(...values: T[]) => OrderedSet<T>
>T : T
>values : T[]
>Array : T[]
>T : T
>OrderedSet : OrderedSet<T>
>T : T

    function fromKeys<T>(iter: Collection<T, any>): OrderedSet<T>;
>fromKeys : { <T>(iter: Collection<T, 任意>): OrderedSet<T>; (obj: { [key: 文字]: 任意; }): OrderedSet<文字>; }
>T : T
>iter : Collection<T, 任意>
>Collection : Collection<K, V>
>T : T
>OrderedSet : OrderedSet<T>
>T : T

    function fromKeys(obj: {[key: string]: any}): OrderedSet<string>;
>fromKeys : { <T>(iter: Collection<T, 任意>): OrderedSet<T>; (obj: { [key: 文字]: 任意; }): OrderedSet<文字>; }
>obj : { [key: 文字]: 任意; }
>key : 文字
>类型别名 :=> 文字
>OrderedSet : OrderedSet<T>
  }
  export function OrderedSet(): OrderedSet<any>;
>OrderedSet : 类为 OrderedSet
>OrderedSet : OrderedSet<T>

  export function OrderedSet<T>(): OrderedSet<T>;
>OrderedSet : 类为 OrderedSet
>T : T
>OrderedSet : OrderedSet<T>
>T : T

  export function OrderedSet<T>(collection: Iterable<T>): OrderedSet<T>;
>OrderedSet : 类为 OrderedSet
>T : T
>collection : Iterable<T>
>Iterable : Iterable<T>
>T : T
>OrderedSet : OrderedSet<T>
>T : T

  export interface OrderedSet<T> extends Set<T> {
>OrderedSet : OrderedSet<T>
>T : T
>Set : Set<T>
>T : T

    // Sequence algorithms
    concat<C>(...valuesOrCollections: Array<Iterable<C> | C>): OrderedSet<T | C>;
>concat : <C>(...valuesOrCollections: (C | Iterable<C>)[]) => OrderedSet<T | C>
>C : C
>valuesOrCollections : (C | Iterable<C>)[]
>Array : T[]
>Iterable : Iterable<T>
>C : C
>C : C
>OrderedSet : OrderedSet<T>
>T : T
>C : C

    map<M>(mapper: (value: T, key: never, iter: this) => M, context?: any): OrderedSet<M>;
>map : <M>(mapper: (value: T, key: 不及, iter: 本体) => M, context?: 任意) => OrderedSet<M>
>M : M
>mapper : (value: T, key: 不及, iter: 本体) => M
>value : T
>T : T
>key : 不及
>类型别名 :=> 不及
>iter : 本体
>M : M
>context : 任意
>类型别名 :=> 任意
>OrderedSet : OrderedSet<T>
>M : M

    flatMap<M>(mapper: (value: T, key: never, iter: this) => Iterable<M>, context?: any): OrderedSet<M>;
>flatMap : <M>(mapper: (value: T, key: 不及, iter: 本体) => Iterable<M>, context?: 任意) => OrderedSet<M>
>M : M
>mapper : (value: T, key: 不及, iter: 本体) => Iterable<M>
>value : T
>T : T
>key : 不及
>类型别名 :=> 不及
>iter : 本体
>Iterable : Iterable<T>
>M : M
>context : 任意
>类型别名 :=> 任意
>OrderedSet : OrderedSet<T>
>M : M

    filter<F extends T>(predicate: (value: T, key: never, iter: this) => value is F, context?: any): OrderedSet<F>;
>filter : { <F 扩展 T>(predicate: (value: T, key: 不及, iter: 本体) => value 作为 F, context?: 任意): OrderedSet<F>; (predicate: (value: T, key: 不及, iter: 本体) => 任意, context?: 任意): 本体; }
>F : F
>T : T
>predicate : (value: T, key: 不及, iter: 本体) => value 作为 F
>value : T
>T : T
>key : 不及
>类型别名 :=> 不及
>iter : 本体
>value : 任意
>类型别名 :=> 任意
>F : F
>context : 任意
>类型别名 :=> 任意
>OrderedSet : OrderedSet<T>
>F : F

    filter(predicate: (value: T, key: never, iter: this) => any, context?: any): this;
>filter : { <F 扩展 T>(predicate: (value: T, key: 不及, iter: 本体) => value 作为 F, context?: 任意): OrderedSet<F>; (predicate: (value: T, key: 不及, iter: 本体) => 任意, context?: 任意): 本体; }
>predicate : (value: T, key: 不及, iter: 本体) => 任意
>value : T
>T : T
>key : 不及
>类型别名 :=> 不及
>iter : 本体
>context : 任意
>类型别名 :=> 任意

    zip(...collections: Array<Collection<any, any>>): OrderedSet<any>;
>zip : (...collections: Collection<任意, 任意>[]) => OrderedSet<任意>
>collections : Collection<任意, 任意>[]
>Array : T[]
>Collection : Collection<K, V>
>OrderedSet : OrderedSet<T>

    zipWith<U, Z>(zipper: (value: T, otherValue: U) => Z, otherCollection: Collection<any, U>): OrderedSet<Z>;
>zipWith : { <U, Z>(zipper: (value: T, otherValue: U) => Z, otherCollection: Collection<任意, U>): OrderedSet<Z>; <U, V, Z>(zipper: (value: T, otherValue: U, thirdValue: V) => Z, otherCollection: Collection<任意, U>, thirdCollection: Collection<任意, V>): OrderedSet<Z>; <Z>(zipper: (...any: 任意[]) => Z, ...collections: Collection<任意, 任意>[]): OrderedSet<Z>; }
>U : U
>Z : Z
>zipper : (value: T, otherValue: U) => Z
>value : T
>T : T
>otherValue : U
>U : U
>Z : Z
>otherCollection : Collection<任意, U>
>Collection : Collection<K, V>
>U : U
>OrderedSet : OrderedSet<T>
>Z : Z

    zipWith<U, V, Z>(zipper: (value: T, otherValue: U, thirdValue: V) => Z, otherCollection: Collection<any, U>, thirdCollection: Collection<any, V>): OrderedSet<Z>;
>zipWith : { <U, Z>(zipper: (value: T, otherValue: U) => Z, otherCollection: Collection<任意, U>): OrderedSet<Z>; <U, V, Z>(zipper: (value: T, otherValue: U, thirdValue: V) => Z, otherCollection: Collection<任意, U>, thirdCollection: Collection<任意, V>): OrderedSet<Z>; <Z>(zipper: (...any: 任意[]) => Z, ...collections: Collection<任意, 任意>[]): OrderedSet<Z>; }
>U : U
>V : V
>Z : Z
>zipper : (value: T, otherValue: U, thirdValue: V) => Z
>value : T
>T : T
>otherValue : U
>U : U
>thirdValue : V
>V : V
>Z : Z
>otherCollection : Collection<任意, U>
>Collection : Collection<K, V>
>U : U
>thirdCollection : Collection<任意, V>
>Collection : Collection<K, V>
>V : V
>OrderedSet : OrderedSet<T>
>Z : Z

    zipWith<Z>(zipper: (...any: Array<any>) => Z, ...collections: Array<Collection<any, any>>): OrderedSet<Z>;
>zipWith : { <U, Z>(zipper: (value: T, otherValue: U) => Z, otherCollection: Collection<任意, U>): OrderedSet<Z>; <U, V, Z>(zipper: (value: T, otherValue: U, thirdValue: V) => Z, otherCollection: Collection<任意, U>, thirdCollection: Collection<任意, V>): OrderedSet<Z>; <Z>(zipper: (...any: 任意[]) => Z, ...collections: Collection<任意, 任意>[]): OrderedSet<Z>; }
>Z : Z
>zipper : (...any: 任意[]) => Z
>any : 任意[]
>Array : T[]
>Z : Z
>collections : Collection<任意, 任意>[]
>Array : T[]
>Collection : Collection<K, V>
>OrderedSet : OrderedSet<T>
>Z : Z
  }
  export module Stack {
>Stack : 类为 Stack

    function isStack(maybeStack: any): maybeStack is Stack<any>;
>isStack : (maybeStack: 任意) => maybeStack 作为 Stack<任意>
>maybeStack : 任意
>类型别名 :=> 任意
>maybeStack : 任意
>类型别名 :=> 任意
>Stack : Stack<T>

    function of<T>(...values: Array<T>): Stack<T>;
>of : <T>(...values: T[]) => Stack<T>
>T : T
>values : T[]
>Array : T[]
>T : T
>Stack : Stack<T>
>T : T
  }
  export function Stack(): Stack<any>;
>Stack : 类为 Stack
>Stack : Stack<T>

  export function Stack<T>(): Stack<T>;
>Stack : 类为 Stack
>T : T
>Stack : Stack<T>
>T : T

  export function Stack<T>(collection: Iterable<T>): Stack<T>;
>Stack : 类为 Stack
>T : T
>collection : Iterable<T>
>Iterable : Iterable<T>
>T : T
>Stack : Stack<T>
>T : T

  export interface Stack<T> extends Collection.Indexed<T> {
>Stack : Stack<T>
>T : T
>Collection.Indexed : 任意
>类型别名 :=> 任意
>Collection : 类为 Collection
>Indexed : Collection.Indexed<T>
>T : T

    // Reading values
    peek(): T | undefined;
>peek : () => T
>T : T

    // Persistent changes
    clear(): Stack<T>;
>clear : () => Stack<T>
>Stack : Stack<T>
>T : T

    unshift(...values: Array<T>): Stack<T>;
>unshift : (...values: T[]) => Stack<T>
>values : T[]
>Array : T[]
>T : T
>Stack : Stack<T>
>T : T

    unshiftAll(iter: Iterable<T>): Stack<T>;
>unshiftAll : (iter: Iterable<T>) => Stack<T>
>iter : Iterable<T>
>Iterable : Iterable<T>
>T : T
>Stack : Stack<T>
>T : T

    shift(): Stack<T>;
>shift : () => Stack<T>
>Stack : Stack<T>
>T : T

    push(...values: Array<T>): Stack<T>;
>push : (...values: T[]) => Stack<T>
>values : T[]
>Array : T[]
>T : T
>Stack : Stack<T>
>T : T

    pushAll(iter: Iterable<T>): Stack<T>;
>pushAll : (iter: Iterable<T>) => Stack<T>
>iter : Iterable<T>
>Iterable : Iterable<T>
>T : T
>Stack : Stack<T>
>T : T

    pop(): Stack<T>;
>pop : () => Stack<T>
>Stack : Stack<T>
>T : T

    // Transient changes
    withMutations(mutator: (mutable: this) => any): this;
>withMutations : (mutator: (mutable: 本体) => 任意) => 本体
>mutator : (mutable: 本体) => 任意
>mutable : 本体

    asMutable(): this;
>asMutable : () => 本体

    asImmutable(): this;
>asImmutable : () => 本体

    // Sequence algorithms
    concat<C>(...valuesOrCollections: Array<Iterable<C> | C>): Stack<T | C>;
>concat : <C>(...valuesOrCollections: (C | Iterable<C>)[]) => Stack<T | C>
>C : C
>valuesOrCollections : (C | Iterable<C>)[]
>Array : T[]
>Iterable : Iterable<T>
>C : C
>C : C
>Stack : Stack<T>
>T : T
>C : C

    map<M>(mapper: (value: T, key: number, iter: this) => M, context?: any): Stack<M>;
>map : <M>(mapper: (value: T, key: 数字, iter: 本体) => M, context?: 任意) => Stack<M>
>M : M
>mapper : (value: T, key: 数字, iter: 本体) => M
>value : T
>T : T
>key : 数字
>类型别名 :=> 数字
>iter : 本体
>M : M
>context : 任意
>类型别名 :=> 任意
>Stack : Stack<T>
>M : M

    flatMap<M>(mapper: (value: T, key: number, iter: this) => Iterable<M>, context?: any): Stack<M>;
>flatMap : <M>(mapper: (value: T, key: 数字, iter: 本体) => Iterable<M>, context?: 任意) => Stack<M>
>M : M
>mapper : (value: T, key: 数字, iter: 本体) => Iterable<M>
>value : T
>T : T
>key : 数字
>类型别名 :=> 数字
>iter : 本体
>Iterable : Iterable<T>
>M : M
>context : 任意
>类型别名 :=> 任意
>Stack : Stack<T>
>M : M

    filter<F extends T>(predicate: (value: T, index: number, iter: this) => value is F, context?: any): Set<F>;
>filter : { <F 扩展 T>(predicate: (value: T, index: 数字, iter: 本体) => value 作为 F, context?: 任意): Set<F>; (predicate: (value: T, index: 数字, iter: 本体) => 任意, context?: 任意): 本体; }
>F : F
>T : T
>predicate : (value: T, index: 数字, iter: 本体) => value 作为 F
>value : T
>T : T
>index : 数字
>类型别名 :=> 数字
>iter : 本体
>value : 任意
>类型别名 :=> 任意
>F : F
>context : 任意
>类型别名 :=> 任意
>Set : Set<T>
>F : F

    filter(predicate: (value: T, index: number, iter: this) => any, context?: any): this;
>filter : { <F 扩展 T>(predicate: (value: T, index: 数字, iter: 本体) => value 作为 F, context?: 任意): Set<F>; (predicate: (value: T, index: 数字, iter: 本体) => 任意, context?: 任意): 本体; }
>predicate : (value: T, index: 数字, iter: 本体) => 任意
>value : T
>T : T
>index : 数字
>类型别名 :=> 数字
>iter : 本体
>context : 任意
>类型别名 :=> 任意
  }
  export function Range(start?: number, end?: number, step?: number): Seq.Indexed<number>;
>Range : (start?: 数字, end?: 数字, step?: 数字) => Seq.Indexed<数字>
>start : 数字
>类型别名 :=> 数字
>end : 数字
>类型别名 :=> 数字
>step : 数字
>类型别名 :=> 数字
>Seq : 任意
>类型别名 :=> 任意
>Indexed : Seq.Indexed<T>

  export function Repeat<T>(value: T, times?: number): Seq.Indexed<T>;
>Repeat : <T>(value: T, times?: 数字) => Seq.Indexed<T>
>T : T
>value : T
>T : T
>times : 数字
>类型别名 :=> 数字
>Seq : 任意
>类型别名 :=> 任意
>Indexed : Seq.Indexed<T>
>T : T

  export module Record {
>Record : 类为 Record

    export function isRecord(maybeRecord: any): maybeRecord is Record.Instance<any>;
>isRecord : (maybeRecord: 任意) => maybeRecord 作为 Instance<任意>
>maybeRecord : 任意
>类型别名 :=> 任意
>maybeRecord : 任意
>类型别名 :=> 任意
>Record : 任意
>类型别名 :=> 任意
>Instance : Instance<T>

    export function getDescriptiveName(record: Instance<any>): string;
>getDescriptiveName : (record: Instance<任意>) => 文字
>record : Instance<任意>
>Instance : Instance<T>

    export interface Class<T extends Object> {
>Class : Class<T>
>T : T
>Object : Object

      (values?: Partial<T> | Iterable<[string, any]>): Instance<T> & Readonly<T>;
>values : Partial<T> | Iterable<[文字, 任意]>
>Partial : Partial<T>
>T : T
>Iterable : Iterable<T>
>Instance : Instance<T>
>T : T
>Readonly : Readonly<T>
>T : T

      new (values?: Partial<T> | Iterable<[string, any]>): Instance<T> & Readonly<T>;
>values : Partial<T> | Iterable<[文字, 任意]>
>Partial : Partial<T>
>T : T
>Iterable : Iterable<T>
>Instance : Instance<T>
>T : T
>Readonly : Readonly<T>
>T : T
    }
    export interface Instance<T extends Object> {
>Instance : Instance<T>
>T : T
>Object : Object

      readonly size: number;
>size : 数字
>类型别名 :=> 数字

      // Reading values
      has(key: string): boolean;
>has : (key: 文字) => 真假
>key : 文字
>类型别名 :=> 文字

      get<K extends keyof T>(key: K): T[K];
>get : <K 扩展 键集 T>(key: K) => T[K]
>K : K
>T : T
>key : K
>K : K
>T : T
>K : K

      // Reading deep values
      hasIn(keyPath: Iterable<any>): boolean;
>hasIn : (keyPath: Iterable<任意>) => 真假
>keyPath : Iterable<任意>
>Iterable : Iterable<T>

      getIn(keyPath: Iterable<any>): any;
>getIn : (keyPath: Iterable<任意>) => 任意
>keyPath : Iterable<任意>
>Iterable : Iterable<T>

      // Value equality
      equals(other: any): boolean;
>equals : (other: 任意) => 真假
>other : 任意
>类型别名 :=> 任意

      hashCode(): number;
>hashCode : () => 数字

      // Persistent changes
      set<K extends keyof T>(key: K, value: T[K]): this;
>set : <K 扩展 键集 T>(key: K, value: T[K]) => 本体
>K : K
>T : T
>key : K
>K : K
>value : T[K]
>T : T
>K : K

      update<K extends keyof T>(key: K, updater: (value: T[K]) => T[K]): this;
>update : <K 扩展 键集 T>(key: K, updater: (value: T[K]) => T[K]) => 本体
>K : K
>T : T
>key : K
>K : K
>updater : (value: T[K]) => T[K]
>value : T[K]
>T : T
>K : K
>T : T
>K : K

      merge(...collections: Array<Partial<T> | Iterable<[string, any]>>): this;
>merge : (...collections: (Iterable<[文字, 任意]> | Partial<T>)[]) => 本体
>collections : (Iterable<[文字, 任意]> | Partial<T>)[]
>Array : T[]
>Partial : Partial<T>
>T : T
>Iterable : Iterable<T>

      mergeDeep(...collections: Array<Partial<T> | Iterable<[string, any]>>): this;
>mergeDeep : (...collections: (Iterable<[文字, 任意]> | Partial<T>)[]) => 本体
>collections : (Iterable<[文字, 任意]> | Partial<T>)[]
>Array : T[]
>Partial : Partial<T>
>T : T
>Iterable : Iterable<T>

      mergeWith(merger: (oldVal: any, newVal: any, key: keyof T) => any, ...collections: Array<Partial<T> | Iterable<[string, any]>>): this;
>mergeWith : (merger: (oldVal: 任意, newVal: 任意, key: 键集 T) => 任意, ...collections: (Iterable<[文字, 任意]> | Partial<T>)[]) => 本体
>merger : (oldVal: 任意, newVal: 任意, key: 键集 T) => 任意
>oldVal : 任意
>类型别名 :=> 任意
>newVal : 任意
>类型别名 :=> 任意
>key : 键集 T
>T : T
>collections : (Iterable<[文字, 任意]> | Partial<T>)[]
>Array : T[]
>Partial : Partial<T>
>T : T
>Iterable : Iterable<T>

      mergeDeepWith(merger: (oldVal: any, newVal: any, key: any) => any, ...collections: Array<Partial<T> | Iterable<[string, any]>>): this;
>mergeDeepWith : (merger: (oldVal: 任意, newVal: 任意, key: 任意) => 任意, ...collections: (Iterable<[文字, 任意]> | Partial<T>)[]) => 本体
>merger : (oldVal: 任意, newVal: 任意, key: 任意) => 任意
>oldVal : 任意
>类型别名 :=> 任意
>newVal : 任意
>类型别名 :=> 任意
>key : 任意
>类型别名 :=> 任意
>collections : (Iterable<[文字, 任意]> | Partial<T>)[]
>Array : T[]
>Partial : Partial<T>
>T : T
>Iterable : Iterable<T>

      delete<K extends keyof T>(key: K): this;
>delete : <K 扩展 键集 T>(key: K) => 本体
>K : K
>T : T
>key : K
>K : K

      remove<K extends keyof T>(key: K): this;
>remove : <K 扩展 键集 T>(key: K) => 本体
>K : K
>T : T
>key : K
>K : K

      clear(): this;
>clear : () => 本体

      // Deep persistent changes
      setIn(keyPath: Iterable<any>, value: any): this;
>setIn : (keyPath: Iterable<任意>, value: 任意) => 本体
>keyPath : Iterable<任意>
>Iterable : Iterable<T>
>value : 任意
>类型别名 :=> 任意

      updateIn(keyPath: Iterable<any>, updater: (value: any) => any): this;
>updateIn : (keyPath: Iterable<任意>, updater: (value: 任意) => 任意) => 本体
>keyPath : Iterable<任意>
>Iterable : Iterable<T>
>updater : (value: 任意) => 任意
>value : 任意
>类型别名 :=> 任意

      mergeIn(keyPath: Iterable<any>, ...collections: Array<any>): this;
>mergeIn : (keyPath: Iterable<任意>, ...collections: 任意[]) => 本体
>keyPath : Iterable<任意>
>Iterable : Iterable<T>
>collections : 任意[]
>Array : T[]

      mergeDeepIn(keyPath: Iterable<any>, ...collections: Array<any>): this;
>mergeDeepIn : (keyPath: Iterable<任意>, ...collections: 任意[]) => 本体
>keyPath : Iterable<任意>
>Iterable : Iterable<T>
>collections : 任意[]
>Array : T[]

      deleteIn(keyPath: Iterable<any>): this;
>deleteIn : (keyPath: Iterable<任意>) => 本体
>keyPath : Iterable<任意>
>Iterable : Iterable<T>

      removeIn(keyPath: Iterable<any>): this;
>removeIn : (keyPath: Iterable<任意>) => 本体
>keyPath : Iterable<任意>
>Iterable : Iterable<T>

      // Conversion to JavaScript types
      toJS(): { [K in keyof T]: any };
>toJS : () => { [K 位于 键集 T]: 任意; }
>K : K
>T : T

      toJSON(): T;
>toJSON : () => T
>T : T

      toObject(): T;
>toObject : () => T
>T : T

      // Transient changes
      withMutations(mutator: (mutable: this) => any): this;
>withMutations : (mutator: (mutable: 本体) => 任意) => 本体
>mutator : (mutable: 本体) => 任意
>mutable : 本体

      asMutable(): this;
>asMutable : () => 本体

      asImmutable(): this;
>asImmutable : () => 本体

      // Sequence algorithms
      toSeq(): Seq.Keyed<keyof T, T[keyof T]>;
>toSeq : () => Seq.Keyed<键集 T, T[键集 T]>
>Seq : 任意
>类型别名 :=> 任意
>Keyed : Seq.Keyed<K, V>
>T : T
>T : T
>T : T

      [Symbol.iterator](): IterableIterator<[keyof T, T[keyof T]]>;
>Symbol.iterator : 符号
>类型别名 :=> 符号
>Symbol : SymbolConstructor
>iterator : 符号
>类型别名 :=> 符号
>IterableIterator : IterableIterator<T>
>T : T
>T : T
>T : T
    }
  }
  export function Record<T>(defaultValues: T, name?: string): Record.Class<T>;
>Record : 类为 Record
>T : T
>defaultValues : T
>T : T
>name : 文字
>类型别名 :=> 文字
>Record : 任意
>类型别名 :=> 任意
>Class : Record.Class<T>
>T : T

  export module Seq {
>Seq : 类为 Seq

    function isSeq(maybeSeq: any): maybeSeq is Seq.Indexed<any> | Seq.Keyed<any, any>;
>isSeq : (maybeSeq: 任意) => maybeSeq 作为 Keyed<任意, 任意> | Indexed<任意>
>maybeSeq : 任意
>类型别名 :=> 任意
>maybeSeq : 任意
>类型别名 :=> 任意
>Seq : 任意
>类型别名 :=> 任意
>Indexed : Indexed<T>
>Seq : 任意
>类型别名 :=> 任意
>Keyed : Keyed<K, V>

    function of<T>(...values: Array<T>): Seq.Indexed<T>;
>of : <T>(...values: T[]) => Indexed<T>
>T : T
>values : T[]
>Array : T[]
>T : T
>Seq : 任意
>类型别名 :=> 任意
>Indexed : Indexed<T>
>T : T

    export module Keyed {}
>Keyed : { <K, V>(collection: Iterable<[K, V]>): Keyed<K, V>; <V>(obj: { [key: 文字]: V; }): Keyed<文字, V>; <K, V>(): Keyed<K, V>; (): Keyed<任意, 任意>; }

    export function Keyed<K, V>(collection: Iterable<[K, V]>): Seq.Keyed<K, V>;
>Keyed : { <K, V>(collection: Iterable<[K, V]>): Keyed<K, V>; <V>(obj: { [key: 文字]: V; }): Keyed<文字, V>; <K, V>(): Keyed<K, V>; (): Keyed<任意, 任意>; }
>K : K
>V : V
>collection : Iterable<[K, V]>
>Iterable : Iterable<T>
>K : K
>V : V
>Seq : 任意
>类型别名 :=> 任意
>Keyed : Keyed<K, V>
>K : K
>V : V

    export function Keyed<V>(obj: {[key: string]: V}): Seq.Keyed<string, V>;
>Keyed : { <K, V>(collection: Iterable<[K, V]>): Keyed<K, V>; <V>(obj: { [key: 文字]: V; }): Keyed<文字, V>; <K, V>(): Keyed<K, V>; (): Keyed<任意, 任意>; }
>V : V
>obj : { [key: 文字]: V; }
>key : 文字
>类型别名 :=> 文字
>V : V
>Seq : 任意
>类型别名 :=> 任意
>Keyed : Keyed<K, V>
>V : V

    export function Keyed<K, V>(): Seq.Keyed<K, V>;
>Keyed : { <K, V>(collection: Iterable<[K, V]>): Keyed<K, V>; <V>(obj: { [key: 文字]: V; }): Keyed<文字, V>; <K, V>(): Keyed<K, V>; (): Keyed<任意, 任意>; }
>K : K
>V : V
>Seq : 任意
>类型别名 :=> 任意
>Keyed : Keyed<K, V>
>K : K
>V : V

    export function Keyed(): Seq.Keyed<any, any>;
>Keyed : { <K, V>(collection: Iterable<[K, V]>): Keyed<K, V>; <V>(obj: { [key: 文字]: V; }): Keyed<文字, V>; <K, V>(): Keyed<K, V>; (): Keyed<任意, 任意>; }
>Seq : 任意
>类型别名 :=> 任意
>Keyed : Keyed<K, V>

    export interface Keyed<K, V> extends Seq<K, V>, Collection.Keyed<K, V> {
>Keyed : Keyed<K, V>
>K : K
>V : V
>Seq : Seq<K, V>
>K : K
>V : V
>Collection.Keyed : 任意
>类型别名 :=> 任意
>Collection : 类为 Collection
>Keyed : Collection.Keyed<K, V>
>K : K
>V : V

      toJS(): Object;
>toJS : () => Object
>Object : Object

      toJSON(): { [key: string]: V };
>toJSON : () => { [key: 文字]: V; }
>key : 文字
>类型别名 :=> 文字
>V : V

      toSeq(): this;
>toSeq : () => 本体

      concat<KC, VC>(...collections: Array<Iterable<[KC, VC]>>): Seq.Keyed<K | KC, V | VC>;
>concat : { <KC, VC>(...collections: Iterable<[KC, VC]>[]): Keyed<K | KC, V | VC>; <C>(...collections: { [key: 文字]: C; }[]): Keyed<文字 | K, V | C>; }
>KC : KC
>VC : VC
>collections : Iterable<[KC, VC]>[]
>Array : T[]
>Iterable : Iterable<T>
>KC : KC
>VC : VC
>Seq : 任意
>类型别名 :=> 任意
>Keyed : Keyed<K, V>
>K : K
>KC : KC
>V : V
>VC : VC

      concat<C>(...collections: Array<{[key: string]: C}>): Seq.Keyed<K | string, V | C>;
>concat : { <KC, VC>(...collections: Iterable<[KC, VC]>[]): Keyed<K | KC, V | VC>; <C>(...collections: { [key: 文字]: C; }[]): Keyed<文字 | K, V | C>; }
>C : C
>collections : { [key: 文字]: C; }[]
>Array : T[]
>key : 文字
>类型别名 :=> 文字
>C : C
>Seq : 任意
>类型别名 :=> 任意
>Keyed : Keyed<K, V>
>K : K
>V : V
>C : C

      map<M>(mapper: (value: V, key: K, iter: this) => M, context?: any): Seq.Keyed<K, M>;
>map : <M>(mapper: (value: V, key: K, iter: 本体) => M, context?: 任意) => Keyed<K, M>
>M : M
>mapper : (value: V, key: K, iter: 本体) => M
>value : V
>V : V
>key : K
>K : K
>iter : 本体
>M : M
>context : 任意
>类型别名 :=> 任意
>Seq : 任意
>类型别名 :=> 任意
>Keyed : Keyed<K, V>
>K : K
>M : M

      mapKeys<M>(mapper: (key: K, value: V, iter: this) => M, context?: any): Seq.Keyed<M, V>;
>mapKeys : <M>(mapper: (key: K, value: V, iter: 本体) => M, context?: 任意) => Keyed<M, V>
>M : M
>mapper : (key: K, value: V, iter: 本体) => M
>key : K
>K : K
>value : V
>V : V
>iter : 本体
>M : M
>context : 任意
>类型别名 :=> 任意
>Seq : 任意
>类型别名 :=> 任意
>Keyed : Keyed<K, V>
>M : M
>V : V

      mapEntries<KM, VM>(mapper: (entry: [K, V], index: number, iter: this) => [KM, VM], context?: any): Seq.Keyed<KM, VM>;
>mapEntries : <KM, VM>(mapper: (entry: [K, V], index: 数字, iter: 本体) => [KM, VM], context?: 任意) => Keyed<KM, VM>
>KM : KM
>VM : VM
>mapper : (entry: [K, V], index: 数字, iter: 本体) => [KM, VM]
>entry : [K, V]
>K : K
>V : V
>index : 数字
>类型别名 :=> 数字
>iter : 本体
>KM : KM
>VM : VM
>context : 任意
>类型别名 :=> 任意
>Seq : 任意
>类型别名 :=> 任意
>Keyed : Keyed<K, V>
>KM : KM
>VM : VM

      flatMap<M>(mapper: (value: V, key: K, iter: this) => Iterable<M>, context?: any): Seq.Keyed<any, any>;
>flatMap : <M>(mapper: (value: V, key: K, iter: 本体) => Iterable<M>, context?: 任意) => Keyed<任意, 任意>
>M : M
>mapper : (value: V, key: K, iter: 本体) => Iterable<M>
>value : V
>V : V
>key : K
>K : K
>iter : 本体
>Iterable : Iterable<T>
>M : M
>context : 任意
>类型别名 :=> 任意
>Seq : 任意
>类型别名 :=> 任意
>Keyed : Keyed<K, V>

      filter<F extends V>(predicate: (value: V, key: K, iter: this) => value is F, context?: any): Seq.Keyed<K, F>;
>filter : { <F 扩展 V>(predicate: (value: V, key: K, iter: 本体) => value 作为 F, context?: 任意): Keyed<K, F>; (predicate: (value: V, key: K, iter: 本体) => 任意, context?: 任意): 本体; }
>F : F
>V : V
>predicate : (value: V, key: K, iter: 本体) => value 作为 F
>value : V
>V : V
>key : K
>K : K
>iter : 本体
>value : 任意
>类型别名 :=> 任意
>F : F
>context : 任意
>类型别名 :=> 任意
>Seq : 任意
>类型别名 :=> 任意
>Keyed : Keyed<K, V>
>K : K
>F : F

      filter(predicate: (value: V, key: K, iter: this) => any, context?: any): this;
>filter : { <F 扩展 V>(predicate: (value: V, key: K, iter: 本体) => value 作为 F, context?: 任意): Keyed<K, F>; (predicate: (value: V, key: K, iter: 本体) => 任意, context?: 任意): 本体; }
>predicate : (value: V, key: K, iter: 本体) => 任意
>value : V
>V : V
>key : K
>K : K
>iter : 本体
>context : 任意
>类型别名 :=> 任意
    }
    module Indexed {
>Indexed : 类为 Indexed

      function of<T>(...values: Array<T>): Seq.Indexed<T>;
>of : <T>(...values: T[]) => Indexed<T>
>T : T
>values : T[]
>Array : T[]
>T : T
>Seq : 任意
>类型别名 :=> 任意
>Indexed : Indexed<T>
>T : T
    }
    export function Indexed(): Seq.Indexed<any>;
>Indexed : 类为 Indexed
>Seq : 任意
>类型别名 :=> 任意
>Indexed : Indexed<T>

    export function Indexed<T>(): Seq.Indexed<T>;
>Indexed : 类为 Indexed
>T : T
>Seq : 任意
>类型别名 :=> 任意
>Indexed : Indexed<T>
>T : T

    export function Indexed<T>(collection: Iterable<T>): Seq.Indexed<T>;
>Indexed : 类为 Indexed
>T : T
>collection : Iterable<T>
>Iterable : Iterable<T>
>T : T
>Seq : 任意
>类型别名 :=> 任意
>Indexed : Indexed<T>
>T : T

    export interface Indexed<T> extends Seq<number, T>, Collection.Indexed<T> {
>Indexed : Indexed<T>
>T : T
>Seq : Seq<K, V>
>T : T
>Collection.Indexed : 任意
>类型别名 :=> 任意
>Collection : 类为 Collection
>Indexed : Collection.Indexed<T>
>T : T

      toJS(): Array<any>;
>toJS : () => 任意[]
>Array : T[]

      toJSON(): Array<T>;
>toJSON : () => T[]
>Array : T[]
>T : T

      toSeq(): this;
>toSeq : () => 本体

      concat<C>(...valuesOrCollections: Array<Iterable<C> | C>): Seq.Indexed<T | C>;
>concat : <C>(...valuesOrCollections: (C | Iterable<C>)[]) => Indexed<T | C>
>C : C
>valuesOrCollections : (C | Iterable<C>)[]
>Array : T[]
>Iterable : Iterable<T>
>C : C
>C : C
>Seq : 任意
>类型别名 :=> 任意
>Indexed : Indexed<T>
>T : T
>C : C

      map<M>(mapper: (value: T, key: number, iter: this) => M, context?: any): Seq.Indexed<M>;
>map : <M>(mapper: (value: T, key: 数字, iter: 本体) => M, context?: 任意) => Indexed<M>
>M : M
>mapper : (value: T, key: 数字, iter: 本体) => M
>value : T
>T : T
>key : 数字
>类型别名 :=> 数字
>iter : 本体
>M : M
>context : 任意
>类型别名 :=> 任意
>Seq : 任意
>类型别名 :=> 任意
>Indexed : Indexed<T>
>M : M

      flatMap<M>(mapper: (value: T, key: number, iter: this) => Iterable<M>, context?: any): Seq.Indexed<M>;
>flatMap : <M>(mapper: (value: T, key: 数字, iter: 本体) => Iterable<M>, context?: 任意) => Indexed<M>
>M : M
>mapper : (value: T, key: 数字, iter: 本体) => Iterable<M>
>value : T
>T : T
>key : 数字
>类型别名 :=> 数字
>iter : 本体
>Iterable : Iterable<T>
>M : M
>context : 任意
>类型别名 :=> 任意
>Seq : 任意
>类型别名 :=> 任意
>Indexed : Indexed<T>
>M : M

      filter<F extends T>(predicate: (value: T, index: number, iter: this) => value is F, context?: any): Seq.Indexed<F>;
>filter : { <F 扩展 T>(predicate: (value: T, index: 数字, iter: 本体) => value 作为 F, context?: 任意): Indexed<F>; (predicate: (value: T, index: 数字, iter: 本体) => 任意, context?: 任意): 本体; }
>F : F
>T : T
>predicate : (value: T, index: 数字, iter: 本体) => value 作为 F
>value : T
>T : T
>index : 数字
>类型别名 :=> 数字
>iter : 本体
>value : 任意
>类型别名 :=> 任意
>F : F
>context : 任意
>类型别名 :=> 任意
>Seq : 任意
>类型别名 :=> 任意
>Indexed : Indexed<T>
>F : F

      filter(predicate: (value: T, index: number, iter: this) => any, context?: any): this;
>filter : { <F 扩展 T>(predicate: (value: T, index: 数字, iter: 本体) => value 作为 F, context?: 任意): Indexed<F>; (predicate: (value: T, index: 数字, iter: 本体) => 任意, context?: 任意): 本体; }
>predicate : (value: T, index: 数字, iter: 本体) => 任意
>value : T
>T : T
>index : 数字
>类型别名 :=> 数字
>iter : 本体
>context : 任意
>类型别名 :=> 任意
    }
    export module Set {
>Set : 类为 Set

      function of<T>(...values: Array<T>): Seq.Set<T>;
>of : <T>(...values: T[]) => Set<T>
>T : T
>values : T[]
>Array : T[]
>T : T
>Seq : 任意
>类型别名 :=> 任意
>Set : Set<T>
>T : T
    }
    export function Set(): Seq.Set<any>;
>Set : 类为 Set
>Seq : 任意
>类型别名 :=> 任意
>Set : Set<T>

    export function Set<T>(): Seq.Set<T>;
>Set : 类为 Set
>T : T
>Seq : 任意
>类型别名 :=> 任意
>Set : Set<T>
>T : T

    export function Set<T>(collection: Iterable<T>): Seq.Set<T>;
>Set : 类为 Set
>T : T
>collection : Iterable<T>
>Iterable : Iterable<T>
>T : T
>Seq : 任意
>类型别名 :=> 任意
>Set : Set<T>
>T : T

    export interface Set<T> extends Seq<never, T>, Collection.Set<T> {
>Set : Set<T>
>T : T
>Seq : Seq<K, V>
>T : T
>Collection.Set : 任意
>类型别名 :=> 任意
>Collection : 类为 Collection
>Set : Collection.Set<T>
>T : T

      toJS(): Array<any>;
>toJS : () => 任意[]
>Array : T[]

      toJSON(): Array<T>;
>toJSON : () => T[]
>Array : T[]
>T : T

      toSeq(): this;
>toSeq : () => 本体

      concat<C>(...valuesOrCollections: Array<Iterable<C> | C>): Seq.Set<T | C>;
>concat : <C>(...valuesOrCollections: (C | Iterable<C>)[]) => Set<T | C>
>C : C
>valuesOrCollections : (C | Iterable<C>)[]
>Array : T[]
>Iterable : Iterable<T>
>C : C
>C : C
>Seq : 任意
>类型别名 :=> 任意
>Set : Set<T>
>T : T
>C : C

      map<M>(mapper: (value: T, key: never, iter: this) => M, context?: any): Seq.Set<M>;
>map : <M>(mapper: (value: T, key: 不及, iter: 本体) => M, context?: 任意) => Set<M>
>M : M
>mapper : (value: T, key: 不及, iter: 本体) => M
>value : T
>T : T
>key : 不及
>类型别名 :=> 不及
>iter : 本体
>M : M
>context : 任意
>类型别名 :=> 任意
>Seq : 任意
>类型别名 :=> 任意
>Set : Set<T>
>M : M

      flatMap<M>(mapper: (value: T, key: never, iter: this) => Iterable<M>, context?: any): Seq.Set<M>;
>flatMap : <M>(mapper: (value: T, key: 不及, iter: 本体) => Iterable<M>, context?: 任意) => Set<M>
>M : M
>mapper : (value: T, key: 不及, iter: 本体) => Iterable<M>
>value : T
>T : T
>key : 不及
>类型别名 :=> 不及
>iter : 本体
>Iterable : Iterable<T>
>M : M
>context : 任意
>类型别名 :=> 任意
>Seq : 任意
>类型别名 :=> 任意
>Set : Set<T>
>M : M

      filter<F extends T>(predicate: (value: T, key: never, iter: this) => value is F, context?: any): Seq.Set<F>;
>filter : { <F 扩展 T>(predicate: (value: T, key: 不及, iter: 本体) => value 作为 F, context?: 任意): Set<F>; (predicate: (value: T, key: 不及, iter: 本体) => 任意, context?: 任意): 本体; }
>F : F
>T : T
>predicate : (value: T, key: 不及, iter: 本体) => value 作为 F
>value : T
>T : T
>key : 不及
>类型别名 :=> 不及
>iter : 本体
>value : 任意
>类型别名 :=> 任意
>F : F
>context : 任意
>类型别名 :=> 任意
>Seq : 任意
>类型别名 :=> 任意
>Set : Set<T>
>F : F

      filter(predicate: (value: T, key: never, iter: this) => any, context?: any): this;
>filter : { <F 扩展 T>(predicate: (value: T, key: 不及, iter: 本体) => value 作为 F, context?: 任意): Set<F>; (predicate: (value: T, key: 不及, iter: 本体) => 任意, context?: 任意): 本体; }
>predicate : (value: T, key: 不及, iter: 本体) => 任意
>value : T
>T : T
>key : 不及
>类型别名 :=> 不及
>iter : 本体
>context : 任意
>类型别名 :=> 任意
    }
  }
  export function Seq<S extends Seq<any, any>>(seq: S): S;
>Seq : 类为 Seq
>S : S
>Seq : Seq<K, V>
>seq : S
>S : S
>S : S

  export function Seq<K, V>(collection: Collection.Keyed<K, V>): Seq.Keyed<K, V>;
>Seq : 类为 Seq
>K : K
>V : V
>collection : Collection.Keyed<K, V>
>Collection : 任意
>类型别名 :=> 任意
>Keyed : Collection.Keyed<K, V>
>K : K
>V : V
>Seq : 任意
>类型别名 :=> 任意
>Keyed : Seq.Keyed<K, V>
>K : K
>V : V

  export function Seq<T>(collection: Collection.Indexed<T>): Seq.Indexed<T>;
>Seq : 类为 Seq
>T : T
>collection : Collection.Indexed<T>
>Collection : 任意
>类型别名 :=> 任意
>Indexed : Collection.Indexed<T>
>T : T
>Seq : 任意
>类型别名 :=> 任意
>Indexed : Seq.Indexed<T>
>T : T

  export function Seq<T>(collection: Collection.Set<T>): Seq.Set<T>;
>Seq : 类为 Seq
>T : T
>collection : Collection.Set<T>
>Collection : 任意
>类型别名 :=> 任意
>Set : Collection.Set<T>
>T : T
>Seq : 任意
>类型别名 :=> 任意
>Set : Seq.Set<T>
>T : T

  export function Seq<T>(collection: Iterable<T>): Seq.Indexed<T>;
>Seq : 类为 Seq
>T : T
>collection : Iterable<T>
>Iterable : Iterable<T>
>T : T
>Seq : 任意
>类型别名 :=> 任意
>Indexed : Seq.Indexed<T>
>T : T

  export function Seq<V>(obj: {[key: string]: V}): Seq.Keyed<string, V>;
>Seq : 类为 Seq
>V : V
>obj : { [key: 文字]: V; }
>key : 文字
>类型别名 :=> 文字
>V : V
>Seq : 任意
>类型别名 :=> 任意
>Keyed : Seq.Keyed<K, V>
>V : V

  export function Seq(): Seq<any, any>;
>Seq : 类为 Seq
>Seq : Seq<K, V>

  export interface Seq<K, V> extends Collection<K, V> {
>Seq : Seq<K, V>
>K : K
>V : V
>Collection : Collection<K, V>
>K : K
>V : V

    readonly size: number | undefined;
>size : 数字
>类型别名 :=> 数字

    // Force evaluation
    cacheResult(): this;
>cacheResult : () => 本体

    // Sequence algorithms
    map<M>(mapper: (value: V, key: K, iter: this) => M, context?: any): Seq<K, M>;
>map : <M>(mapper: (value: V, key: K, iter: 本体) => M, context?: 任意) => Seq<K, M>
>M : M
>mapper : (value: V, key: K, iter: 本体) => M
>value : V
>V : V
>key : K
>K : K
>iter : 本体
>M : M
>context : 任意
>类型别名 :=> 任意
>Seq : Seq<K, V>
>K : K
>M : M

    flatMap<M>(mapper: (value: V, key: K, iter: this) => Iterable<M>, context?: any): Seq<K, M>;
>flatMap : <M>(mapper: (value: V, key: K, iter: 本体) => Iterable<M>, context?: 任意) => Seq<K, M>
>M : M
>mapper : (value: V, key: K, iter: 本体) => Iterable<M>
>value : V
>V : V
>key : K
>K : K
>iter : 本体
>Iterable : Iterable<T>
>M : M
>context : 任意
>类型别名 :=> 任意
>Seq : Seq<K, V>
>K : K
>M : M

    filter<F extends V>(predicate: (value: V, key: K, iter: this) => value is F, context?: any): Seq<K, F>;
>filter : { <F 扩展 V>(predicate: (value: V, key: K, iter: 本体) => value 作为 F, context?: 任意): Seq<K, F>; (predicate: (value: V, key: K, iter: 本体) => 任意, context?: 任意): 本体; }
>F : F
>V : V
>predicate : (value: V, key: K, iter: 本体) => value 作为 F
>value : V
>V : V
>key : K
>K : K
>iter : 本体
>value : 任意
>类型别名 :=> 任意
>F : F
>context : 任意
>类型别名 :=> 任意
>Seq : Seq<K, V>
>K : K
>F : F

    filter(predicate: (value: V, key: K, iter: this) => any, context?: any): this;
>filter : { <F 扩展 V>(predicate: (value: V, key: K, iter: 本体) => value 作为 F, context?: 任意): Seq<K, F>; (predicate: (value: V, key: K, iter: 本体) => 任意, context?: 任意): 本体; }
>predicate : (value: V, key: K, iter: 本体) => 任意
>value : V
>V : V
>key : K
>K : K
>iter : 本体
>context : 任意
>类型别名 :=> 任意
  }
  export module Collection {
>Collection : 类为 Collection

    function isKeyed(maybeKeyed: any): maybeKeyed is Collection.Keyed<any, any>;
>isKeyed : (maybeKeyed: 任意) => maybeKeyed 作为 Keyed<任意, 任意>
>maybeKeyed : 任意
>类型别名 :=> 任意
>maybeKeyed : 任意
>类型别名 :=> 任意
>Collection : 任意
>类型别名 :=> 任意
>Keyed : Keyed<K, V>

    function isIndexed(maybeIndexed: any): maybeIndexed is Collection.Indexed<any>;
>isIndexed : (maybeIndexed: 任意) => maybeIndexed 作为 Indexed<任意>
>maybeIndexed : 任意
>类型别名 :=> 任意
>maybeIndexed : 任意
>类型别名 :=> 任意
>Collection : 任意
>类型别名 :=> 任意
>Indexed : Indexed<T>

    function isAssociative(maybeAssociative: any): maybeAssociative is Collection.Keyed<any, any> | Collection.Indexed<any>;
>isAssociative : (maybeAssociative: 任意) => maybeAssociative 作为 Indexed<任意> | Keyed<任意, 任意>
>maybeAssociative : 任意
>类型别名 :=> 任意
>maybeAssociative : 任意
>类型别名 :=> 任意
>Collection : 任意
>类型别名 :=> 任意
>Keyed : Keyed<K, V>
>Collection : 任意
>类型别名 :=> 任意
>Indexed : Indexed<T>

    function isOrdered(maybeOrdered: any): boolean;
>isOrdered : (maybeOrdered: 任意) => 真假
>maybeOrdered : 任意
>类型别名 :=> 任意

    export module Keyed {}
>Keyed : { <K, V>(collection: Iterable<[K, V]>): Keyed<K, V>; <V>(obj: { [key: 文字]: V; }): Keyed<文字, V>; }

    export function Keyed<K, V>(collection: Iterable<[K, V]>): Collection.Keyed<K, V>;
>Keyed : { <K, V>(collection: Iterable<[K, V]>): Keyed<K, V>; <V>(obj: { [key: 文字]: V; }): Keyed<文字, V>; }
>K : K
>V : V
>collection : Iterable<[K, V]>
>Iterable : Iterable<T>
>K : K
>V : V
>Collection : 任意
>类型别名 :=> 任意
>Keyed : Keyed<K, V>
>K : K
>V : V

    export function Keyed<V>(obj: {[key: string]: V}): Collection.Keyed<string, V>;
>Keyed : { <K, V>(collection: Iterable<[K, V]>): Keyed<K, V>; <V>(obj: { [key: 文字]: V; }): Keyed<文字, V>; }
>V : V
>obj : { [key: 文字]: V; }
>key : 文字
>类型别名 :=> 文字
>V : V
>Collection : 任意
>类型别名 :=> 任意
>Keyed : Keyed<K, V>
>V : V

    export interface Keyed<K, V> extends Collection<K, V> {
>Keyed : Keyed<K, V>
>K : K
>V : V
>Collection : Collection<K, V>
>K : K
>V : V

      toJS(): Object;
>toJS : () => Object
>Object : Object

      toJSON(): { [key: string]: V };
>toJSON : () => { [key: 文字]: V; }
>key : 文字
>类型别名 :=> 文字
>V : V

      toSeq(): Seq.Keyed<K, V>;
>toSeq : () => Seq.Keyed<K, V>
>Seq : 任意
>类型别名 :=> 任意
>Keyed : Seq.Keyed<K, V>
>K : K
>V : V

      // Sequence functions
      flip(): this;
>flip : () => 本体

      concat<KC, VC>(...collections: Array<Iterable<[KC, VC]>>): Collection.Keyed<K | KC, V | VC>;
>concat : { <KC, VC>(...collections: Iterable<[KC, VC]>[]): Keyed<K | KC, V | VC>; <C>(...collections: { [key: 文字]: C; }[]): Keyed<文字 | K, V | C>; }
>KC : KC
>VC : VC
>collections : Iterable<[KC, VC]>[]
>Array : T[]
>Iterable : Iterable<T>
>KC : KC
>VC : VC
>Collection : 任意
>类型别名 :=> 任意
>Keyed : Keyed<K, V>
>K : K
>KC : KC
>V : V
>VC : VC

      concat<C>(...collections: Array<{[key: string]: C}>): Collection.Keyed<K | string, V | C>;
>concat : { <KC, VC>(...collections: Iterable<[KC, VC]>[]): Keyed<K | KC, V | VC>; <C>(...collections: { [key: 文字]: C; }[]): Keyed<文字 | K, V | C>; }
>C : C
>collections : { [key: 文字]: C; }[]
>Array : T[]
>key : 文字
>类型别名 :=> 文字
>C : C
>Collection : 任意
>类型别名 :=> 任意
>Keyed : Keyed<K, V>
>K : K
>V : V
>C : C

      map<M>(mapper: (value: V, key: K, iter: this) => M, context?: any): Collection.Keyed<K, M>;
>map : <M>(mapper: (value: V, key: K, iter: 本体) => M, context?: 任意) => Keyed<K, M>
>M : M
>mapper : (value: V, key: K, iter: 本体) => M
>value : V
>V : V
>key : K
>K : K
>iter : 本体
>M : M
>context : 任意
>类型别名 :=> 任意
>Collection : 任意
>类型别名 :=> 任意
>Keyed : Keyed<K, V>
>K : K
>M : M

      mapKeys<M>(mapper: (key: K, value: V, iter: this) => M, context?: any): Collection.Keyed<M, V>;
>mapKeys : <M>(mapper: (key: K, value: V, iter: 本体) => M, context?: 任意) => Keyed<M, V>
>M : M
>mapper : (key: K, value: V, iter: 本体) => M
>key : K
>K : K
>value : V
>V : V
>iter : 本体
>M : M
>context : 任意
>类型别名 :=> 任意
>Collection : 任意
>类型别名 :=> 任意
>Keyed : Keyed<K, V>
>M : M
>V : V

      mapEntries<KM, VM>(mapper: (entry: [K, V], index: number, iter: this) => [KM, VM], context?: any): Collection.Keyed<KM, VM>;
>mapEntries : <KM, VM>(mapper: (entry: [K, V], index: 数字, iter: 本体) => [KM, VM], context?: 任意) => Keyed<KM, VM>
>KM : KM
>VM : VM
>mapper : (entry: [K, V], index: 数字, iter: 本体) => [KM, VM]
>entry : [K, V]
>K : K
>V : V
>index : 数字
>类型别名 :=> 数字
>iter : 本体
>KM : KM
>VM : VM
>context : 任意
>类型别名 :=> 任意
>Collection : 任意
>类型别名 :=> 任意
>Keyed : Keyed<K, V>
>KM : KM
>VM : VM

      flatMap<M>(mapper: (value: V, key: K, iter: this) => Iterable<M>, context?: any): Collection.Keyed<any, any>;
>flatMap : <M>(mapper: (value: V, key: K, iter: 本体) => Iterable<M>, context?: 任意) => Keyed<任意, 任意>
>M : M
>mapper : (value: V, key: K, iter: 本体) => Iterable<M>
>value : V
>V : V
>key : K
>K : K
>iter : 本体
>Iterable : Iterable<T>
>M : M
>context : 任意
>类型别名 :=> 任意
>Collection : 任意
>类型别名 :=> 任意
>Keyed : Keyed<K, V>

      filter<F extends V>(predicate: (value: V, key: K, iter: this) => value is F, context?: any): Collection.Keyed<K, F>;
>filter : { <F 扩展 V>(predicate: (value: V, key: K, iter: 本体) => value 作为 F, context?: 任意): Keyed<K, F>; (predicate: (value: V, key: K, iter: 本体) => 任意, context?: 任意): 本体; }
>F : F
>V : V
>predicate : (value: V, key: K, iter: 本体) => value 作为 F
>value : V
>V : V
>key : K
>K : K
>iter : 本体
>value : 任意
>类型别名 :=> 任意
>F : F
>context : 任意
>类型别名 :=> 任意
>Collection : 任意
>类型别名 :=> 任意
>Keyed : Keyed<K, V>
>K : K
>F : F

      filter(predicate: (value: V, key: K, iter: this) => any, context?: any): this;
>filter : { <F 扩展 V>(predicate: (value: V, key: K, iter: 本体) => value 作为 F, context?: 任意): Keyed<K, F>; (predicate: (value: V, key: K, iter: 本体) => 任意, context?: 任意): 本体; }
>predicate : (value: V, key: K, iter: 本体) => 任意
>value : V
>V : V
>key : K
>K : K
>iter : 本体
>context : 任意
>类型别名 :=> 任意

      [Symbol.iterator](): IterableIterator<[K, V]>;
>Symbol.iterator : 符号
>类型别名 :=> 符号
>Symbol : SymbolConstructor
>iterator : 符号
>类型别名 :=> 符号
>IterableIterator : IterableIterator<T>
>K : K
>V : V
    }
    export module Indexed {}
>Indexed : <T>(collection: Iterable<T>) => Indexed<T>

    export function Indexed<T>(collection: Iterable<T>): Collection.Indexed<T>;
>Indexed : <T>(collection: Iterable<T>) => Indexed<T>
>T : T
>collection : Iterable<T>
>Iterable : Iterable<T>
>T : T
>Collection : 任意
>类型别名 :=> 任意
>Indexed : Indexed<T>
>T : T

    export interface Indexed<T> extends Collection<number, T> {
>Indexed : Indexed<T>
>T : T
>Collection : Collection<K, V>
>T : T

      toJS(): Array<any>;
>toJS : () => 任意[]
>Array : T[]

      toJSON(): Array<T>;
>toJSON : () => T[]
>Array : T[]
>T : T

      // Reading values
      get<NSV>(index: number, notSetValue: NSV): T | NSV;
>get : { <NSV>(index: 数字, notSetValue: NSV): T | NSV; (index: 数字): T; }
>NSV : NSV
>index : 数字
>类型别名 :=> 数字
>notSetValue : NSV
>NSV : NSV
>T : T
>NSV : NSV

      get(index: number): T | undefined;
>get : { <NSV>(index: 数字, notSetValue: NSV): T | NSV; (index: 数字): T; }
>index : 数字
>类型别名 :=> 数字
>T : T

      // Conversion to Seq
      toSeq(): Seq.Indexed<T>;
>toSeq : () => Seq.Indexed<T>
>Seq : 任意
>类型别名 :=> 任意
>Indexed : Seq.Indexed<T>
>T : T

      fromEntrySeq(): Seq.Keyed<any, any>;
>fromEntrySeq : () => Seq.Keyed<任意, 任意>
>Seq : 任意
>类型别名 :=> 任意
>Keyed : Seq.Keyed<K, V>

      // Combination
      interpose(separator: T): this;
>interpose : (separator: T) => 本体
>separator : T
>T : T

      interleave(...collections: Array<Collection<any, T>>): this;
>interleave : (...collections: Collection<任意, T>[]) => 本体
>collections : Collection<任意, T>[]
>Array : T[]
>Collection : Collection<K, V>
>T : T

      splice(index: number, removeNum: number, ...values: Array<T>): this;
>splice : (index: 数字, removeNum: 数字, ...values: T[]) => 本体
>index : 数字
>类型别名 :=> 数字
>removeNum : 数字
>类型别名 :=> 数字
>values : T[]
>Array : T[]
>T : T

      zip(...collections: Array<Collection<any, any>>): Collection.Indexed<any>;
>zip : (...collections: Collection<任意, 任意>[]) => Indexed<任意>
>collections : Collection<任意, 任意>[]
>Array : T[]
>Collection : Collection<K, V>
>Collection : 任意
>类型别名 :=> 任意
>Indexed : Indexed<T>

      zipWith<U, Z>(zipper: (value: T, otherValue: U) => Z, otherCollection: Collection<any, U>): Collection.Indexed<Z>;
>zipWith : { <U, Z>(zipper: (value: T, otherValue: U) => Z, otherCollection: Collection<任意, U>): Indexed<Z>; <U, V, Z>(zipper: (value: T, otherValue: U, thirdValue: V) => Z, otherCollection: Collection<任意, U>, thirdCollection: Collection<任意, V>): Indexed<Z>; <Z>(zipper: (...any: 任意[]) => Z, ...collections: Collection<任意, 任意>[]): Indexed<Z>; }
>U : U
>Z : Z
>zipper : (value: T, otherValue: U) => Z
>value : T
>T : T
>otherValue : U
>U : U
>Z : Z
>otherCollection : Collection<任意, U>
>Collection : Collection<K, V>
>U : U
>Collection : 任意
>类型别名 :=> 任意
>Indexed : Indexed<T>
>Z : Z

      zipWith<U, V, Z>(zipper: (value: T, otherValue: U, thirdValue: V) => Z, otherCollection: Collection<any, U>, thirdCollection: Collection<any, V>): Collection.Indexed<Z>;
>zipWith : { <U, Z>(zipper: (value: T, otherValue: U) => Z, otherCollection: Collection<任意, U>): Indexed<Z>; <U, V, Z>(zipper: (value: T, otherValue: U, thirdValue: V) => Z, otherCollection: Collection<任意, U>, thirdCollection: Collection<任意, V>): Indexed<Z>; <Z>(zipper: (...any: 任意[]) => Z, ...collections: Collection<任意, 任意>[]): Indexed<Z>; }
>U : U
>V : V
>Z : Z
>zipper : (value: T, otherValue: U, thirdValue: V) => Z
>value : T
>T : T
>otherValue : U
>U : U
>thirdValue : V
>V : V
>Z : Z
>otherCollection : Collection<任意, U>
>Collection : Collection<K, V>
>U : U
>thirdCollection : Collection<任意, V>
>Collection : Collection<K, V>
>V : V
>Collection : 任意
>类型别名 :=> 任意
>Indexed : Indexed<T>
>Z : Z

      zipWith<Z>(zipper: (...any: Array<any>) => Z, ...collections: Array<Collection<any, any>>): Collection.Indexed<Z>;
>zipWith : { <U, Z>(zipper: (value: T, otherValue: U) => Z, otherCollection: Collection<任意, U>): Indexed<Z>; <U, V, Z>(zipper: (value: T, otherValue: U, thirdValue: V) => Z, otherCollection: Collection<任意, U>, thirdCollection: Collection<任意, V>): Indexed<Z>; <Z>(zipper: (...any: 任意[]) => Z, ...collections: Collection<任意, 任意>[]): Indexed<Z>; }
>Z : Z
>zipper : (...any: 任意[]) => Z
>any : 任意[]
>Array : T[]
>Z : Z
>collections : Collection<任意, 任意>[]
>Array : T[]
>Collection : Collection<K, V>
>Collection : 任意
>类型别名 :=> 任意
>Indexed : Indexed<T>
>Z : Z

      // Search for value
      indexOf(searchValue: T): number;
>indexOf : (searchValue: T) => 数字
>searchValue : T
>T : T

      lastIndexOf(searchValue: T): number;
>lastIndexOf : (searchValue: T) => 数字
>searchValue : T
>T : T

      findIndex(predicate: (value: T, index: number, iter: this) => boolean, context?: any): number;
>findIndex : (predicate: (value: T, index: 数字, iter: 本体) => 真假, context?: 任意) => 数字
>predicate : (value: T, index: 数字, iter: 本体) => 真假
>value : T
>T : T
>index : 数字
>类型别名 :=> 数字
>iter : 本体
>context : 任意
>类型别名 :=> 任意

      findLastIndex(predicate: (value: T, index: number, iter: this) => boolean, context?: any): number;
>findLastIndex : (predicate: (value: T, index: 数字, iter: 本体) => 真假, context?: 任意) => 数字
>predicate : (value: T, index: 数字, iter: 本体) => 真假
>value : T
>T : T
>index : 数字
>类型别名 :=> 数字
>iter : 本体
>context : 任意
>类型别名 :=> 任意

      // Sequence algorithms
      concat<C>(...valuesOrCollections: Array<Iterable<C> | C>): Collection.Indexed<T | C>;
>concat : <C>(...valuesOrCollections: (C | Iterable<C>)[]) => Indexed<T | C>
>C : C
>valuesOrCollections : (C | Iterable<C>)[]
>Array : T[]
>Iterable : Iterable<T>
>C : C
>C : C
>Collection : 任意
>类型别名 :=> 任意
>Indexed : Indexed<T>
>T : T
>C : C

      map<M>(mapper: (value: T, key: number, iter: this) => M, context?: any): Collection.Indexed<M>;
>map : <M>(mapper: (value: T, key: 数字, iter: 本体) => M, context?: 任意) => Indexed<M>
>M : M
>mapper : (value: T, key: 数字, iter: 本体) => M
>value : T
>T : T
>key : 数字
>类型别名 :=> 数字
>iter : 本体
>M : M
>context : 任意
>类型别名 :=> 任意
>Collection : 任意
>类型别名 :=> 任意
>Indexed : Indexed<T>
>M : M

      flatMap<M>(mapper: (value: T, key: number, iter: this) => Iterable<M>, context?: any): Collection.Indexed<M>;
>flatMap : <M>(mapper: (value: T, key: 数字, iter: 本体) => Iterable<M>, context?: 任意) => Indexed<M>
>M : M
>mapper : (value: T, key: 数字, iter: 本体) => Iterable<M>
>value : T
>T : T
>key : 数字
>类型别名 :=> 数字
>iter : 本体
>Iterable : Iterable<T>
>M : M
>context : 任意
>类型别名 :=> 任意
>Collection : 任意
>类型别名 :=> 任意
>Indexed : Indexed<T>
>M : M

      filter<F extends T>(predicate: (value: T, index: number, iter: this) => value is F, context?: any): Collection.Indexed<F>;
>filter : { <F 扩展 T>(predicate: (value: T, index: 数字, iter: 本体) => value 作为 F, context?: 任意): Indexed<F>; (predicate: (value: T, index: 数字, iter: 本体) => 任意, context?: 任意): 本体; }
>F : F
>T : T
>predicate : (value: T, index: 数字, iter: 本体) => value 作为 F
>value : T
>T : T
>index : 数字
>类型别名 :=> 数字
>iter : 本体
>value : 任意
>类型别名 :=> 任意
>F : F
>context : 任意
>类型别名 :=> 任意
>Collection : 任意
>类型别名 :=> 任意
>Indexed : Indexed<T>
>F : F

      filter(predicate: (value: T, index: number, iter: this) => any, context?: any): this;
>filter : { <F 扩展 T>(predicate: (value: T, index: 数字, iter: 本体) => value 作为 F, context?: 任意): Indexed<F>; (predicate: (value: T, index: 数字, iter: 本体) => 任意, context?: 任意): 本体; }
>predicate : (value: T, index: 数字, iter: 本体) => 任意
>value : T
>T : T
>index : 数字
>类型别名 :=> 数字
>iter : 本体
>context : 任意
>类型别名 :=> 任意

      [Symbol.iterator](): IterableIterator<T>;
>Symbol.iterator : 符号
>类型别名 :=> 符号
>Symbol : SymbolConstructor
>iterator : 符号
>类型别名 :=> 符号
>IterableIterator : IterableIterator<T>
>T : T
    }
    export module Set {}
>Set : <T>(collection: Iterable<T>) => Set<T>

    export function Set<T>(collection: Iterable<T>): Collection.Set<T>;
>Set : <T>(collection: Iterable<T>) => Set<T>
>T : T
>collection : Iterable<T>
>Iterable : Iterable<T>
>T : T
>Collection : 任意
>类型别名 :=> 任意
>Set : Set<T>
>T : T

    export interface Set<T> extends Collection<never, T> {
>Set : Set<T>
>T : T
>Collection : Collection<K, V>
>T : T

      toJS(): Array<any>;
>toJS : () => 任意[]
>Array : T[]

      toJSON(): Array<T>;
>toJSON : () => T[]
>Array : T[]
>T : T

      toSeq(): Seq.Set<T>;
>toSeq : () => Seq.Set<T>
>Seq : 任意
>类型别名 :=> 任意
>Set : Seq.Set<T>
>T : T

      // Sequence algorithms
      concat<C>(...valuesOrCollections: Array<Iterable<C> | C>): Collection.Set<T | C>;
>concat : <C>(...valuesOrCollections: (C | Iterable<C>)[]) => Set<T | C>
>C : C
>valuesOrCollections : (C | Iterable<C>)[]
>Array : T[]
>Iterable : Iterable<T>
>C : C
>C : C
>Collection : 任意
>类型别名 :=> 任意
>Set : Set<T>
>T : T
>C : C

      map<M>(mapper: (value: T, key: never, iter: this) => M, context?: any): Collection.Set<M>;
>map : <M>(mapper: (value: T, key: 不及, iter: 本体) => M, context?: 任意) => Set<M>
>M : M
>mapper : (value: T, key: 不及, iter: 本体) => M
>value : T
>T : T
>key : 不及
>类型别名 :=> 不及
>iter : 本体
>M : M
>context : 任意
>类型别名 :=> 任意
>Collection : 任意
>类型别名 :=> 任意
>Set : Set<T>
>M : M

      flatMap<M>(mapper: (value: T, key: never, iter: this) => Iterable<M>, context?: any):  Collection.Set<M>;
>flatMap : <M>(mapper: (value: T, key: 不及, iter: 本体) => Iterable<M>, context?: 任意) => Set<M>
>M : M
>mapper : (value: T, key: 不及, iter: 本体) => Iterable<M>
>value : T
>T : T
>key : 不及
>类型别名 :=> 不及
>iter : 本体
>Iterable : Iterable<T>
>M : M
>context : 任意
>类型别名 :=> 任意
>Collection : 任意
>类型别名 :=> 任意
>Set : Set<T>
>M : M

      filter<F extends T>(predicate: (value: T, key: never, iter: this) => value is F, context?: any): Collection.Set<F>;
>filter : { <F 扩展 T>(predicate: (value: T, key: 不及, iter: 本体) => value 作为 F, context?: 任意): Set<F>; (predicate: (value: T, key: 不及, iter: 本体) => 任意, context?: 任意): 本体; }
>F : F
>T : T
>predicate : (value: T, key: 不及, iter: 本体) => value 作为 F
>value : T
>T : T
>key : 不及
>类型别名 :=> 不及
>iter : 本体
>value : 任意
>类型别名 :=> 任意
>F : F
>context : 任意
>类型别名 :=> 任意
>Collection : 任意
>类型别名 :=> 任意
>Set : Set<T>
>F : F

      filter(predicate: (value: T, key: never, iter: this) => any, context?: any): this;
>filter : { <F 扩展 T>(predicate: (value: T, key: 不及, iter: 本体) => value 作为 F, context?: 任意): Set<F>; (predicate: (value: T, key: 不及, iter: 本体) => 任意, context?: 任意): 本体; }
>predicate : (value: T, key: 不及, iter: 本体) => 任意
>value : T
>T : T
>key : 不及
>类型别名 :=> 不及
>iter : 本体
>context : 任意
>类型别名 :=> 任意

      [Symbol.iterator](): IterableIterator<T>;
>Symbol.iterator : 符号
>类型别名 :=> 符号
>Symbol : SymbolConstructor
>iterator : 符号
>类型别名 :=> 符号
>IterableIterator : IterableIterator<T>
>T : T
    }
  }
  export function Collection<I extends Collection<any, any>>(collection: I): I;
>Collection : 类为 Collection
>I : I
>Collection : Collection<K, V>
>collection : I
>I : I
>I : I

  export function Collection<T>(collection: Iterable<T>): Collection.Indexed<T>;
>Collection : 类为 Collection
>T : T
>collection : Iterable<T>
>Iterable : Iterable<T>
>T : T
>Collection : 任意
>类型别名 :=> 任意
>Indexed : Collection.Indexed<T>
>T : T

  export function Collection<V>(obj: {[key: string]: V}): Collection.Keyed<string, V>;
>Collection : 类为 Collection
>V : V
>obj : { [key: 文字]: V; }
>key : 文字
>类型别名 :=> 文字
>V : V
>Collection : 任意
>类型别名 :=> 任意
>Keyed : Collection.Keyed<K, V>
>V : V

  export interface Collection<K, V> extends ValueObject {
>Collection : Collection<K, V>
>K : K
>V : V
>ValueObject : ValueObject

    // Value equality
    equals(other: any): boolean;
>equals : (other: 任意) => 真假
>other : 任意
>类型别名 :=> 任意

    hashCode(): number;
>hashCode : () => 数字

    // Reading values
    get<NSV>(key: K, notSetValue: NSV): V | NSV;
>get : { <NSV>(key: K, notSetValue: NSV): V | NSV; (key: K): V; }
>NSV : NSV
>key : K
>K : K
>notSetValue : NSV
>NSV : NSV
>V : V
>NSV : NSV

    get(key: K): V | undefined;
>get : { <NSV>(key: K, notSetValue: NSV): V | NSV; (key: K): V; }
>key : K
>K : K
>V : V

    has(key: K): boolean;
>has : (key: K) => 真假
>key : K
>K : K

    includes(value: V): boolean;
>includes : (value: V) => 真假
>value : V
>V : V

    contains(value: V): boolean;
>contains : (value: V) => 真假
>value : V
>V : V

    first(): V | undefined;
>first : () => V
>V : V

    last(): V | undefined;
>last : () => V
>V : V

    // Reading deep values
    getIn(searchKeyPath: Iterable<any>, notSetValue?: any): any;
>getIn : (searchKeyPath: Iterable<任意>, notSetValue?: 任意) => 任意
>searchKeyPath : Iterable<任意>
>Iterable : Iterable<T>
>notSetValue : 任意
>类型别名 :=> 任意

    hasIn(searchKeyPath: Iterable<any>): boolean;
>hasIn : (searchKeyPath: Iterable<任意>) => 真假
>searchKeyPath : Iterable<任意>
>Iterable : Iterable<T>

    // Persistent changes
    update<R>(updater: (value: this) => R): R;
>update : <R>(updater: (value: 本体) => R) => R
>R : R
>updater : (value: 本体) => R
>value : 本体
>R : R
>R : R

    // Conversion to JavaScript types
    toJS(): Array<any> | { [key: string]: any };
>toJS : () => 任意[] | { [key: 文字]: 任意; }
>Array : T[]
>key : 文字
>类型别名 :=> 文字

    toJSON(): Array<V> | { [key: string]: V };
>toJSON : () => V[] | { [key: 文字]: V; }
>Array : T[]
>V : V
>key : 文字
>类型别名 :=> 文字
>V : V

    toArray(): Array<V>;
>toArray : () => V[]
>Array : T[]
>V : V

    toObject(): { [key: string]: V };
>toObject : () => { [key: 文字]: V; }
>key : 文字
>类型别名 :=> 文字
>V : V

    // Conversion to Collections
    toMap(): Map<K, V>;
>toMap : () => Map<K, V>
>Map : Map<K, V>
>K : K
>V : V

    toOrderedMap(): OrderedMap<K, V>;
>toOrderedMap : () => OrderedMap<K, V>
>OrderedMap : OrderedMap<K, V>
>K : K
>V : V

    toSet(): Set<V>;
>toSet : () => Set<V>
>Set : Set<T>
>V : V

    toOrderedSet(): OrderedSet<V>;
>toOrderedSet : () => OrderedSet<V>
>OrderedSet : OrderedSet<T>
>V : V

    toList(): List<V>;
>toList : () => List<V>
>List : List<T>
>V : V

    toStack(): Stack<V>;
>toStack : () => Stack<V>
>Stack : Stack<T>
>V : V

    // Conversion to Seq
    toSeq(): this;
>toSeq : () => 本体

    toKeyedSeq(): Seq.Keyed<K, V>;
>toKeyedSeq : () => Seq.Keyed<K, V>
>Seq : 任意
>类型别名 :=> 任意
>Keyed : Seq.Keyed<K, V>
>K : K
>V : V

    toIndexedSeq(): Seq.Indexed<V>;
>toIndexedSeq : () => Seq.Indexed<V>
>Seq : 任意
>类型别名 :=> 任意
>Indexed : Seq.Indexed<T>
>V : V

    toSetSeq(): Seq.Set<V>;
>toSetSeq : () => Seq.Set<V>
>Seq : 任意
>类型别名 :=> 任意
>Set : Seq.Set<T>
>V : V

    // Iterators
    keys(): IterableIterator<K>;
>keys : () => IterableIterator<K>
>IterableIterator : IterableIterator<T>
>K : K

    values(): IterableIterator<V>;
>values : () => IterableIterator<V>
>IterableIterator : IterableIterator<T>
>V : V

    entries(): IterableIterator<[K, V]>;
>entries : () => IterableIterator<[K, V]>
>IterableIterator : IterableIterator<T>
>K : K
>V : V

    // Collections (Seq)
    keySeq(): Seq.Indexed<K>;
>keySeq : () => Seq.Indexed<K>
>Seq : 任意
>类型别名 :=> 任意
>Indexed : Seq.Indexed<T>
>K : K

    valueSeq(): Seq.Indexed<V>;
>valueSeq : () => Seq.Indexed<V>
>Seq : 任意
>类型别名 :=> 任意
>Indexed : Seq.Indexed<T>
>V : V

    entrySeq(): Seq.Indexed<[K, V]>;
>entrySeq : () => Seq.Indexed<[K, V]>
>Seq : 任意
>类型别名 :=> 任意
>Indexed : Seq.Indexed<T>
>K : K
>V : V

    // Sequence algorithms
    map<M>(mapper: (value: V, key: K, iter: this) => M, context?: any): Collection<K, M>;
>map : <M>(mapper: (value: V, key: K, iter: 本体) => M, context?: 任意) => Collection<K, M>
>M : M
>mapper : (value: V, key: K, iter: 本体) => M
>value : V
>V : V
>key : K
>K : K
>iter : 本体
>M : M
>context : 任意
>类型别名 :=> 任意
>Collection : Collection<K, V>
>K : K
>M : M

    filter<F extends V>(predicate: (value: V, key: K, iter: this) => value is F, context?: any): Collection<K, F>;
>filter : { <F 扩展 V>(predicate: (value: V, key: K, iter: 本体) => value 作为 F, context?: 任意): Collection<K, F>; (predicate: (value: V, key: K, iter: 本体) => 任意, context?: 任意): 本体; }
>F : F
>V : V
>predicate : (value: V, key: K, iter: 本体) => value 作为 F
>value : V
>V : V
>key : K
>K : K
>iter : 本体
>value : 任意
>类型别名 :=> 任意
>F : F
>context : 任意
>类型别名 :=> 任意
>Collection : Collection<K, V>
>K : K
>F : F

    filter(predicate: (value: V, key: K, iter: this) => any, context?: any): this;
>filter : { <F 扩展 V>(predicate: (value: V, key: K, iter: 本体) => value 作为 F, context?: 任意): Collection<K, F>; (predicate: (value: V, key: K, iter: 本体) => 任意, context?: 任意): 本体; }
>predicate : (value: V, key: K, iter: 本体) => 任意
>value : V
>V : V
>key : K
>K : K
>iter : 本体
>context : 任意
>类型别名 :=> 任意

    filterNot(predicate: (value: V, key: K, iter: this) => boolean, context?: any): this;
>filterNot : (predicate: (value: V, key: K, iter: 本体) => 真假, context?: 任意) => 本体
>predicate : (value: V, key: K, iter: 本体) => 真假
>value : V
>V : V
>key : K
>K : K
>iter : 本体
>context : 任意
>类型别名 :=> 任意

    reverse(): this;
>reverse : () => 本体

    sort(comparator?: (valueA: V, valueB: V) => number): this;
>sort : (comparator?: (valueA: V, valueB: V) => 数字) => 本体
>comparator : (valueA: V, valueB: V) => 数字
>valueA : V
>V : V
>valueB : V
>V : V

    sortBy<C>(comparatorValueMapper: (value: V, key: K, iter: this) => C, comparator?: (valueA: C, valueB: C) => number): this;
>sortBy : <C>(comparatorValueMapper: (value: V, key: K, iter: 本体) => C, comparator?: (valueA: C, valueB: C) => 数字) => 本体
>C : C
>comparatorValueMapper : (value: V, key: K, iter: 本体) => C
>value : V
>V : V
>key : K
>K : K
>iter : 本体
>C : C
>comparator : (valueA: C, valueB: C) => 数字
>valueA : C
>C : C
>valueB : C
>C : C

    groupBy<G>(grouper: (value: V, key: K, iter: this) => G, context?: any): /*Map*/Seq.Keyed<G, /*this*/Collection<K, V>>;
>groupBy : <G>(grouper: (value: V, key: K, iter: 本体) => G, context?: 任意) => Seq.Keyed<G, Collection<K, V>>
>G : G
>grouper : (value: V, key: K, iter: 本体) => G
>value : V
>V : V
>key : K
>K : K
>iter : 本体
>G : G
>context : 任意
>类型别名 :=> 任意
>Seq : 任意
>类型别名 :=> 任意
>Keyed : Seq.Keyed<K, V>
>G : G
>Collection : Collection<K, V>
>K : K
>V : V

    // Side effects
    forEach(sideEffect: (value: V, key: K, iter: this) => any, context?: any): number;
>forEach : (sideEffect: (value: V, key: K, iter: 本体) => 任意, context?: 任意) => 数字
>sideEffect : (value: V, key: K, iter: 本体) => 任意
>value : V
>V : V
>key : K
>K : K
>iter : 本体
>context : 任意
>类型别名 :=> 任意

    // Creating subsets
    slice(begin?: number, end?: number): this;
>slice : (begin?: 数字, end?: 数字) => 本体
>begin : 数字
>类型别名 :=> 数字
>end : 数字
>类型别名 :=> 数字

    rest(): this;
>rest : () => 本体

    butLast(): this;
>butLast : () => 本体

    skip(amount: number): this;
>skip : (amount: 数字) => 本体
>amount : 数字
>类型别名 :=> 数字

    skipLast(amount: number): this;
>skipLast : (amount: 数字) => 本体
>amount : 数字
>类型别名 :=> 数字

    skipWhile(predicate: (value: V, key: K, iter: this) => boolean, context?: any): this;
>skipWhile : (predicate: (value: V, key: K, iter: 本体) => 真假, context?: 任意) => 本体
>predicate : (value: V, key: K, iter: 本体) => 真假
>value : V
>V : V
>key : K
>K : K
>iter : 本体
>context : 任意
>类型别名 :=> 任意

    skipUntil(predicate: (value: V, key: K, iter: this) => boolean, context?: any): this;
>skipUntil : (predicate: (value: V, key: K, iter: 本体) => 真假, context?: 任意) => 本体
>predicate : (value: V, key: K, iter: 本体) => 真假
>value : V
>V : V
>key : K
>K : K
>iter : 本体
>context : 任意
>类型别名 :=> 任意

    take(amount: number): this;
>take : (amount: 数字) => 本体
>amount : 数字
>类型别名 :=> 数字

    takeLast(amount: number): this;
>takeLast : (amount: 数字) => 本体
>amount : 数字
>类型别名 :=> 数字

    takeWhile(predicate: (value: V, key: K, iter: this) => boolean, context?: any): this;
>takeWhile : (predicate: (value: V, key: K, iter: 本体) => 真假, context?: 任意) => 本体
>predicate : (value: V, key: K, iter: 本体) => 真假
>value : V
>V : V
>key : K
>K : K
>iter : 本体
>context : 任意
>类型别名 :=> 任意

    takeUntil(predicate: (value: V, key: K, iter: this) => boolean, context?: any): this;
>takeUntil : (predicate: (value: V, key: K, iter: 本体) => 真假, context?: 任意) => 本体
>predicate : (value: V, key: K, iter: 本体) => 真假
>value : V
>V : V
>key : K
>K : K
>iter : 本体
>context : 任意
>类型别名 :=> 任意

    // Combination
    concat(...valuesOrCollections: Array<any>): Collection<any, any>;
>concat : (...valuesOrCollections: 任意[]) => Collection<任意, 任意>
>valuesOrCollections : 任意[]
>Array : T[]
>Collection : Collection<K, V>

    flatten(depth?: number): Collection<any, any>;
>flatten : { (depth?: 数字): Collection<任意, 任意>; (shallow?: 真假): Collection<任意, 任意>; }
>depth : 数字
>类型别名 :=> 数字
>Collection : Collection<K, V>

    flatten(shallow?: boolean): Collection<any, any>;
>flatten : { (depth?: 数字): Collection<任意, 任意>; (shallow?: 真假): Collection<任意, 任意>; }
>shallow : 真假
>类型别名 :=> 真假
>Collection : Collection<K, V>

    flatMap<M>(mapper: (value: V, key: K, iter: this) => Iterable<M>, context?: any): Collection<K, M>;
>flatMap : <M>(mapper: (value: V, key: K, iter: 本体) => Iterable<M>, context?: 任意) => Collection<K, M>
>M : M
>mapper : (value: V, key: K, iter: 本体) => Iterable<M>
>value : V
>V : V
>key : K
>K : K
>iter : 本体
>Iterable : Iterable<T>
>M : M
>context : 任意
>类型别名 :=> 任意
>Collection : Collection<K, V>
>K : K
>M : M

    // Reducing a value
    reduce<R>(reducer: (reduction: R, value: V, key: K, iter: this) => R, initialReduction: R, context?: any): R;
>reduce : { <R>(reducer: (reduction: R, value: V, key: K, iter: 本体) => R, initialReduction: R, context?: 任意): R; <R>(reducer: (reduction: V | R, value: V, key: K, iter: 本体) => R): R; }
>R : R
>reducer : (reduction: R, value: V, key: K, iter: 本体) => R
>reduction : R
>R : R
>value : V
>V : V
>key : K
>K : K
>iter : 本体
>R : R
>initialReduction : R
>R : R
>context : 任意
>类型别名 :=> 任意
>R : R

    reduce<R>(reducer: (reduction: V | R, value: V, key: K, iter: this) => R): R;
>reduce : { <R>(reducer: (reduction: R, value: V, key: K, iter: 本体) => R, initialReduction: R, context?: 任意): R; <R>(reducer: (reduction: V | R, value: V, key: K, iter: 本体) => R): R; }
>R : R
>reducer : (reduction: V | R, value: V, key: K, iter: 本体) => R
>reduction : V | R
>V : V
>R : R
>value : V
>V : V
>key : K
>K : K
>iter : 本体
>R : R
>R : R

    reduceRight<R>(reducer: (reduction: R, value: V, key: K, iter: this) => R, initialReduction: R, context?: any): R;
>reduceRight : { <R>(reducer: (reduction: R, value: V, key: K, iter: 本体) => R, initialReduction: R, context?: 任意): R; <R>(reducer: (reduction: V | R, value: V, key: K, iter: 本体) => R): R; }
>R : R
>reducer : (reduction: R, value: V, key: K, iter: 本体) => R
>reduction : R
>R : R
>value : V
>V : V
>key : K
>K : K
>iter : 本体
>R : R
>initialReduction : R
>R : R
>context : 任意
>类型别名 :=> 任意
>R : R

    reduceRight<R>(reducer: (reduction: V | R, value: V, key: K, iter: this) => R): R;
>reduceRight : { <R>(reducer: (reduction: R, value: V, key: K, iter: 本体) => R, initialReduction: R, context?: 任意): R; <R>(reducer: (reduction: V | R, value: V, key: K, iter: 本体) => R): R; }
>R : R
>reducer : (reduction: V | R, value: V, key: K, iter: 本体) => R
>reduction : V | R
>V : V
>R : R
>value : V
>V : V
>key : K
>K : K
>iter : 本体
>R : R
>R : R

    every(predicate: (value: V, key: K, iter: this) => boolean, context?: any): boolean;
>every : (predicate: (value: V, key: K, iter: 本体) => 真假, context?: 任意) => 真假
>predicate : (value: V, key: K, iter: 本体) => 真假
>value : V
>V : V
>key : K
>K : K
>iter : 本体
>context : 任意
>类型别名 :=> 任意

    some(predicate: (value: V, key: K, iter: this) => boolean, context?: any): boolean;
>some : (predicate: (value: V, key: K, iter: 本体) => 真假, context?: 任意) => 真假
>predicate : (value: V, key: K, iter: 本体) => 真假
>value : V
>V : V
>key : K
>K : K
>iter : 本体
>context : 任意
>类型别名 :=> 任意

    join(separator?: string): string;
>join : (separator?: 文字) => 文字
>separator : 文字
>类型别名 :=> 文字

    isEmpty(): boolean;
>isEmpty : () => 真假

    count(): number;
>count : { (): 数字; (predicate: (value: V, key: K, iter: 本体) => 真假, context?: 任意): 数字; }

    count(predicate: (value: V, key: K, iter: this) => boolean, context?: any): number;
>count : { (): 数字; (predicate: (value: V, key: K, iter: 本体) => 真假, context?: 任意): 数字; }
>predicate : (value: V, key: K, iter: 本体) => 真假
>value : V
>V : V
>key : K
>K : K
>iter : 本体
>context : 任意
>类型别名 :=> 任意

    countBy<G>(grouper: (value: V, key: K, iter: this) => G, context?: any): Map<G, number>;
>countBy : <G>(grouper: (value: V, key: K, iter: 本体) => G, context?: 任意) => Map<G, 数字>
>G : G
>grouper : (value: V, key: K, iter: 本体) => G
>value : V
>V : V
>key : K
>K : K
>iter : 本体
>G : G
>context : 任意
>类型别名 :=> 任意
>Map : Map<K, V>
>G : G

    // Search for value
    find(predicate: (value: V, key: K, iter: this) => boolean, context?: any, notSetValue?: V): V | undefined;
>find : (predicate: (value: V, key: K, iter: 本体) => 真假, context?: 任意, notSetValue?: V) => V
>predicate : (value: V, key: K, iter: 本体) => 真假
>value : V
>V : V
>key : K
>K : K
>iter : 本体
>context : 任意
>类型别名 :=> 任意
>notSetValue : V
>V : V
>V : V

    findLast(predicate: (value: V, key: K, iter: this) => boolean, context?: any, notSetValue?: V): V | undefined;
>findLast : (predicate: (value: V, key: K, iter: 本体) => 真假, context?: 任意, notSetValue?: V) => V
>predicate : (value: V, key: K, iter: 本体) => 真假
>value : V
>V : V
>key : K
>K : K
>iter : 本体
>context : 任意
>类型别名 :=> 任意
>notSetValue : V
>V : V
>V : V

    findEntry(predicate: (value: V, key: K, iter: this) => boolean, context?: any, notSetValue?: V): [K, V] | undefined;
>findEntry : (predicate: (value: V, key: K, iter: 本体) => 真假, context?: 任意, notSetValue?: V) => [K, V]
>predicate : (value: V, key: K, iter: 本体) => 真假
>value : V
>V : V
>key : K
>K : K
>iter : 本体
>context : 任意
>类型别名 :=> 任意
>notSetValue : V
>V : V
>K : K
>V : V

    findLastEntry(predicate: (value: V, key: K, iter: this) => boolean, context?: any, notSetValue?: V): [K, V] | undefined;
>findLastEntry : (predicate: (value: V, key: K, iter: 本体) => 真假, context?: 任意, notSetValue?: V) => [K, V]
>predicate : (value: V, key: K, iter: 本体) => 真假
>value : V
>V : V
>key : K
>K : K
>iter : 本体
>context : 任意
>类型别名 :=> 任意
>notSetValue : V
>V : V
>K : K
>V : V

    findKey(predicate: (value: V, key: K, iter: this) => boolean, context?: any): K | undefined;
>findKey : (predicate: (value: V, key: K, iter: 本体) => 真假, context?: 任意) => K
>predicate : (value: V, key: K, iter: 本体) => 真假
>value : V
>V : V
>key : K
>K : K
>iter : 本体
>context : 任意
>类型别名 :=> 任意
>K : K

    findLastKey(predicate: (value: V, key: K, iter: this) => boolean, context?: any): K | undefined;
>findLastKey : (predicate: (value: V, key: K, iter: 本体) => 真假, context?: 任意) => K
>predicate : (value: V, key: K, iter: 本体) => 真假
>value : V
>V : V
>key : K
>K : K
>iter : 本体
>context : 任意
>类型别名 :=> 任意
>K : K

    keyOf(searchValue: V): K | undefined;
>keyOf : (searchValue: V) => K
>searchValue : V
>V : V
>K : K

    lastKeyOf(searchValue: V): K | undefined;
>lastKeyOf : (searchValue: V) => K
>searchValue : V
>V : V
>K : K

    max(comparator?: (valueA: V, valueB: V) => number): V | undefined;
>max : (comparator?: (valueA: V, valueB: V) => 数字) => V
>comparator : (valueA: V, valueB: V) => 数字
>valueA : V
>V : V
>valueB : V
>V : V
>V : V

    maxBy<C>(comparatorValueMapper: (value: V, key: K, iter: this) => C, comparator?: (valueA: C, valueB: C) => number): V | undefined;
>maxBy : <C>(comparatorValueMapper: (value: V, key: K, iter: 本体) => C, comparator?: (valueA: C, valueB: C) => 数字) => V
>C : C
>comparatorValueMapper : (value: V, key: K, iter: 本体) => C
>value : V
>V : V
>key : K
>K : K
>iter : 本体
>C : C
>comparator : (valueA: C, valueB: C) => 数字
>valueA : C
>C : C
>valueB : C
>C : C
>V : V

    min(comparator?: (valueA: V, valueB: V) => number): V | undefined;
>min : (comparator?: (valueA: V, valueB: V) => 数字) => V
>comparator : (valueA: V, valueB: V) => 数字
>valueA : V
>V : V
>valueB : V
>V : V
>V : V

    minBy<C>(comparatorValueMapper: (value: V, key: K, iter: this) => C, comparator?: (valueA: C, valueB: C) => number): V | undefined;
>minBy : <C>(comparatorValueMapper: (value: V, key: K, iter: 本体) => C, comparator?: (valueA: C, valueB: C) => 数字) => V
>C : C
>comparatorValueMapper : (value: V, key: K, iter: 本体) => C
>value : V
>V : V
>key : K
>K : K
>iter : 本体
>C : C
>comparator : (valueA: C, valueB: C) => 数字
>valueA : C
>C : C
>valueB : C
>C : C
>V : V

    // Comparison
    isSubset(iter: Iterable<V>): boolean;
>isSubset : (iter: Iterable<V>) => 真假
>iter : Iterable<V>
>Iterable : Iterable<T>
>V : V

    isSuperset(iter: Iterable<V>): boolean;
>isSuperset : (iter: Iterable<V>) => 真假
>iter : Iterable<V>
>Iterable : Iterable<T>
>V : V

    readonly size: number;
>size : 数字
>类型别名 :=> 数字
  }
}
declare module "immutable" {
  export = Immutable
>Immutable : 类为 Immutable
}

