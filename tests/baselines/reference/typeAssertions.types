=== tests/cases/conformance/expressions/typeAssertions/typeAssertions.ts ===
// Function call whose argument is a 1 arg generic function call with explicit type arguments
function fn1<T>(t: T) { }
>fn1 : <T>(t: T) => void
>T : T
>t : T
>T : T

function fn2(t: any) { }
>fn2 : (t: any) => void
>t : any
>类型别名 :=> 任意

fn1(fn2<string>(4)); // Error
>fn1(fn2<string>(4)) : void
>类型别名 :=> 无值
>fn1 : <T>(t: T) => void
>fn2<string>(4) : void
>类型别名 :=> 无值
>fn2 : (t: any) => void
>4 : 4

var a: any;
>a : any
>类型别名 :=> 任意

var s: string;
>s : string
>类型别名 :=> 文字

// Type assertion of non - unary expression
var a = <any>"" + 4;
>a : any
>类型别名 :=> 任意
><any>"" + 4 : any
>类型别名 :=> 任意
><any>"" : any
>类型别名 :=> 任意
>"" : ""
>4 : 4

var s = "" + <any>4;
>s : string
>类型别名 :=> 文字
>"" + <any>4 : string
>类型别名 :=> 文字
>"" : ""
><any>4 : any
>类型别名 :=> 任意
>4 : 4

class SomeBase {
>SomeBase : SomeBase

    private p;
>p : any
>类型别名 :=> 任意
}
class SomeDerived extends SomeBase {
>SomeDerived : SomeDerived
>SomeBase : SomeBase

    private x;
>x : any
>类型别名 :=> 任意
}
class SomeOther {
>SomeOther : SomeOther

    private q;
>q : any
>类型别名 :=> 任意
}

// Type assertion should check for assignability in either direction
var someBase = new SomeBase();
>someBase : SomeBase
>new SomeBase() : SomeBase
>SomeBase : typeof SomeBase

var someDerived = new SomeDerived();
>someDerived : SomeDerived
>new SomeDerived() : SomeDerived
>SomeDerived : typeof SomeDerived

var someOther = new SomeOther();
>someOther : SomeOther
>new SomeOther() : SomeOther
>SomeOther : typeof SomeOther

someBase = <SomeBase>someDerived;
>someBase = <SomeBase>someDerived : SomeBase
>someBase : SomeBase
><SomeBase>someDerived : SomeBase
>SomeBase : SomeBase
>someDerived : SomeDerived

someBase = <SomeBase>someBase;
>someBase = <SomeBase>someBase : SomeBase
>someBase : SomeBase
><SomeBase>someBase : SomeBase
>SomeBase : SomeBase
>someBase : SomeBase

someBase = <SomeBase>someOther; // Error
>someBase = <SomeBase>someOther : SomeBase
>someBase : SomeBase
><SomeBase>someOther : SomeBase
>SomeBase : SomeBase
>someOther : SomeOther

someDerived = <SomeDerived>someDerived;
>someDerived = <SomeDerived>someDerived : SomeDerived
>someDerived : SomeDerived
><SomeDerived>someDerived : SomeDerived
>SomeDerived : SomeDerived
>someDerived : SomeDerived

someDerived = <SomeDerived>someBase;
>someDerived = <SomeDerived>someBase : SomeDerived
>someDerived : SomeDerived
><SomeDerived>someBase : SomeDerived
>SomeDerived : SomeDerived
>someBase : SomeBase

someDerived = <SomeDerived>someOther; // Error
>someDerived = <SomeDerived>someOther : SomeDerived
>someDerived : SomeDerived
><SomeDerived>someOther : SomeDerived
>SomeDerived : SomeDerived
>someOther : SomeOther

someOther = <SomeOther>someDerived; // Error
>someOther = <SomeOther>someDerived : SomeOther
>someOther : SomeOther
><SomeOther>someDerived : SomeOther
>SomeOther : SomeOther
>someDerived : SomeDerived

someOther = <SomeOther>someBase; // Error
>someOther = <SomeOther>someBase : SomeOther
>someOther : SomeOther
><SomeOther>someBase : SomeOther
>SomeOther : SomeOther
>someBase : SomeBase

someOther = <SomeOther>someOther;
>someOther = <SomeOther>someOther : SomeOther
>someOther : SomeOther
><SomeOther>someOther : SomeOther
>SomeOther : SomeOther
>someOther : SomeOther

// Type assertion cannot be a type-predicate type
var numOrStr: number | string;
>numOrStr : string | number

var str: string;
>str : string
>类型别名 :=> 文字

if(<numOrStr is string>(numOrStr === undefined)) { // Error
><numOrStr is : any
>类型别名 :=> 任意
>numOrStr : No type information available!
>is : any
>类型别名 :=> 任意
>string>(numOrStr === undefined) : boolean
>类型别名 :=> 真假
>string : any
>类型别名 :=> 任意
>(numOrStr === undefined) : boolean
>类型别名 :=> 真假
>numOrStr === undefined : boolean
>类型别名 :=> 真假
>numOrStr : string | number
>undefined : undefined
>类型别名 :=> 未定

	str = numOrStr; // Error, no narrowing occurred
>str = numOrStr : string | number
>str : string
>类型别名 :=> 文字
>numOrStr : string | number
}

if((numOrStr === undefined) as numOrStr is string) { // Error
>(numOrStr === undefined) as numOrStr : any
>类型别名 :=> 任意
>(numOrStr === undefined) : boolean
>类型别名 :=> 真假
>numOrStr === undefined : boolean
>类型别名 :=> 真假
>numOrStr : string | number
>undefined : undefined
>类型别名 :=> 未定
>numOrStr : No type information available!
>is : any
>类型别名 :=> 任意
>string : any
>类型别名 :=> 任意
}


