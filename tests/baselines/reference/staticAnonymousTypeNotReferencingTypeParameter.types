=== tests/cases/compiler/staticAnonymousTypeNotReferencingTypeParameter.ts ===
// This test case is a condensed version of Angular 2's ListWrapper. Prior to #7448
// this would cause the compiler to run out of memory.

function outer<T>(x: T) {
>outer : <T>(x: T) => typeof Inner
>T : T
>x : T
>T : T

  class Inner {
>Inner : Inner

    static y: T = x;
>y : T
>T : T
>x : T
  }
  return Inner;
>Inner : typeof Inner
}
let y: number = outer(5).y;
>y : number
>类型别名 :=> 数字
>outer(5).y : number
>类型别名 :=> 数字
>outer(5) : typeof Inner
>outer : <T>(x: T) => typeof Inner
>5 : 5
>y : number
>类型别名 :=> 数字

class ListWrapper2 {
>ListWrapper2 : ListWrapper2

  static clone<T>(dit: typeof ListWrapper2, array: T[]): T[] { return array.slice(0); }
>clone : <T>(dit: typeof ListWrapper2, array: T[]) => T[]
>T : T
>dit : typeof ListWrapper2
>ListWrapper2 : typeof ListWrapper2
>array : T[]
>T : T
>T : T
>array.slice(0) : T[]
>array.slice : (start?: number, end?: number) => T[]
>array : T[]
>slice : (start?: number, end?: number) => T[]
>0 : 0

  static reversed<T>(dit: typeof ListWrapper2, array: T[]): T[] {
>reversed : <T>(dit: typeof ListWrapper2, array: T[]) => T[]
>T : T
>dit : typeof ListWrapper2
>ListWrapper2 : typeof ListWrapper2
>array : T[]
>T : T
>T : T

    var a = ListWrapper2.clone(dit, array);
>a : T[]
>ListWrapper2.clone(dit, array) : T[]
>ListWrapper2.clone : <T>(dit: typeof ListWrapper2, array: T[]) => T[]
>ListWrapper2 : typeof ListWrapper2
>clone : <T>(dit: typeof ListWrapper2, array: T[]) => T[]
>dit : typeof ListWrapper2
>array : T[]

    return a;
>a : T[]
  }
}
namespace tessst {
>tessst : typeof tessst

    /**
     * Iterates through 'array' by index and performs the callback on each element of array until the callback
     * returns a truthy value, then returns that value.
     * If no such value is found, the callback is applied to each element of array and undefined is returned.
     */
    export function funkyFor<T, U>(array: T[], callback: (element: T, index: number) => U): U {
>funkyFor : <T, U>(array: T[], callback: (element: T, index: number) => U) => U
>T : T
>U : U
>array : T[]
>T : T
>callback : (element: T, index: number) => U
>element : T
>T : T
>index : number
>类型别名 :=> 数字
>U : U
>U : U

        if (array) {
>array : T[]

            for (let i = 0, len = array.length; i < len; i++) {
>i : number
>类型别名 :=> 数字
>0 : 0
>len : number
>类型别名 :=> 数字
>array.length : number
>类型别名 :=> 数字
>array : T[]
>length : number
>类型别名 :=> 数字
>i < len : boolean
>类型别名 :=> 真假
>i : number
>类型别名 :=> 数字
>len : number
>类型别名 :=> 数字
>i++ : number
>类型别名 :=> 数字
>i : number
>类型别名 :=> 数字

                const result = callback(array[i], i);
>result : U
>callback(array[i], i) : U
>callback : (element: T, index: number) => U
>array[i] : T
>array : T[]
>i : number
>类型别名 :=> 数字
>i : number
>类型别名 :=> 数字

                if (result) {
>result : U

                    return result;
>result : U
                }
            }
        }
        return undefined;
>undefined : undefined
>类型别名 :=> 未定
    }
}
interface Scanner {
>Scanner : Scanner

  scanRange<T>(start: number, length: number, callback: () => T): T;
>scanRange : <T>(start: number, length: number, callback: () => T) => T
>T : T
>start : number
>类型别名 :=> 数字
>length : number
>类型别名 :=> 数字
>callback : () => T
>T : T
>T : T
}
class ListWrapper {
>ListWrapper : ListWrapper

  // JS has no way to express a statically fixed size list, but dart does so we
  // keep both methods.
  static createFixedSize(dit: typeof ListWrapper, size: number): any[] { return new Array(size); }
>createFixedSize : (dit: typeof ListWrapper, size: number) => any[]
>dit : typeof ListWrapper
>ListWrapper : typeof ListWrapper
>size : number
>类型别名 :=> 数字
>new Array(size) : any[]
>Array : ArrayConstructor
>size : number
>类型别名 :=> 数字

  static createGrowableSize(dit: typeof ListWrapper, size: number): any[] { return new Array(size); }
>createGrowableSize : (dit: typeof ListWrapper, size: number) => any[]
>dit : typeof ListWrapper
>ListWrapper : typeof ListWrapper
>size : number
>类型别名 :=> 数字
>new Array(size) : any[]
>Array : ArrayConstructor
>size : number
>类型别名 :=> 数字

  static clone<T>(dit: typeof ListWrapper, array: T[]): T[] { return array.slice(0); }
>clone : <T>(dit: typeof ListWrapper, array: T[]) => T[]
>T : T
>dit : typeof ListWrapper
>ListWrapper : typeof ListWrapper
>array : T[]
>T : T
>T : T
>array.slice(0) : T[]
>array.slice : (start?: number, end?: number) => T[]
>array : T[]
>slice : (start?: number, end?: number) => T[]
>0 : 0

  static forEachWithIndex<T>(dit: typeof ListWrapper, array: T[], fn: (t: T, n: number) => void) {
>forEachWithIndex : <T>(dit: typeof ListWrapper, array: T[], fn: (t: T, n: number) => void) => void
>T : T
>dit : typeof ListWrapper
>ListWrapper : typeof ListWrapper
>array : T[]
>T : T
>fn : (t: T, n: number) => void
>t : T
>T : T
>n : number
>类型别名 :=> 数字

    for (var i = 0; i < array.length; i++) {
>i : number
>类型别名 :=> 数字
>0 : 0
>i < array.length : boolean
>类型别名 :=> 真假
>i : number
>类型别名 :=> 数字
>array.length : number
>类型别名 :=> 数字
>array : T[]
>length : number
>类型别名 :=> 数字
>i++ : number
>类型别名 :=> 数字
>i : number
>类型别名 :=> 数字

      fn(array[i], i);
>fn(array[i], i) : void
>类型别名 :=> 无值
>fn : (t: T, n: number) => void
>array[i] : T
>array : T[]
>i : number
>类型别名 :=> 数字
>i : number
>类型别名 :=> 数字
    }
  }
  static first<T>(dit: typeof ListWrapper, array: T[]): T {
>first : <T>(dit: typeof ListWrapper, array: T[]) => T
>T : T
>dit : typeof ListWrapper
>ListWrapper : typeof ListWrapper
>array : T[]
>T : T
>T : T

    if (!array) return null;
>!array : boolean
>类型别名 :=> 真假
>array : T[]
>null : null
>类型别名 :=> 空值

    return array[0];
>array[0] : T
>array : T[]
>0 : 0
  }
  static last<T>(dit: typeof ListWrapper, array: T[]): T {
>last : <T>(dit: typeof ListWrapper, array: T[]) => T
>T : T
>dit : typeof ListWrapper
>ListWrapper : typeof ListWrapper
>array : T[]
>T : T
>T : T

    if (!array || array.length == 0) return null;
>!array || array.length == 0 : boolean
>类型别名 :=> 真假
>!array : boolean
>类型别名 :=> 真假
>array : T[]
>array.length == 0 : boolean
>类型别名 :=> 真假
>array.length : number
>类型别名 :=> 数字
>array : T[]
>length : number
>类型别名 :=> 数字
>0 : 0
>null : null
>类型别名 :=> 空值

    return array[array.length - 1];
>array[array.length - 1] : T
>array : T[]
>array.length - 1 : number
>类型别名 :=> 数字
>array.length : number
>类型别名 :=> 数字
>array : T[]
>length : number
>类型别名 :=> 数字
>1 : 1
  }
  static indexOf<T>(dit: typeof ListWrapper, array: T[], value: T, startIndex: number = 0): number {
>indexOf : <T>(dit: typeof ListWrapper, array: T[], value: T, startIndex?: number) => number
>T : T
>dit : typeof ListWrapper
>ListWrapper : typeof ListWrapper
>array : T[]
>T : T
>value : T
>T : T
>startIndex : number
>类型别名 :=> 数字
>0 : 0

    return array.indexOf(value, startIndex);
>array.indexOf(value, startIndex) : number
>类型别名 :=> 数字
>array.indexOf : (searchElement: T, fromIndex?: number) => number
>array : T[]
>indexOf : (searchElement: T, fromIndex?: number) => number
>value : T
>startIndex : number
>类型别名 :=> 数字
  }
  static contains<T>(dit: typeof ListWrapper, list: T[], el: T): boolean { return list.indexOf(el) !== -1; }
>contains : <T>(dit: typeof ListWrapper, list: T[], el: T) => boolean
>T : T
>dit : typeof ListWrapper
>ListWrapper : typeof ListWrapper
>list : T[]
>T : T
>el : T
>T : T
>list.indexOf(el) !== -1 : boolean
>类型别名 :=> 真假
>list.indexOf(el) : number
>类型别名 :=> 数字
>list.indexOf : (searchElement: T, fromIndex?: number) => number
>list : T[]
>indexOf : (searchElement: T, fromIndex?: number) => number
>el : T
>-1 : -1
>1 : 1

  static reversed<T>(dit: typeof ListWrapper, array: T[]): T[] {
>reversed : <T>(dit: typeof ListWrapper, array: T[]) => T[]
>T : T
>dit : typeof ListWrapper
>ListWrapper : typeof ListWrapper
>array : T[]
>T : T
>T : T

    var a = ListWrapper.clone(dit, array);
>a : T[]
>ListWrapper.clone(dit, array) : T[]
>ListWrapper.clone : <T>(dit: typeof ListWrapper, array: T[]) => T[]
>ListWrapper : typeof ListWrapper
>clone : <T>(dit: typeof ListWrapper, array: T[]) => T[]
>dit : typeof ListWrapper
>array : T[]

    let scanner: Scanner;
>scanner : Scanner
>Scanner : Scanner

    scanner.scanRange(3, 5, () => {  });
>scanner.scanRange(3, 5, () => {  }) : void
>类型别名 :=> 无值
>scanner.scanRange : <T>(start: number, length: number, callback: () => T) => T
>scanner : Scanner
>scanRange : <T>(start: number, length: number, callback: () => T) => T
>3 : 3
>5 : 5
>() => {  } : () => void

    return tessst.funkyFor(array, t => t.toString()) ? a.reverse() : a;
>tessst.funkyFor(array, t => t.toString()) ? a.reverse() : a : T[]
>tessst.funkyFor(array, t => t.toString()) : string
>类型别名 :=> 文字
>tessst.funkyFor : <T, U>(array: T[], callback: (element: T, index: number) => U) => U
>tessst : typeof tessst
>funkyFor : <T, U>(array: T[], callback: (element: T, index: number) => U) => U
>array : T[]
>t => t.toString() : (t: T) => string
>t : T
>t.toString() : string
>类型别名 :=> 文字
>t.toString : () => string
>t : T
>toString : () => string
>a.reverse() : T[]
>a.reverse : () => T[]
>a : T[]
>reverse : () => T[]
>a : T[]
  }
  static concat(dit: typeof ListWrapper, a: any[], b: any[]): any[] { return a.concat(b); }
>concat : (dit: typeof ListWrapper, a: any[], b: any[]) => any[]
>dit : typeof ListWrapper
>ListWrapper : typeof ListWrapper
>a : any[]
>b : any[]
>a.concat(b) : any[]
>a.concat : { (...items: ReadonlyArray<any>[]): any[]; (...items: any[]): any[]; }
>a : any[]
>concat : { (...items: ReadonlyArray<any>[]): any[]; (...items: any[]): any[]; }
>b : any[]

  static insert<T>(dit: typeof ListWrapper, list: T[], index: number, value: T) { list.splice(index, 0, value); }
>insert : <T>(dit: typeof ListWrapper, list: T[], index: number, value: T) => void
>T : T
>dit : typeof ListWrapper
>ListWrapper : typeof ListWrapper
>list : T[]
>T : T
>index : number
>类型别名 :=> 数字
>value : T
>T : T
>list.splice(index, 0, value) : T[]
>list.splice : { (start: number, deleteCount?: number): T[]; (start: number, deleteCount: number, ...items: T[]): T[]; }
>list : T[]
>splice : { (start: number, deleteCount?: number): T[]; (start: number, deleteCount: number, ...items: T[]): T[]; }
>index : number
>类型别名 :=> 数字
>0 : 0
>value : T

  static removeAt<T>(dit: typeof ListWrapper, list: T[], index: number): T {
>removeAt : <T>(dit: typeof ListWrapper, list: T[], index: number) => T
>T : T
>dit : typeof ListWrapper
>ListWrapper : typeof ListWrapper
>list : T[]
>T : T
>index : number
>类型别名 :=> 数字
>T : T

    var res = list[index];
>res : T
>list[index] : T
>list : T[]
>index : number
>类型别名 :=> 数字

    list.splice(index, 1);
>list.splice(index, 1) : T[]
>list.splice : { (start: number, deleteCount?: number): T[]; (start: number, deleteCount: number, ...items: T[]): T[]; }
>list : T[]
>splice : { (start: number, deleteCount?: number): T[]; (start: number, deleteCount: number, ...items: T[]): T[]; }
>index : number
>类型别名 :=> 数字
>1 : 1

    return res;
>res : T
  }
  static removeAll<T>(dit: typeof ListWrapper, list: T[], items: T[]) {
>removeAll : <T>(dit: typeof ListWrapper, list: T[], items: T[]) => void
>T : T
>dit : typeof ListWrapper
>ListWrapper : typeof ListWrapper
>list : T[]
>T : T
>items : T[]
>T : T

    for (var i = 0; i < items.length; ++i) {
>i : number
>类型别名 :=> 数字
>0 : 0
>i < items.length : boolean
>类型别名 :=> 真假
>i : number
>类型别名 :=> 数字
>items.length : number
>类型别名 :=> 数字
>items : T[]
>length : number
>类型别名 :=> 数字
>++i : number
>类型别名 :=> 数字
>i : number
>类型别名 :=> 数字

      var index = list.indexOf(items[i]);
>index : number
>类型别名 :=> 数字
>list.indexOf(items[i]) : number
>类型别名 :=> 数字
>list.indexOf : (searchElement: T, fromIndex?: number) => number
>list : T[]
>indexOf : (searchElement: T, fromIndex?: number) => number
>items[i] : T
>items : T[]
>i : number
>类型别名 :=> 数字

      list.splice(index, 1);
>list.splice(index, 1) : T[]
>list.splice : { (start: number, deleteCount?: number): T[]; (start: number, deleteCount: number, ...items: T[]): T[]; }
>list : T[]
>splice : { (start: number, deleteCount?: number): T[]; (start: number, deleteCount: number, ...items: T[]): T[]; }
>index : number
>类型别名 :=> 数字
>1 : 1
    }
  }
  static remove<T>(dit: typeof ListWrapper, list: T[], el: T): boolean {
>remove : <T>(dit: typeof ListWrapper, list: T[], el: T) => boolean
>T : T
>dit : typeof ListWrapper
>ListWrapper : typeof ListWrapper
>list : T[]
>T : T
>el : T
>T : T

    var index = list.indexOf(el);
>index : number
>类型别名 :=> 数字
>list.indexOf(el) : number
>类型别名 :=> 数字
>list.indexOf : (searchElement: T, fromIndex?: number) => number
>list : T[]
>indexOf : (searchElement: T, fromIndex?: number) => number
>el : T

    if (index > -1) {
>index > -1 : boolean
>类型别名 :=> 真假
>index : number
>类型别名 :=> 数字
>-1 : -1
>1 : 1

      list.splice(index, 1);
>list.splice(index, 1) : T[]
>list.splice : { (start: number, deleteCount?: number): T[]; (start: number, deleteCount: number, ...items: T[]): T[]; }
>list : T[]
>splice : { (start: number, deleteCount?: number): T[]; (start: number, deleteCount: number, ...items: T[]): T[]; }
>index : number
>类型别名 :=> 数字
>1 : 1

      return true;
>true : true
>类型别名 :=> 为真
    }
    return false;
>false : false
>类型别名 :=> 为假
  }
  static clear(dit: typeof ListWrapper, list: any[]) { list.length = 0; }
>clear : (dit: typeof ListWrapper, list: any[]) => void
>dit : typeof ListWrapper
>ListWrapper : typeof ListWrapper
>list : any[]
>list.length = 0 : 0
>list.length : number
>类型别名 :=> 数字
>list : any[]
>length : number
>类型别名 :=> 数字
>0 : 0

  static isEmpty(dit: typeof ListWrapper, list: any[]): boolean { return list.length == 0; }
>isEmpty : (dit: typeof ListWrapper, list: any[]) => boolean
>dit : typeof ListWrapper
>ListWrapper : typeof ListWrapper
>list : any[]
>list.length == 0 : boolean
>类型别名 :=> 真假
>list.length : number
>类型别名 :=> 数字
>list : any[]
>length : number
>类型别名 :=> 数字
>0 : 0

  static fill(dit: typeof ListWrapper, list: any[], value: any, start: number = 0, end: number = null) {
>fill : (dit: typeof ListWrapper, list: any[], value: any, start?: number, end?: number) => void
>dit : typeof ListWrapper
>ListWrapper : typeof ListWrapper
>list : any[]
>value : any
>类型别名 :=> 任意
>start : number
>类型别名 :=> 数字
>0 : 0
>end : number
>类型别名 :=> 数字
>null : null
>类型别名 :=> 空值

    list.fill(value, start, end === null ? list.length : end);
>list.fill(value, start, end === null ? list.length : end) : void
>类型别名 :=> 无值
>list.fill : (value: any, start: number, end: number) => void
>list : any[]
>fill : (value: any, start: number, end: number) => void
>value : any
>类型别名 :=> 任意
>start : number
>类型别名 :=> 数字
>end === null ? list.length : end : number
>类型别名 :=> 数字
>end === null : boolean
>类型别名 :=> 真假
>end : number
>类型别名 :=> 数字
>null : null
>类型别名 :=> 空值
>list.length : number
>类型别名 :=> 数字
>list : any[]
>length : number
>类型别名 :=> 数字
>end : number
>类型别名 :=> 数字
  }
  static equals(dit: typeof ListWrapper, a: any[], b: any[]): boolean {
>equals : (dit: typeof ListWrapper, a: any[], b: any[]) => boolean
>dit : typeof ListWrapper
>ListWrapper : typeof ListWrapper
>a : any[]
>b : any[]

    if (a.length != b.length) return false;
>a.length != b.length : boolean
>类型别名 :=> 真假
>a.length : number
>类型别名 :=> 数字
>a : any[]
>length : number
>类型别名 :=> 数字
>b.length : number
>类型别名 :=> 数字
>b : any[]
>length : number
>类型别名 :=> 数字
>false : false
>类型别名 :=> 为假

    for (var i = 0; i < a.length; ++i) {
>i : number
>类型别名 :=> 数字
>0 : 0
>i < a.length : boolean
>类型别名 :=> 真假
>i : number
>类型别名 :=> 数字
>a.length : number
>类型别名 :=> 数字
>a : any[]
>length : number
>类型别名 :=> 数字
>++i : number
>类型别名 :=> 数字
>i : number
>类型别名 :=> 数字

      if (a[i] !== b[i]) return false;
>a[i] !== b[i] : boolean
>类型别名 :=> 真假
>a[i] : any
>类型别名 :=> 任意
>a : any[]
>i : number
>类型别名 :=> 数字
>b[i] : any
>类型别名 :=> 任意
>b : any[]
>i : number
>类型别名 :=> 数字
>false : false
>类型别名 :=> 为假
    }
    return true;
>true : true
>类型别名 :=> 为真
  }
  static slice<T>(dit: typeof ListWrapper, l: T[], from: number = 0, to: number = null): T[] {
>slice : <T>(dit: typeof ListWrapper, l: T[], from?: number, to?: number) => T[]
>T : T
>dit : typeof ListWrapper
>ListWrapper : typeof ListWrapper
>l : T[]
>T : T
>from : number
>类型别名 :=> 数字
>0 : 0
>to : number
>类型别名 :=> 数字
>null : null
>类型别名 :=> 空值
>T : T

    return l.slice(from, to === null ? undefined : to);
>l.slice(from, to === null ? undefined : to) : T[]
>l.slice : (start?: number, end?: number) => T[]
>l : T[]
>slice : (start?: number, end?: number) => T[]
>from : number
>类型别名 :=> 数字
>to === null ? undefined : to : number
>类型别名 :=> 数字
>to === null : boolean
>类型别名 :=> 真假
>to : number
>类型别名 :=> 数字
>null : null
>类型别名 :=> 空值
>undefined : undefined
>类型别名 :=> 未定
>to : number
>类型别名 :=> 数字
  }
  static splice<T>(dit: typeof ListWrapper, l: T[], from: number, length: number): T[] { return l.splice(from, length); }
>splice : <T>(dit: typeof ListWrapper, l: T[], from: number, length: number) => T[]
>T : T
>dit : typeof ListWrapper
>ListWrapper : typeof ListWrapper
>l : T[]
>T : T
>from : number
>类型别名 :=> 数字
>length : number
>类型别名 :=> 数字
>T : T
>l.splice(from, length) : T[]
>l.splice : { (start: number, deleteCount?: number): T[]; (start: number, deleteCount: number, ...items: T[]): T[]; }
>l : T[]
>splice : { (start: number, deleteCount?: number): T[]; (start: number, deleteCount: number, ...items: T[]): T[]; }
>from : number
>类型别名 :=> 数字
>length : number
>类型别名 :=> 数字

  static sort<T>(dit: typeof ListWrapper, l: T[], compareFn?: (a: T, b: T) => number) {
>sort : <T>(dit: typeof ListWrapper, l: T[], compareFn?: (a: T, b: T) => number) => void
>T : T
>dit : typeof ListWrapper
>ListWrapper : typeof ListWrapper
>l : T[]
>T : T
>compareFn : (a: T, b: T) => number
>a : T
>T : T
>b : T
>T : T

    if (isPresent(compareFn)) {
>isPresent(compareFn) : boolean
>类型别名 :=> 真假
>isPresent : <T>(compareFn?: (a: T, b: T) => number) => boolean
>compareFn : (a: T, b: T) => number

      l.sort(compareFn);
>l.sort(compareFn) : T[]
>l.sort : (compareFn?: (a: T, b: T) => number) => T[]
>l : T[]
>sort : (compareFn?: (a: T, b: T) => number) => T[]
>compareFn : (a: T, b: T) => number

    } else {
      l.sort();
>l.sort() : T[]
>l.sort : (compareFn?: (a: T, b: T) => number) => T[]
>l : T[]
>sort : (compareFn?: (a: T, b: T) => number) => T[]
    }
  }
  static toString<T>(dit: typeof ListWrapper, l: T[]): string { return l.toString(); }
>toString : <T>(dit: typeof ListWrapper, l: T[]) => string
>T : T
>dit : typeof ListWrapper
>ListWrapper : typeof ListWrapper
>l : T[]
>T : T
>l.toString() : string
>类型别名 :=> 文字
>l.toString : () => string
>l : T[]
>toString : () => string

  static toJSON<T>(dit: typeof ListWrapper, l: T[]): string { return JSON.stringify(l); }
>toJSON : <T>(dit: typeof ListWrapper, l: T[]) => string
>T : T
>dit : typeof ListWrapper
>ListWrapper : typeof ListWrapper
>l : T[]
>T : T
>JSON.stringify(l) : string
>类型别名 :=> 文字
>JSON.stringify : { (value: any, replacer?: (key: string, value: any) => any, space?: string | number): string; (value: any, replacer?: (string | number)[], space?: string | number): string; }
>JSON : JSON
>stringify : { (value: any, replacer?: (key: string, value: any) => any, space?: string | number): string; (value: any, replacer?: (string | number)[], space?: string | number): string; }
>l : T[]

  static maximum<T>(dit: typeof ListWrapper, list: T[], predicate: (t: T) => number): T {
>maximum : <T>(dit: typeof ListWrapper, list: T[], predicate: (t: T) => number) => T
>T : T
>dit : typeof ListWrapper
>ListWrapper : typeof ListWrapper
>list : T[]
>T : T
>predicate : (t: T) => number
>t : T
>T : T
>T : T

    if (list.length == 0) {
>list.length == 0 : boolean
>类型别名 :=> 真假
>list.length : number
>类型别名 :=> 数字
>list : T[]
>length : number
>类型别名 :=> 数字
>0 : 0

      return null;
>null : null
>类型别名 :=> 空值
    }
    var solution: T = null;
>solution : T
>T : T
>null : null
>类型别名 :=> 空值

    var maxValue = -Infinity;
>maxValue : number
>类型别名 :=> 数字
>-Infinity : number
>类型别名 :=> 数字
>Infinity : number
>类型别名 :=> 数字

    for (var index = 0; index < list.length; index++) {
>index : number
>类型别名 :=> 数字
>0 : 0
>index < list.length : boolean
>类型别名 :=> 真假
>index : number
>类型别名 :=> 数字
>list.length : number
>类型别名 :=> 数字
>list : T[]
>length : number
>类型别名 :=> 数字
>index++ : number
>类型别名 :=> 数字
>index : number
>类型别名 :=> 数字

      var candidate = list[index];
>candidate : T
>list[index] : T
>list : T[]
>index : number
>类型别名 :=> 数字

      if (isBlank(candidate)) {
>isBlank(candidate) : boolean
>类型别名 :=> 真假
>isBlank : (x: any) => boolean
>candidate : T

        continue;
      }
      var candidateValue = predicate(candidate);
>candidateValue : number
>类型别名 :=> 数字
>predicate(candidate) : number
>类型别名 :=> 数字
>predicate : (t: T) => number
>candidate : T

      if (candidateValue > maxValue) {
>candidateValue > maxValue : boolean
>类型别名 :=> 真假
>candidateValue : number
>类型别名 :=> 数字
>maxValue : number
>类型别名 :=> 数字

        solution = candidate;
>solution = candidate : T
>solution : T
>candidate : T

        maxValue = candidateValue;
>maxValue = candidateValue : number
>类型别名 :=> 数字
>maxValue : number
>类型别名 :=> 数字
>candidateValue : number
>类型别名 :=> 数字
      }
    }
    return solution;
>solution : T
  }
}
let cloned = ListWrapper.clone(ListWrapper, [1,2,3,4]);
>cloned : number[]
>ListWrapper.clone(ListWrapper, [1,2,3,4]) : number[]
>ListWrapper.clone : <T>(dit: typeof ListWrapper, array: T[]) => T[]
>ListWrapper : typeof ListWrapper
>clone : <T>(dit: typeof ListWrapper, array: T[]) => T[]
>ListWrapper : typeof ListWrapper
>[1,2,3,4] : number[]
>1 : 1
>2 : 2
>3 : 3
>4 : 4

declare function isBlank(x: any): boolean;
>isBlank : (x: any) => boolean
>x : any
>类型别名 :=> 任意

declare function isPresent<T>(compareFn?: (a: T, b: T) => number): boolean;
>isPresent : <T>(compareFn?: (a: T, b: T) => number) => boolean
>T : T
>compareFn : (a: T, b: T) => number
>a : T
>T : T
>b : T
>T : T

interface Array<T> {
>Array : T[]
>T : T

	fill(value: any, start: number, end: number): void;
>fill : (value: any, start: number, end: number) => void
>value : any
>类型别名 :=> 任意
>start : number
>类型别名 :=> 数字
>end : number
>类型别名 :=> 数字
}
