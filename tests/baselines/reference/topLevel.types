=== tests/cases/compiler/topLevel.ts ===
interface IPoint {
>IPoint : IPoint

    x:number;
>x : number
>类型别名 :=> 数字

    y:number;
>y : number
>类型别名 :=> 数字
}

class Point implements IPoint {
>Point : Point
>IPoint : IPoint

    constructor(public x,public y){}
>x : any
>类型别名 :=> 任意
>y : any
>类型别名 :=> 任意

    public move(xo:number,yo:number) {
>move : (xo: number, yo: number) => this
>xo : number
>类型别名 :=> 数字
>yo : number
>类型别名 :=> 数字

	this.x+=xo;
>this.x+=xo : any
>类型别名 :=> 任意
>this.x : any
>类型别名 :=> 任意
>this : this
>x : any
>类型别名 :=> 任意
>xo : number
>类型别名 :=> 数字

	this.y+=yo;
>this.y+=yo : any
>类型别名 :=> 任意
>this.y : any
>类型别名 :=> 任意
>this : this
>y : any
>类型别名 :=> 任意
>yo : number
>类型别名 :=> 数字

	return this;
>this : this
    }
    public toString() {
>toString : () => string

	return ("("+this.x+","+this.y+")");
>("("+this.x+","+this.y+")") : string
>类型别名 :=> 文字
>"("+this.x+","+this.y+")" : string
>类型别名 :=> 文字
>"("+this.x+","+this.y : string
>类型别名 :=> 文字
>"("+this.x+"," : string
>类型别名 :=> 文字
>"("+this.x : string
>类型别名 :=> 文字
>"(" : "("
>this.x : any
>类型别名 :=> 任意
>this : this
>x : any
>类型别名 :=> 任意
>"," : ","
>this.y : any
>类型别名 :=> 任意
>this : this
>y : any
>类型别名 :=> 任意
>")" : ")"
    }
}

var result="";
>result : string
>类型别名 :=> 文字
>"" : ""

result+=(new Point(3,4).move(2,2));
>result+=(new Point(3,4).move(2,2)) : string
>类型别名 :=> 文字
>result : string
>类型别名 :=> 文字
>(new Point(3,4).move(2,2)) : Point
>new Point(3,4).move(2,2) : Point
>new Point(3,4).move : (xo: number, yo: number) => Point
>new Point(3,4) : Point
>Point : typeof Point
>3 : 3
>4 : 4
>move : (xo: number, yo: number) => Point
>2 : 2
>2 : 2

module M {
>M : typeof M

    export var origin=new Point(0,0);
>origin : Point
>new Point(0,0) : Point
>Point : typeof Point
>0 : 0
>0 : 0
}

result+=(M.origin.move(1,1));
>result+=(M.origin.move(1,1)) : string
>类型别名 :=> 文字
>result : string
>类型别名 :=> 文字
>(M.origin.move(1,1)) : Point
>M.origin.move(1,1) : Point
>M.origin.move : (xo: number, yo: number) => Point
>M.origin : Point
>M : typeof M
>origin : Point
>move : (xo: number, yo: number) => Point
>1 : 1
>1 : 1


