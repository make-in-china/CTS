=== tests/cases/compiler/mixingApparentTypeOverrides.ts ===
type Constructor<T> = new(...args: any[]) => T;
>Constructor : Constructor<T>
>T : T
>args : any[]
>T : T

function Tagged<T extends Constructor<{}>>(Base: T) {
>Tagged : <T extends Constructor<{}>>(Base: T) => { new (...args: any[]): (Anonymous class); prototype: Tagged<any>.(Anonymous class); } & T
>T : T
>Constructor : Constructor<T>
>Base : T
>T : T

  return class extends Base {
>class extends Base {    _tag: string;    constructor(...args: any[]) {      super(...args);      this._tag = "";    }  } : { new (...args: any[]): (Anonymous class); prototype: Tagged<any>.(Anonymous class); } & T
>Base : {}

    _tag: string;
>_tag : string
>类型别名 :=> 文字

    constructor(...args: any[]) {
>args : any[]

      super(...args);
>super(...args) : void
>类型别名 :=> 无值
>super : T
>...args : any
>类型别名 :=> 任意
>args : any[]

      this._tag = "";
>this._tag = "" : ""
>this._tag : string
>类型别名 :=> 文字
>this : this
>_tag : string
>类型别名 :=> 文字
>"" : ""
    }
  };
}

class A {
>A : A

  toString () {
>toString : () => string

    return "class A";
>"class A" : "class A"
  }
}

class B extends Tagged(A) {
>B : B
>Tagged(A) : Tagged<typeof A>.(Anonymous class) & A
>Tagged : <T extends Constructor<{}>>(Base: T) => { new (...args: any[]): (Anonymous class); prototype: Tagged<any>.(Anonymous class); } & T
>A : typeof A

  toString () { // Should not be an error
>toString : () => string

    return "class B";
>"class B" : "class B"
  }
}

class C extends A {
>C : C
>A : A

  toString () { // Should not be an error
>toString : () => string

    return "class C";
>"class C" : "class C"
  }
}
