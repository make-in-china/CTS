=== tests/cases/conformance/types/typeParameters/typeParameterLists/propertyAccessOnTypeParameterWithConstraints5.ts ===
class A {
>A : A

    foo(): string { return ''; }
>foo : () => string
>'' : ""
}

class B extends A {
>B : B
>A : A

    bar(): string {
>bar : () => string

        return '';
>'' : ""
    }
}

class C<U extends T, T extends A> {
>C : C<U, T>
>U : U
>T : T
>T : T
>A : A

    f() {
>f : () => string

        var x: U;
>x : U
>U : U

        var a = x['foo'](); // should be string
>a : string
>类型别名 :=> 文字
>x['foo']() : string
>类型别名 :=> 文字
>x['foo'] : () => string
>x : U
>'foo' : "foo"

        return a + x.foo() + x.notHere();
>a + x.foo() + x.notHere() : string
>类型别名 :=> 文字
>a + x.foo() : string
>类型别名 :=> 文字
>a : string
>类型别名 :=> 文字
>x.foo() : string
>类型别名 :=> 文字
>x.foo : () => string
>x : U
>foo : () => string
>x.notHere() : any
>类型别名 :=> 任意
>x.notHere : any
>类型别名 :=> 任意
>x : U
>notHere : any
>类型别名 :=> 任意
    }
}

var r = (new C<B, A>()).f();
>r : string
>类型别名 :=> 文字
>(new C<B, A>()).f() : string
>类型别名 :=> 文字
>(new C<B, A>()).f : () => string
>(new C<B, A>()) : C<B, A>
>new C<B, A>() : C<B, A>
>C : typeof C
>B : B
>A : A
>f : () => string

interface I<U extends T, T extends A> {
>I : I<U, T>
>U : U
>T : T
>T : T
>A : A

    foo: U;
>foo : U
>U : U
}
var i: I<B, A>;
>i : I<B, A>
>I : I<U, T>
>B : B
>A : A

var r2 = i.foo.notHere();
>r2 : any
>类型别名 :=> 任意
>i.foo.notHere() : any
>类型别名 :=> 任意
>i.foo.notHere : any
>类型别名 :=> 任意
>i.foo : B
>i : I<B, A>
>foo : B
>notHere : any
>类型别名 :=> 任意

var r2b = i.foo['foo']();
>r2b : string
>类型别名 :=> 文字
>i.foo['foo']() : string
>类型别名 :=> 文字
>i.foo['foo'] : () => string
>i.foo : B
>i : I<B, A>
>foo : B
>'foo' : "foo"

var a: {
>a : <U extends T, T extends A>() => U

    <U extends T, T extends A>(): U;
>U : U
>T : T
>T : T
>A : A
>U : U
}
// BUG 794164
var r3: string = a().notHere();
>r3 : string
>类型别名 :=> 文字
>a().notHere() : any
>类型别名 :=> 任意
>a().notHere : any
>类型别名 :=> 任意
>a() : A
>a : <U extends T, T extends A>() => U
>notHere : any
>类型别名 :=> 任意

var r3b: string = a()['foo']();
>r3b : string
>类型别名 :=> 文字
>a()['foo']() : string
>类型别名 :=> 文字
>a()['foo'] : () => string
>a() : A
>a : <U extends T, T extends A>() => U
>'foo' : "foo"

var b = {
>b : any
>类型别名 :=> 任意
>{    foo: <U extends T, T extends A>(x: U): U => {        var a = x['foo'](); // should be string        return a + x.notHere();    },    // BUG 794164    bar: b.foo(1).notHere()} : { foo: <U extends T, T extends A>(x: U) => U; bar: any; }

    foo: <U extends T, T extends A>(x: U): U => {
>foo : <U extends T, T extends A>(x: U) => U
><U extends T, T extends A>(x: U): U => {        var a = x['foo'](); // should be string        return a + x.notHere();    } : <U extends T, T extends A>(x: U) => U
>U : U
>T : T
>T : T
>A : A
>x : U
>U : U
>U : U

        var a = x['foo'](); // should be string
>a : string
>类型别名 :=> 文字
>x['foo']() : string
>类型别名 :=> 文字
>x['foo'] : () => string
>x : U
>'foo' : "foo"

        return a + x.notHere();
>a + x.notHere() : string
>类型别名 :=> 文字
>a : string
>类型别名 :=> 文字
>x.notHere() : any
>类型别名 :=> 任意
>x.notHere : any
>类型别名 :=> 任意
>x : U
>notHere : any
>类型别名 :=> 任意

    },
    // BUG 794164
    bar: b.foo(1).notHere()
>bar : any
>类型别名 :=> 任意
>b.foo(1).notHere() : any
>类型别名 :=> 任意
>b.foo(1).notHere : any
>类型别名 :=> 任意
>b.foo(1) : any
>类型别名 :=> 任意
>b.foo : any
>类型别名 :=> 任意
>b : any
>类型别名 :=> 任意
>foo : any
>类型别名 :=> 任意
>1 : 1
>notHere : any
>类型别名 :=> 任意
}

var r4 = b.foo(new B()); // error after constraints above made illegal, doesn't matter
>r4 : any
>类型别名 :=> 任意
>b.foo(new B()) : any
>类型别名 :=> 任意
>b.foo : any
>类型别名 :=> 任意
>b : any
>类型别名 :=> 任意
>foo : any
>类型别名 :=> 任意
>new B() : B
>B : typeof B

