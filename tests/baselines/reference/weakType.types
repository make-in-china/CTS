=== tests/cases/compiler/weakType.ts ===
interface Settings {
>Settings : Settings

    timeout?: number;
>timeout : number
>类型别名 :=> 数字

    onError?(): void;
>onError : () => void
}

function getDefaultSettings() {
>getDefaultSettings : () => { timeout: number; }

    return { timeout: 1000 };
>{ timeout: 1000 } : { timeout: number; }
>timeout : number
>类型别名 :=> 数字
>1000 : 1000
}
interface CtorOnly {
>CtorOnly : CtorOnly

    new(s: string): { timeout: 1000 }
>s : string
>类型别名 :=> 文字
>timeout : 1000
}

function doSomething(settings: Settings) { /* ... */ }
>doSomething : (settings: Settings) => void
>settings : Settings
>Settings : Settings

// forgot to call `getDefaultSettings`
doSomething(getDefaultSettings);
>doSomething(getDefaultSettings) : void
>类型别名 :=> 无值
>doSomething : (settings: Settings) => void
>getDefaultSettings : () => { timeout: number; }

doSomething(() => ({ timeout: 1000 }));
>doSomething(() => ({ timeout: 1000 })) : void
>类型别名 :=> 无值
>doSomething : (settings: Settings) => void
>() => ({ timeout: 1000 }) : () => { timeout: number; }
>({ timeout: 1000 }) : { timeout: number; }
>{ timeout: 1000 } : { timeout: number; }
>timeout : number
>类型别名 :=> 数字
>1000 : 1000

doSomething(null as CtorOnly);
>doSomething(null as CtorOnly) : void
>类型别名 :=> 无值
>doSomething : (settings: Settings) => void
>null as CtorOnly : CtorOnly
>null : null
>类型别名 :=> 空值
>CtorOnly : CtorOnly

doSomething(12);
>doSomething(12) : void
>类型别名 :=> 无值
>doSomething : (settings: Settings) => void
>12 : 12

doSomething('completely wrong');
>doSomething('completely wrong') : void
>类型别名 :=> 无值
>doSomething : (settings: Settings) => void
>'completely wrong' : "completely wrong"

doSomething(false);
>doSomething(false) : void
>类型别名 :=> 无值
>doSomething : (settings: Settings) => void
>false : false
>类型别名 :=> 为假

// this is an oddly popular way of defining settings
// this example is from services/textChanges.ts
type ConfigurableStart = { useStart?: boolean }
>ConfigurableStart : ConfigurableStart
>useStart : boolean
>类型别名 :=> 真假

type ConfigurableEnd = { useEnd?: boolean }
>ConfigurableEnd : ConfigurableEnd
>useEnd : boolean
>类型别名 :=> 真假

type ConfigurableStartEnd = ConfigurableStart & ConfigurableEnd
>ConfigurableStartEnd : ConfigurableStartEnd
>ConfigurableStart : ConfigurableStart
>ConfigurableEnd : ConfigurableEnd

interface InsertOptions {
>InsertOptions : InsertOptions

    prefix?: string
>prefix : string
>类型别名 :=> 文字

    suffix?: string
>suffix : string
>类型别名 :=> 文字
}
type ChangeOptions = ConfigurableStartEnd & InsertOptions;
>ChangeOptions : ChangeOptions
>ConfigurableStartEnd : ConfigurableStartEnd
>InsertOptions : InsertOptions

function del(options: ConfigurableStartEnd = {},
>del : (options?: ConfigurableStartEnd, error?: { error?: number; }) => void
>options : ConfigurableStartEnd
>ConfigurableStartEnd : ConfigurableStartEnd
>{} : {}

             error: { error?: number } = {}) {
>error : { error?: number; }
>error : number
>类型别名 :=> 数字
>{} : {}

    let changes: ChangeOptions[];
>changes : ChangeOptions[]
>ChangeOptions : ChangeOptions

    changes.push(options);
>changes.push(options) : number
>类型别名 :=> 数字
>changes.push : (...items: ChangeOptions[]) => number
>changes : ChangeOptions[]
>push : (...items: ChangeOptions[]) => number
>options : ConfigurableStartEnd

    changes.push(error);
>changes.push(error) : number
>类型别名 :=> 数字
>changes.push : (...items: ChangeOptions[]) => number
>changes : ChangeOptions[]
>push : (...items: ChangeOptions[]) => number
>error : { error?: number; }
}

class K {
>K : K

    constructor(s: string) { }
>s : string
>类型别名 :=> 文字
}
// Ctor isn't a weak type because it has a construct signature
interface Ctor {
>Ctor : Ctor

    new (s: string): K
>s : string
>类型别名 :=> 文字
>K : K

    n?: number
>n : number
>类型别名 :=> 数字
}
let ctor: Ctor = K
>ctor : Ctor
>Ctor : Ctor
>K : typeof K

type Spoiler = { nope?: string }
>Spoiler : Spoiler
>nope : string
>类型别名 :=> 文字

type Weak = {
>Weak : Weak

    a?: number
>a : number
>类型别名 :=> 数字

    properties?: {
>properties : { b?: number; }

        b?: number
>b : number
>类型别名 :=> 数字
    }
}
declare let unknown: {
>unknown : { properties: { wrong: string; }; }

    properties: {
>properties : { wrong: string; }

        wrong: string
>wrong : string
>类型别名 :=> 文字
    }
}
let weak: Weak & Spoiler = unknown
>weak : Weak & Spoiler
>Weak : Weak
>Spoiler : Spoiler
>unknown : { properties: { wrong: string; }; }


