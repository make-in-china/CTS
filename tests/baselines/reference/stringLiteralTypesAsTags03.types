=== tests/cases/conformance/types/stringLiteral/stringLiteralTypesAsTags03.ts ===
type Kind = "A" | "B"
>Kind : Kind

interface Entity {
>Entity : Entity

    kind: Kind;
>kind : Kind
>Kind : Kind
}

interface A extends Entity {
>A : A
>Entity : Entity

    kind: "A";
>kind : "A"

    a: number;
>a : number
>类型别名 :=> 数字
}

interface B extends Entity {
>B : B
>Entity : Entity

    kind: "B";
>kind : "B"

    b: string;
>b : string
>类型别名 :=> 文字
}

// Currently (2015-12-14), we write '"A" | "A"' and '"B" | "B"' to avoid
// interpreting respective overloads as "specialized" signatures.
// That way, we can avoid the need to look for a compatible overload
// signature and simply check compatibility with the implementation.
function hasKind(entity: Entity, kind: "A" | "A"): entity is A;
>hasKind : { (entity: Entity, kind: "A"): entity is A; (entity: Entity, kind: "B"): entity is B; }
>entity : Entity
>Entity : Entity
>kind : "A"
>entity : any
>类型别名 :=> 任意
>A : A

function hasKind(entity: Entity, kind: "B" | "B"): entity is B;
>hasKind : { (entity: Entity, kind: "A"): entity is A; (entity: Entity, kind: "B"): entity is B; }
>entity : Entity
>Entity : Entity
>kind : "B"
>entity : any
>类型别名 :=> 任意
>B : B

function hasKind(entity: Entity, kind: Kind): entity is Entity {
>hasKind : { (entity: Entity, kind: "A"): entity is A; (entity: Entity, kind: "B"): entity is B; }
>entity : Entity
>Entity : Entity
>kind : Kind
>Kind : Kind
>entity : any
>类型别名 :=> 任意
>Entity : Entity

    return entity.kind === kind;
>entity.kind === kind : boolean
>类型别名 :=> 真假
>entity.kind : Kind
>entity : Entity
>kind : Kind
>kind : Kind
}

let x: A = {
>x : A
>A : A
>{    kind: "A",    a: 100,} : { kind: "A"; a: number; }

    kind: "A",
>kind : string
>类型别名 :=> 文字
>"A" : "A"

    a: 100,
>a : number
>类型别名 :=> 数字
>100 : 100
}

if (hasKind(x, "A")) {
>hasKind(x, "A") : boolean
>类型别名 :=> 真假
>hasKind : { (entity: Entity, kind: "A"): entity is A; (entity: Entity, kind: "B"): entity is B; }
>x : A
>"A" : "A"

    let a = x;
>a : A
>x : A
}
else {
    let b = x;
>b : never
>类型别名 :=> 不及
>x : never
>类型别名 :=> 不及
}

if (!hasKind(x, "B")) {
>!hasKind(x, "B") : boolean
>类型别名 :=> 真假
>hasKind(x, "B") : boolean
>类型别名 :=> 真假
>hasKind : { (entity: Entity, kind: "A"): entity is A; (entity: Entity, kind: "B"): entity is B; }
>x : A
>"B" : "B"

    let c = x;
>c : A
>x : A
}
else {
    let d = x;
>d : A & B
>x : A & B
}
