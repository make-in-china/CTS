=== tests/cases/compiler/fallbackToBindingPatternForTypeInference.ts ===
declare function trans<T>(f: (x: T) => string): number;
>trans : <T>(f: (x: T) => string) => number
>T : T
>f : (x: T) => string
>x : T
>T : T

trans(({a}) => a);
>trans(({a}) => a) : number
>类型别名 :=> 数字
>trans : <T>(f: (x: T) => string) => number
>({a}) => a : ({ a }: { a: any; }) => any
>a : any
>类型别名 :=> 任意
>a : any
>类型别名 :=> 任意

trans(([b,c]) => 'foo');
>trans(([b,c]) => 'foo') : number
>类型别名 :=> 数字
>trans : <T>(f: (x: T) => string) => number
>([b,c]) => 'foo' : ([b, c]: [any, any]) => string
>b : any
>类型别名 :=> 任意
>c : any
>类型别名 :=> 任意
>'foo' : "foo"

trans(({d: [e,f]}) => 'foo');
>trans(({d: [e,f]}) => 'foo') : number
>类型别名 :=> 数字
>trans : <T>(f: (x: T) => string) => number
>({d: [e,f]}) => 'foo' : ({ d: [e, f] }: { d: [any, any]; }) => string
>d : any
>类型别名 :=> 任意
>e : any
>类型别名 :=> 任意
>f : any
>类型别名 :=> 任意
>'foo' : "foo"

trans(([{g},{h}]) => 'foo');
>trans(([{g},{h}]) => 'foo') : number
>类型别名 :=> 数字
>trans : <T>(f: (x: T) => string) => number
>([{g},{h}]) => 'foo' : ([{ g }, { h }]: [{ g: any; }, { h: any; }]) => string
>g : any
>类型别名 :=> 任意
>h : any
>类型别名 :=> 任意
>'foo' : "foo"

trans(({a, b = 10}) => a);
>trans(({a, b = 10}) => a) : number
>类型别名 :=> 数字
>trans : <T>(f: (x: T) => string) => number
>({a, b = 10}) => a : ({ a, b }: { a: any; b?: number; }) => any
>a : any
>类型别名 :=> 任意
>b : number
>类型别名 :=> 数字
>10 : 10
>a : any
>类型别名 :=> 任意

