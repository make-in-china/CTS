=== tests/cases/conformance/dynamicImport/0.ts ===
export class B {
>B : B

    print() { return "I am B"}
>print : () => string
>"I am B" : "I am B"
}

=== tests/cases/conformance/dynamicImport/2.ts ===
// We use Promise<any> for now as there is no way to specify shape of module object
function foo(x: Promise<any>) {
>foo : (x: Promise<any>) => void
>x : Promise<any>
>Promise : Promise<T>

    x.then(value => {
>x.then(value => {        let b = new value.B();        b.print();    }) : Promise<void>
>x.then : <TResult1 = any, TResult2 = never>(onfulfilled?: (value: any) => TResult1 | PromiseLike<TResult1>, onrejected?: (reason: any) => TResult2 | PromiseLike<TResult2>) => Promise<TResult1 | TResult2>
>x : Promise<any>
>then : <TResult1 = any, TResult2 = never>(onfulfilled?: (value: any) => TResult1 | PromiseLike<TResult1>, onrejected?: (reason: any) => TResult2 | PromiseLike<TResult2>) => Promise<TResult1 | TResult2>
>value => {        let b = new value.B();        b.print();    } : (value: any) => void
>value : any
>类型别名 :=> 任意

        let b = new value.B();
>b : any
>类型别名 :=> 任意
>new value.B() : any
>类型别名 :=> 任意
>value.B : any
>类型别名 :=> 任意
>value : any
>类型别名 :=> 任意
>B : any
>类型别名 :=> 任意

        b.print();
>b.print() : any
>类型别名 :=> 任意
>b.print : any
>类型别名 :=> 任意
>b : any
>类型别名 :=> 任意
>print : any
>类型别名 :=> 任意

    })
}

foo(import("./0"));
>foo(import("./0")) : void
>类型别名 :=> 无值
>foo : (x: Promise<any>) => void
>import("./0") : Promise<typeof "tests/cases/conformance/dynamicImport/0" & { default: typeof "tests/cases/conformance/dynamicImport/0"; }>
>"./0" : "./0"

