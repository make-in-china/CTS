=== tests/cases/compiler/controlFlowPropertyDeclarations.ts ===
// Repro from ##8913

declare var require:any;
>require : any
>类型别名 :=> 任意

var HTMLDOMPropertyConfig = require('react/lib/HTMLDOMPropertyConfig');
>HTMLDOMPropertyConfig : any
>类型别名 :=> 任意
>require('react/lib/HTMLDOMPropertyConfig') : any
>类型别名 :=> 任意
>require : any
>类型别名 :=> 任意
>'react/lib/HTMLDOMPropertyConfig' : "react/lib/HTMLDOMPropertyConfig"

// Populate property map with ReactJS's attribute and property mappings
// TODO handle/use .Properties value eg: MUST_USE_PROPERTY is not HTML attr
for (var propname in HTMLDOMPropertyConfig.Properties) {
>propname : string
>类型别名 :=> 文字
>HTMLDOMPropertyConfig.Properties : any
>类型别名 :=> 任意
>HTMLDOMPropertyConfig : any
>类型别名 :=> 任意
>Properties : any
>类型别名 :=> 任意

  if (!HTMLDOMPropertyConfig.Properties.hasOwnProperty(propname)) {
>!HTMLDOMPropertyConfig.Properties.hasOwnProperty(propname) : boolean
>类型别名 :=> 真假
>HTMLDOMPropertyConfig.Properties.hasOwnProperty(propname) : any
>类型别名 :=> 任意
>HTMLDOMPropertyConfig.Properties.hasOwnProperty : any
>类型别名 :=> 任意
>HTMLDOMPropertyConfig.Properties : any
>类型别名 :=> 任意
>HTMLDOMPropertyConfig : any
>类型别名 :=> 任意
>Properties : any
>类型别名 :=> 任意
>hasOwnProperty : any
>类型别名 :=> 任意
>propname : string
>类型别名 :=> 文字

    continue;
  }

  var mapFrom = HTMLDOMPropertyConfig.DOMAttributeNames[propname] || propname.toLowerCase();
>mapFrom : any
>类型别名 :=> 任意
>HTMLDOMPropertyConfig.DOMAttributeNames[propname] || propname.toLowerCase() : any
>类型别名 :=> 任意
>HTMLDOMPropertyConfig.DOMAttributeNames[propname] : any
>类型别名 :=> 任意
>HTMLDOMPropertyConfig.DOMAttributeNames : any
>类型别名 :=> 任意
>HTMLDOMPropertyConfig : any
>类型别名 :=> 任意
>DOMAttributeNames : any
>类型别名 :=> 任意
>propname : string
>类型别名 :=> 文字
>propname.toLowerCase() : string
>类型别名 :=> 文字
>propname.toLowerCase : () => string
>propname : string
>类型别名 :=> 文字
>toLowerCase : () => string
}

/**
 * Repeats a string a certain number of times.
 * Also: the future is bright and consists of native string repetition:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat
 *
 * @param {string} string  String to repeat
 * @param {number} times   Number of times to repeat string. Integer.
 * @see http://jsperf.com/string-repeater/2
 */
function repeatString(string, times) {
>repeatString : (string: any, times: any) => any
>string : any
>类型别名 :=> 任意
>times : any
>类型别名 :=> 任意

  if (times === 1) {
>times === 1 : boolean
>类型别名 :=> 真假
>times : any
>类型别名 :=> 任意
>1 : 1

    return string;
>string : any
>类型别名 :=> 任意
  }
  if (times < 0) { throw new Error(); }
>times < 0 : boolean
>类型别名 :=> 真假
>times : any
>类型别名 :=> 任意
>0 : 0
>new Error() : Error
>Error : ErrorConstructor

  var repeated = '';
>repeated : string
>类型别名 :=> 文字
>'' : ""

  while (times) {
>times : any
>类型别名 :=> 任意

    if (times & 1) {
>times & 1 : number
>类型别名 :=> 数字
>times : any
>类型别名 :=> 任意
>1 : 1

      repeated += string;
>repeated += string : string
>类型别名 :=> 文字
>repeated : string
>类型别名 :=> 文字
>string : any
>类型别名 :=> 任意
    }
    if (times >>= 1) {
>times >>= 1 : number
>类型别名 :=> 数字
>times : any
>类型别名 :=> 任意
>1 : 1

      string += string;
>string += string : any
>类型别名 :=> 任意
>string : any
>类型别名 :=> 任意
>string : any
>类型别名 :=> 任意
    }
  }
  return repeated;
>repeated : string
>类型别名 :=> 文字
}

/**
 * Determine if the string ends with the specified substring.
 *
 * @param {string} haystack String to search in
 * @param {string} needle   String to search for
 * @return {boolean}
 */
function endsWith(haystack, needle) {
>endsWith : (haystack: any, needle: any) => boolean
>haystack : any
>类型别名 :=> 任意
>needle : any
>类型别名 :=> 任意

  return haystack.slice(-needle.length) === needle;
>haystack.slice(-needle.length) === needle : boolean
>类型别名 :=> 真假
>haystack.slice(-needle.length) : any
>类型别名 :=> 任意
>haystack.slice : any
>类型别名 :=> 任意
>haystack : any
>类型别名 :=> 任意
>slice : any
>类型别名 :=> 任意
>-needle.length : number
>类型别名 :=> 数字
>needle.length : any
>类型别名 :=> 任意
>needle : any
>类型别名 :=> 任意
>length : any
>类型别名 :=> 任意
>needle : any
>类型别名 :=> 任意
}

/**
 * Trim the specified substring off the string. If the string does not end
 * with the specified substring, this is a no-op.
 *
 * @param {string} haystack String to search in
 * @param {string} needle   String to search for
 * @return {string}
 */
function trimEnd(haystack, needle) {
>trimEnd : (haystack: any, needle: any) => any
>haystack : any
>类型别名 :=> 任意
>needle : any
>类型别名 :=> 任意

  return endsWith(haystack, needle)
>endsWith(haystack, needle)    ? haystack.slice(0, -needle.length)    : haystack : any
>类型别名 :=> 任意
>endsWith(haystack, needle) : boolean
>类型别名 :=> 真假
>endsWith : (haystack: any, needle: any) => boolean
>haystack : any
>类型别名 :=> 任意
>needle : any
>类型别名 :=> 任意

    ? haystack.slice(0, -needle.length)
>haystack.slice(0, -needle.length) : any
>类型别名 :=> 任意
>haystack.slice : any
>类型别名 :=> 任意
>haystack : any
>类型别名 :=> 任意
>slice : any
>类型别名 :=> 任意
>0 : 0
>-needle.length : number
>类型别名 :=> 数字
>needle.length : any
>类型别名 :=> 任意
>needle : any
>类型别名 :=> 任意
>length : any
>类型别名 :=> 任意

    : haystack;
>haystack : any
>类型别名 :=> 任意
}

/**
 * Convert a hyphenated string to camelCase.
 */
function hyphenToCamelCase(string) {
>hyphenToCamelCase : (string: any) => any
>string : any
>类型别名 :=> 任意

  return string.replace(/-(.)/g, function(match, chr) {
>string.replace(/-(.)/g, function(match, chr) {    return chr.toUpperCase();  }) : any
>类型别名 :=> 任意
>string.replace : any
>类型别名 :=> 任意
>string : any
>类型别名 :=> 任意
>replace : any
>类型别名 :=> 任意
>/-(.)/g : RegExp
>function(match, chr) {    return chr.toUpperCase();  } : (match: any, chr: any) => any
>match : any
>类型别名 :=> 任意
>chr : any
>类型别名 :=> 任意

    return chr.toUpperCase();
>chr.toUpperCase() : any
>类型别名 :=> 任意
>chr.toUpperCase : any
>类型别名 :=> 任意
>chr : any
>类型别名 :=> 任意
>toUpperCase : any
>类型别名 :=> 任意

  });
}

/**
 * Determines if the specified string consists entirely of whitespace.
 */
function isEmpty(string) {
>isEmpty : (string: any) => boolean
>string : any
>类型别名 :=> 任意

   return !/[^\s]/.test(string);
>!/[^\s]/.test(string) : boolean
>类型别名 :=> 真假
>/[^\s]/.test(string) : boolean
>类型别名 :=> 真假
>/[^\s]/.test : (string: string) => boolean
>/[^\s]/ : RegExp
>test : (string: string) => boolean
>string : any
>类型别名 :=> 任意
}

/**
 * Determines if the CSS value can be converted from a
 * 'px' suffixed string to a numeric value
 *
 * @param {string} value CSS property value
 * @return {boolean}
 */
function isConvertiblePixelValue(value) {
>isConvertiblePixelValue : (value: any) => boolean
>value : any
>类型别名 :=> 任意

  return /^\d+px$/.test(value);
>/^\d+px$/.test(value) : boolean
>类型别名 :=> 真假
>/^\d+px$/.test : (string: string) => boolean
>/^\d+px$/ : RegExp
>test : (string: string) => boolean
>value : any
>类型别名 :=> 任意
}

export class HTMLtoJSX {
>HTMLtoJSX : HTMLtoJSX

    private output: string;
>output : string
>类型别名 :=> 文字

    private level: number;
>level : number
>类型别名 :=> 数字

    private _inPreTag: boolean;
>_inPreTag : boolean
>类型别名 :=> 真假


  /**
   * Handles processing of the specified text node
   *
   * @param {TextNode} node
   */
  _visitText = (node) => {
>_visitText : (node: any) => void
>(node) => {    var parentTag = node.parentNode && node.parentNode.tagName.toLowerCase();    if (parentTag === 'textarea' || parentTag === 'style') {      // Ignore text content of textareas and styles, as it will have already been moved      // to a "defaultValue" attribute and "dangerouslySetInnerHTML" attribute respectively.      return;    }    var text = ''    if (this._inPreTag) {      // If this text is contained within a <pre>, we need to ensure the JSX      // whitespace coalescing rules don't eat the whitespace. This means      // wrapping newlines and sequences of two or more spaces in variables.      text = text        .replace(/\r/g, '')        .replace(/( {2,}|\n|\t|\{|\})/g, function(whitespace) {          return '{' + JSON.stringify(whitespace) + '}';        });    } else {      // If there's a newline in the text, adjust the indent level      if (text.indexOf('\n') > -1) {      }    }    this.output += text;  } : (node: any) => void
>node : any
>类型别名 :=> 任意

    var parentTag = node.parentNode && node.parentNode.tagName.toLowerCase();
>parentTag : any
>类型别名 :=> 任意
>node.parentNode && node.parentNode.tagName.toLowerCase() : any
>类型别名 :=> 任意
>node.parentNode : any
>类型别名 :=> 任意
>node : any
>类型别名 :=> 任意
>parentNode : any
>类型别名 :=> 任意
>node.parentNode.tagName.toLowerCase() : any
>类型别名 :=> 任意
>node.parentNode.tagName.toLowerCase : any
>类型别名 :=> 任意
>node.parentNode.tagName : any
>类型别名 :=> 任意
>node.parentNode : any
>类型别名 :=> 任意
>node : any
>类型别名 :=> 任意
>parentNode : any
>类型别名 :=> 任意
>tagName : any
>类型别名 :=> 任意
>toLowerCase : any
>类型别名 :=> 任意

    if (parentTag === 'textarea' || parentTag === 'style') {
>parentTag === 'textarea' || parentTag === 'style' : boolean
>类型别名 :=> 真假
>parentTag === 'textarea' : boolean
>类型别名 :=> 真假
>parentTag : any
>类型别名 :=> 任意
>'textarea' : "textarea"
>parentTag === 'style' : boolean
>类型别名 :=> 真假
>parentTag : any
>类型别名 :=> 任意
>'style' : "style"

      // Ignore text content of textareas and styles, as it will have already been moved
      // to a "defaultValue" attribute and "dangerouslySetInnerHTML" attribute respectively.
      return;
    }

    var text = ''
>text : string
>类型别名 :=> 文字
>'' : ""

    if (this._inPreTag) {
>this._inPreTag : boolean
>类型别名 :=> 真假
>this : this
>_inPreTag : boolean
>类型别名 :=> 真假

      // If this text is contained within a <pre>, we need to ensure the JSX
      // whitespace coalescing rules don't eat the whitespace. This means
      // wrapping newlines and sequences of two or more spaces in variables.
      text = text
>text = text        .replace(/\r/g, '')        .replace(/( {2,}|\n|\t|\{|\})/g, function(whitespace) {          return '{' + JSON.stringify(whitespace) + '}';        }) : string
>类型别名 :=> 文字
>text : string
>类型别名 :=> 文字
>text        .replace(/\r/g, '')        .replace(/( {2,}|\n|\t|\{|\})/g, function(whitespace) {          return '{' + JSON.stringify(whitespace) + '}';        }) : string
>类型别名 :=> 文字
>text        .replace(/\r/g, '')        .replace : { (searchValue: string | RegExp, replaceValue: string): string; (searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string; }
>text        .replace(/\r/g, '') : string
>类型别名 :=> 文字
>text        .replace : { (searchValue: string | RegExp, replaceValue: string): string; (searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string; }
>text : string
>类型别名 :=> 文字

        .replace(/\r/g, '')
>replace : { (searchValue: string | RegExp, replaceValue: string): string; (searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string; }
>/\r/g : RegExp
>'' : ""

        .replace(/( {2,}|\n|\t|\{|\})/g, function(whitespace) {
>replace : { (searchValue: string | RegExp, replaceValue: string): string; (searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string; }
>/( {2,}|\n|\t|\{|\})/g : RegExp
>function(whitespace) {          return '{' + JSON.stringify(whitespace) + '}';        } : (whitespace: string) => string
>whitespace : string
>类型别名 :=> 文字

          return '{' + JSON.stringify(whitespace) + '}';
>'{' + JSON.stringify(whitespace) + '}' : string
>类型别名 :=> 文字
>'{' + JSON.stringify(whitespace) : string
>类型别名 :=> 文字
>'{' : "{"
>JSON.stringify(whitespace) : string
>类型别名 :=> 文字
>JSON.stringify : { (value: any, replacer?: (key: string, value: any) => any, space?: string | number): string; (value: any, replacer?: (string | number)[], space?: string | number): string; }
>JSON : JSON
>stringify : { (value: any, replacer?: (key: string, value: any) => any, space?: string | number): string; (value: any, replacer?: (string | number)[], space?: string | number): string; }
>whitespace : string
>类型别名 :=> 文字
>'}' : "}"

        });
    } else {
      // If there's a newline in the text, adjust the indent level
      if (text.indexOf('\n') > -1) {
>text.indexOf('\n') > -1 : boolean
>类型别名 :=> 真假
>text.indexOf('\n') : number
>类型别名 :=> 数字
>text.indexOf : (searchString: string, position?: number) => number
>text : string
>类型别名 :=> 文字
>indexOf : (searchString: string, position?: number) => number
>'\n' : "\n"
>-1 : -1
>1 : 1
      }
    }
    this.output += text;
>this.output += text : string
>类型别名 :=> 文字
>this.output : string
>类型别名 :=> 文字
>this : this
>output : string
>类型别名 :=> 文字
>text : string
>类型别名 :=> 文字
  }



};

/**
 * Handles parsing of inline styles
 */
export class StyleParser {
>StyleParser : StyleParser

  styles = {};
>styles : {}
>{} : {}

  toJSXString = () => {
>toJSXString : () => void
>() => {    for (var key in this.styles) {      if (!this.styles.hasOwnProperty(key)) {      }    }  } : () => void

    for (var key in this.styles) {
>key : string
>类型别名 :=> 文字
>this.styles : {}
>this : this
>styles : {}

      if (!this.styles.hasOwnProperty(key)) {
>!this.styles.hasOwnProperty(key) : boolean
>类型别名 :=> 真假
>this.styles.hasOwnProperty(key) : boolean
>类型别名 :=> 真假
>this.styles.hasOwnProperty : (v: string) => boolean
>this.styles : {}
>this : this
>styles : {}
>hasOwnProperty : (v: string) => boolean
>key : string
>类型别名 :=> 文字
      }
    }
  }
}
