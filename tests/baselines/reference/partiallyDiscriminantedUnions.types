=== tests/cases/compiler/partiallyDiscriminantedUnions.ts ===
// Repro from #10586

interface A1 {
>A1 : A1

    type: 'a';
>type : "a"

    subtype: 1;
>subtype : 1
}

interface A2 {
>A2 : A2

    type: 'a';
>type : "a"

    subtype: 2;
>subtype : 2

    foo: number;
>foo : number
>类型别名 :=> 数字
}

interface B {
>B : B

    type: 'b';
>type : "b"
}

type AB = A1 | A2 | B;
>AB : AB
>A1 : A1
>A2 : A2
>B : B

const ab: AB = <AB>{};
>ab : AB
>AB : AB
><AB>{} : AB
>AB : AB
>{} : {}

if (ab.type === 'a') {
>ab.type === 'a' : boolean
>类型别名 :=> 真假
>ab.type : "a" | "b"
>ab : AB
>type : "a" | "b"
>'a' : "a"

    if (ab.subtype === 2) {
>ab.subtype === 2 : boolean
>类型别名 :=> 真假
>ab.subtype : 1 | 2
>ab : A1 | A2
>subtype : 1 | 2
>2 : 2

        ab.foo;
>ab.foo : number
>类型别名 :=> 数字
>ab : A2
>foo : number
>类型别名 :=> 数字
    }
}

// Repro from #11185

class Square { kind: "square"; }
>Square : Square
>kind : "square"

class Circle { kind: "circle"; }
>Circle : Circle
>kind : "circle"

type Shape = Circle | Square;
>Shape : Shape
>Circle : Circle
>Square : Square

type Shapes = Shape | Array<Shape>;
>Shapes : Shapes
>Shape : Shape
>Array : T[]
>Shape : Shape

function isShape(s : Shapes): s is Shape {
>isShape : (s: Shapes) => s is Shape
>s : Shapes
>Shapes : Shapes
>s : any
>类型别名 :=> 任意
>Shape : Shape

    return !Array.isArray(s);
>!Array.isArray(s) : boolean
>类型别名 :=> 真假
>Array.isArray(s) : boolean
>类型别名 :=> 真假
>Array.isArray : (arg: any) => arg is any[]
>Array : ArrayConstructor
>isArray : (arg: any) => arg is any[]
>s : Shapes
}

function fail(s: Shapes) {
>fail : (s: Shapes) => void
>s : Shapes
>Shapes : Shapes

    if (isShape(s)) {
>isShape(s) : boolean
>类型别名 :=> 真假
>isShape : (s: Shapes) => s is Shape
>s : Shapes

        if (s.kind === "circle") {
>s.kind === "circle" : boolean
>类型别名 :=> 真假
>s.kind : "square" | "circle"
>s : Shape
>kind : "square" | "circle"
>"circle" : "circle"

            let c: Circle = s;
>c : Circle
>Circle : Circle
>s : Circle
        }
    }
}
