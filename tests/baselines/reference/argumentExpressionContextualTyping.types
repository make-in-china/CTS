=== tests/cases/conformance/expressions/contextualTyping/argumentExpressionContextualTyping.ts ===
// In a typed function call, argument expressions are contextually typed by their corresponding parameter types.
function foo({x: [a, b], y: {c, d, e}}) { }
>foo : ({ x: [a, b], y: { c, d, e } }: { x: [any, any]; y: { c: any; d: any; e: any; }; }) => void
>x : any
>类型别名 :=> 任意
>a : any
>类型别名 :=> 任意
>b : any
>类型别名 :=> 任意
>y : any
>类型别名 :=> 任意
>c : any
>类型别名 :=> 任意
>d : any
>类型别名 :=> 任意
>e : any
>类型别名 :=> 任意

function bar({x: [a, b = 10], y: {c, d, e = { f:1 }}}) { }
>bar : ({ x: [a, b], y: { c, d, e } }: { x: [any, number]; y: { c: any; d: any; e?: { f: number; }; }; }) => void
>x : any
>类型别名 :=> 任意
>a : any
>类型别名 :=> 任意
>b : number
>类型别名 :=> 数字
>10 : 10
>y : any
>类型别名 :=> 任意
>c : any
>类型别名 :=> 任意
>d : any
>类型别名 :=> 任意
>e : { f: number; }
>{ f:1 } : { f: number; }
>f : number
>类型别名 :=> 数字
>1 : 1

function baz(x: [string, number, boolean]) { }
>baz : (x: [string, number, boolean]) => void
>x : [string, number, boolean]

var o = { x: ["string", 1], y: { c: true, d: "world", e: 3 } };
>o : { x: (string | number)[]; y: { c: boolean; d: string; e: number; }; }
>{ x: ["string", 1], y: { c: true, d: "world", e: 3 } } : { x: (string | number)[]; y: { c: boolean; d: string; e: number; }; }
>x : (string | number)[]
>["string", 1] : (string | number)[]
>"string" : "string"
>1 : 1
>y : { c: boolean; d: string; e: number; }
>{ c: true, d: "world", e: 3 } : { c: boolean; d: string; e: number; }
>c : boolean
>类型别名 :=> 真假
>true : true
>类型别名 :=> 为真
>d : string
>类型别名 :=> 文字
>"world" : "world"
>e : number
>类型别名 :=> 数字
>3 : 3

var o1: { x: [string, number], y: { c: boolean, d: string, e: number } } = { x: ["string", 1], y: { c: true, d: "world", e: 3 } };
>o1 : { x: [string, number]; y: { c: boolean; d: string; e: number; }; }
>x : [string, number]
>y : { c: boolean; d: string; e: number; }
>c : boolean
>类型别名 :=> 真假
>d : string
>类型别名 :=> 文字
>e : number
>类型别名 :=> 数字
>{ x: ["string", 1], y: { c: true, d: "world", e: 3 } } : { x: [string, number]; y: { c: true; d: string; e: number; }; }
>x : [string, number]
>["string", 1] : [string, number]
>"string" : "string"
>1 : 1
>y : { c: true; d: string; e: number; }
>{ c: true, d: "world", e: 3 } : { c: true; d: string; e: number; }
>c : boolean
>类型别名 :=> 真假
>true : true
>类型别名 :=> 为真
>d : string
>类型别名 :=> 文字
>"world" : "world"
>e : number
>类型别名 :=> 数字
>3 : 3

foo(o1); // Not error since x has contextual type of tuple namely [string, number]
>foo(o1) : void
>类型别名 :=> 无值
>foo : ({ x: [a, b], y: { c, d, e } }: { x: [any, any]; y: { c: any; d: any; e: any; }; }) => void
>o1 : { x: [string, number]; y: { c: boolean; d: string; e: number; }; }

foo({ x: ["string", 1], y: { c: true, d: "world", e: 3 } }); // Not error
>foo({ x: ["string", 1], y: { c: true, d: "world", e: 3 } }) : void
>类型别名 :=> 无值
>foo : ({ x: [a, b], y: { c, d, e } }: { x: [any, any]; y: { c: any; d: any; e: any; }; }) => void
>{ x: ["string", 1], y: { c: true, d: "world", e: 3 } } : { x: [string, number]; y: { c: boolean; d: string; e: number; }; }
>x : [string, number]
>["string", 1] : [string, number]
>"string" : "string"
>1 : 1
>y : { c: boolean; d: string; e: number; }
>{ c: true, d: "world", e: 3 } : { c: boolean; d: string; e: number; }
>c : boolean
>类型别名 :=> 真假
>true : true
>类型别名 :=> 为真
>d : string
>类型别名 :=> 文字
>"world" : "world"
>e : number
>类型别名 :=> 数字
>3 : 3

var array = ["string", 1, true];
>array : (string | number | boolean)[]
>["string", 1, true] : (string | number | boolean)[]
>"string" : "string"
>1 : 1
>true : true
>类型别名 :=> 为真

var tuple: [string, number, boolean] = ["string", 1, true];
>tuple : [string, number, boolean]
>["string", 1, true] : [string, number, true]
>"string" : "string"
>1 : 1
>true : true
>类型别名 :=> 为真

baz(tuple);
>baz(tuple) : void
>类型别名 :=> 无值
>baz : (x: [string, number, boolean]) => void
>tuple : [string, number, boolean]

baz(["string", 1, true]);
>baz(["string", 1, true]) : void
>类型别名 :=> 无值
>baz : (x: [string, number, boolean]) => void
>["string", 1, true] : [string, number, true]
>"string" : "string"
>1 : 1
>true : true
>类型别名 :=> 为真

baz(array);                          // Error
>baz(array) : void
>类型别名 :=> 无值
>baz : (x: [string, number, boolean]) => void
>array : (string | number | boolean)[]

baz(["string", 1, true, ...array]);  // Error
>baz(["string", 1, true, ...array]) : void
>类型别名 :=> 无值
>baz : (x: [string, number, boolean]) => void
>["string", 1, true, ...array] : (string | number | boolean)[]
>"string" : "string"
>1 : 1
>true : true
>类型别名 :=> 为真
>...array : string | number | boolean
>array : (string | number | boolean)[]

foo(o);                              // Error because x has an array type namely (string|number)[]
>foo(o) : void
>类型别名 :=> 无值
>foo : ({ x: [a, b], y: { c, d, e } }: { x: [any, any]; y: { c: any; d: any; e: any; }; }) => void
>o : { x: (string | number)[]; y: { c: boolean; d: string; e: number; }; }

