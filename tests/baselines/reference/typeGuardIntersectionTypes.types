=== tests/cases/conformance/expressions/typeGuards/typeGuardIntersectionTypes.ts ===
interface X {
>X : X

    x: string;
>x : string
>类型别名 :=> 文字
}

interface Y {
>Y : Y

    y: string;
>y : string
>类型别名 :=> 文字
}

interface Z {
>Z : Z

    z: string;
>z : string
>类型别名 :=> 文字
}

declare function isX(obj: any): obj is X;
>isX : (obj: any) => obj is X
>obj : any
>类型别名 :=> 任意
>obj : any
>类型别名 :=> 任意
>X : X

declare function isY(obj: any): obj is Y;
>isY : (obj: any) => obj is Y
>obj : any
>类型别名 :=> 任意
>obj : any
>类型别名 :=> 任意
>Y : Y

declare function isZ(obj: any): obj is Z;
>isZ : (obj: any) => obj is Z
>obj : any
>类型别名 :=> 任意
>obj : any
>类型别名 :=> 任意
>Z : Z

function f1(obj: Object) {
>f1 : (obj: Object) => void
>obj : Object
>Object : Object

    if (isX(obj) || isY(obj) || isZ(obj)) {
>isX(obj) || isY(obj) || isZ(obj) : boolean
>类型别名 :=> 真假
>isX(obj) || isY(obj) : boolean
>类型别名 :=> 真假
>isX(obj) : boolean
>类型别名 :=> 真假
>isX : (obj: any) => obj is X
>obj : Object
>isY(obj) : boolean
>类型别名 :=> 真假
>isY : (obj: any) => obj is Y
>obj : Object
>isZ(obj) : boolean
>类型别名 :=> 真假
>isZ : (obj: any) => obj is Z
>obj : Object

        obj;
>obj : X | Y | Z
    }
    if (isX(obj) && isY(obj) && isZ(obj)) {
>isX(obj) && isY(obj) && isZ(obj) : boolean
>类型别名 :=> 真假
>isX(obj) && isY(obj) : boolean
>类型别名 :=> 真假
>isX(obj) : boolean
>类型别名 :=> 真假
>isX : (obj: any) => obj is X
>obj : Object
>isY(obj) : boolean
>类型别名 :=> 真假
>isY : (obj: any) => obj is Y
>obj : X
>isZ(obj) : boolean
>类型别名 :=> 真假
>isZ : (obj: any) => obj is Z
>obj : X & Y

        obj;
>obj : X & Y & Z
    }
}

// Repro from #8911

// two interfaces
interface A {
>A : A

  a: string;
>a : string
>类型别名 :=> 文字
}

interface B {
>B : B

  b: string;
>b : string
>类型别名 :=> 文字
}

// a type guard for B
function isB(toTest: any): toTest is B {
>isB : (toTest: any) => toTest is B
>toTest : any
>类型别名 :=> 任意
>toTest : any
>类型别名 :=> 任意
>B : B

  return toTest && toTest.b;
>toTest && toTest.b : any
>类型别名 :=> 任意
>toTest : any
>类型别名 :=> 任意
>toTest.b : any
>类型别名 :=> 任意
>toTest : any
>类型别名 :=> 任意
>b : any
>类型别名 :=> 任意
}

// a function that turns an A into an A & B
function union(a: A): A & B | null {
>union : (a: A) => (A & B) | null
>a : A
>A : A
>A : A
>B : B
>null : null
>类型别名 :=> 空值

  if (isB(a)) {
>isB(a) : boolean
>类型别名 :=> 真假
>isB : (toTest: any) => toTest is B
>a : A

    return a;
>a : A & B

  } else {
    return null;
>null : null
>类型别名 :=> 空值
  }
}

// Repro from #9016

declare function log(s: string): void;
>log : (s: string) => void
>s : string
>类型别名 :=> 文字

// Supported beast features
interface Beast     { wings?: boolean; legs?: number }
>Beast : Beast
>wings : boolean | undefined
>legs : number | undefined

interface Legged    { legs: number; }
>Legged : Legged
>legs : number
>类型别名 :=> 数字

interface Winged    { wings: boolean; }
>Winged : Winged
>wings : boolean
>类型别名 :=> 真假

// Beast feature detection via user-defined type guards
function hasLegs(x: Beast): x is Legged { return x && typeof x.legs === 'number'; }
>hasLegs : (x: Beast) => x is Legged
>x : Beast
>Beast : Beast
>x : any
>类型别名 :=> 任意
>Legged : Legged
>x && typeof x.legs === 'number' : boolean
>类型别名 :=> 真假
>x : Beast
>typeof x.legs === 'number' : boolean
>类型别名 :=> 真假
>typeof x.legs : "string" | "number" | "boolean" | "symbol" | "undefined" | "object" | "function" | "文字" | "数字" | "真假" | "符号" | "未定" | "对象" | "函数"
>x.legs : number | undefined
>x : Beast
>legs : number | undefined
>'number' : "number"

function hasWings(x: Beast): x is Winged { return x && !!x.wings; }
>hasWings : (x: Beast) => x is Winged
>x : Beast
>Beast : Beast
>x : any
>类型别名 :=> 任意
>Winged : Winged
>x && !!x.wings : boolean
>类型别名 :=> 真假
>x : Beast
>!!x.wings : boolean
>类型别名 :=> 真假
>!x.wings : boolean
>类型别名 :=> 真假
>x.wings : boolean | undefined
>x : Beast
>wings : boolean | undefined

// Function to identify a given beast by detecting its features
function identifyBeast(beast: Beast) {
>identifyBeast : (beast: Beast) => void
>beast : Beast
>Beast : Beast

    // All beasts with legs
    if (hasLegs(beast)) {
>hasLegs(beast) : boolean
>类型别名 :=> 真假
>hasLegs : (x: Beast) => x is Legged
>beast : Beast

        // All winged beasts with legs
        if (hasWings(beast)) {
>hasWings(beast) : boolean
>类型别名 :=> 真假
>hasWings : (x: Beast) => x is Winged
>beast : Legged

            if (beast.legs === 4) {
>beast.legs === 4 : boolean
>类型别名 :=> 真假
>beast.legs : number
>类型别名 :=> 数字
>beast : Legged & Winged
>legs : number
>类型别名 :=> 数字
>4 : 4

                log(`pegasus - 4 legs, wings`);
>log(`pegasus - 4 legs, wings`) : void
>类型别名 :=> 无值
>log : (s: string) => void
>`pegasus - 4 legs, wings` : "pegasus - 4 legs, wings"
            }
            else if (beast.legs === 2) {
>beast.legs === 2 : boolean
>类型别名 :=> 真假
>beast.legs : number
>类型别名 :=> 数字
>beast : Legged & Winged
>legs : number
>类型别名 :=> 数字
>2 : 2

                log(`bird - 2 legs, wings`);
>log(`bird - 2 legs, wings`) : void
>类型别名 :=> 无值
>log : (s: string) => void
>`bird - 2 legs, wings` : "bird - 2 legs, wings"
            }
            else {
                log(`unknown - ${beast.legs} legs, wings`);
>log(`unknown - ${beast.legs} legs, wings`) : void
>类型别名 :=> 无值
>log : (s: string) => void
>`unknown - ${beast.legs} legs, wings` : string
>类型别名 :=> 文字
>beast.legs : number
>类型别名 :=> 数字
>beast : Legged & Winged
>legs : number
>类型别名 :=> 数字
            }
        }

        // All non-winged beasts with legs
        else {
            log(`manbearpig - ${beast.legs} legs, no wings`);
>log(`manbearpig - ${beast.legs} legs, no wings`) : void
>类型别名 :=> 无值
>log : (s: string) => void
>`manbearpig - ${beast.legs} legs, no wings` : string
>类型别名 :=> 文字
>beast.legs : number
>类型别名 :=> 数字
>beast : Legged
>legs : number
>类型别名 :=> 数字
        }
    }

    // All beasts without legs    
    else {
        if (hasWings(beast)) {
>hasWings(beast) : boolean
>类型别名 :=> 真假
>hasWings : (x: Beast) => x is Winged
>beast : Beast

            log(`quetzalcoatl - no legs, wings`)
>log(`quetzalcoatl - no legs, wings`) : void
>类型别名 :=> 无值
>log : (s: string) => void
>`quetzalcoatl - no legs, wings` : "quetzalcoatl - no legs, wings"
        }
        else {
            log(`snake - no legs, no wings`)
>log(`snake - no legs, no wings`) : void
>类型别名 :=> 无值
>log : (s: string) => void
>`snake - no legs, no wings` : "snake - no legs, no wings"
        }
    }
}

function beastFoo(beast: Object) {
>beastFoo : (beast: Object) => void
>beast : Object
>Object : Object

    if (hasWings(beast) && hasLegs(beast)) {
>hasWings(beast) && hasLegs(beast) : boolean
>类型别名 :=> 真假
>hasWings(beast) : boolean
>类型别名 :=> 真假
>hasWings : (x: Beast) => x is Winged
>beast : Object
>hasLegs(beast) : boolean
>类型别名 :=> 真假
>hasLegs : (x: Beast) => x is Legged
>beast : Winged

        beast;  // Winged & Legged
>beast : Winged & Legged
    }
    else {
        beast;
>beast : Object
    }

    if (hasLegs(beast) && hasWings(beast)) {
>hasLegs(beast) && hasWings(beast) : boolean
>类型别名 :=> 真假
>hasLegs(beast) : boolean
>类型别名 :=> 真假
>hasLegs : (x: Beast) => x is Legged
>beast : Object
>hasWings(beast) : boolean
>类型别名 :=> 真假
>hasWings : (x: Beast) => x is Winged
>beast : Legged

        beast;  // Legged & Winged
>beast : Legged & Winged
    }
}
