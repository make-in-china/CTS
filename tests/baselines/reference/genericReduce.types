=== tests/cases/compiler/genericReduce.ts ===
var a = ["An", "array", "of", "strings"];
>a : string[]
>["An", "array", "of", "strings"] : string[]
>"An" : "An"
>"array" : "array"
>"of" : "of"
>"strings" : "strings"

var b = a.map(s => s.length);
>b : number[]
>a.map(s => s.length) : number[]
>a.map : <U>(callbackfn: (value: string, index: number, array: string[]) => U, thisArg?: any) => U[]
>a : string[]
>map : <U>(callbackfn: (value: string, index: number, array: string[]) => U, thisArg?: any) => U[]
>s => s.length : (s: string) => number
>s : string
>类型别名 :=> 文字
>s.length : number
>类型别名 :=> 数字
>s : string
>类型别名 :=> 文字
>length : number
>类型别名 :=> 数字

var n1 = b.reduce((x, y) => x + y);
>n1 : number
>类型别名 :=> 数字
>b.reduce((x, y) => x + y) : number
>类型别名 :=> 数字
>b.reduce : { (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: number[]) => number): number; (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: number[]) => number, initialValue: number): number; <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: number[]) => U, initialValue: U): U; }
>b : number[]
>reduce : { (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: number[]) => number): number; (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: number[]) => number, initialValue: number): number; <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: number[]) => U, initialValue: U): U; }
>(x, y) => x + y : (x: number, y: number) => number
>x : number
>类型别名 :=> 数字
>y : number
>类型别名 :=> 数字
>x + y : number
>类型别名 :=> 数字
>x : number
>类型别名 :=> 数字
>y : number
>类型别名 :=> 数字

var n2 = b.reduceRight((x, y) => x + y);
>n2 : number
>类型别名 :=> 数字
>b.reduceRight((x, y) => x + y) : number
>类型别名 :=> 数字
>b.reduceRight : { (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: number[]) => number): number; (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: number[]) => number, initialValue: number): number; <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: number[]) => U, initialValue: U): U; }
>b : number[]
>reduceRight : { (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: number[]) => number): number; (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: number[]) => number, initialValue: number): number; <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: number[]) => U, initialValue: U): U; }
>(x, y) => x + y : (x: number, y: number) => number
>x : number
>类型别名 :=> 数字
>y : number
>类型别名 :=> 数字
>x + y : number
>类型别名 :=> 数字
>x : number
>类型别名 :=> 数字
>y : number
>类型别名 :=> 数字

n1.x = "fail";       // should error, as 'n1' should be type 'number', not 'any'.
>n1.x = "fail" : "fail"
>n1.x : any
>类型别名 :=> 任意
>n1 : number
>类型别名 :=> 数字
>x : any
>类型别名 :=> 任意
>"fail" : "fail"

n1.toExponential(2); // should not error if 'n1' is correctly number.
>n1.toExponential(2) : string
>类型别名 :=> 文字
>n1.toExponential : (fractionDigits?: number) => string
>n1 : number
>类型别名 :=> 数字
>toExponential : (fractionDigits?: number) => string
>2 : 2

n2.x = "fail";       // should error, as 'n2' should be type 'number', not 'any'.
>n2.x = "fail" : "fail"
>n2.x : any
>类型别名 :=> 任意
>n2 : number
>类型别名 :=> 数字
>x : any
>类型别名 :=> 任意
>"fail" : "fail"

n2.toExponential(2); // should not error if 'n2' is correctly number.
>n2.toExponential(2) : string
>类型别名 :=> 文字
>n2.toExponential : (fractionDigits?: number) => string
>n2 : number
>类型别名 :=> 数字
>toExponential : (fractionDigits?: number) => string
>2 : 2

var n3 = b.reduce<string>( (x, y) => x + y, ""); // Initial value is of type string
>n3 : string
>类型别名 :=> 文字
>b.reduce<string>( (x, y) => x + y, "") : string
>类型别名 :=> 文字
>b.reduce : { (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: number[]) => number): number; (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: number[]) => number, initialValue: number): number; <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: number[]) => U, initialValue: U): U; }
>b : number[]
>reduce : { (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: number[]) => number): number; (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: number[]) => number, initialValue: number): number; <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: number[]) => U, initialValue: U): U; }
>(x, y) => x + y : (x: string, y: number) => string
>x : string
>类型别名 :=> 文字
>y : number
>类型别名 :=> 数字
>x + y : string
>类型别名 :=> 文字
>x : string
>类型别名 :=> 文字
>y : number
>类型别名 :=> 数字
>"" : ""

n3.toExponential(2); // should error if 'n3' is correctly type 'string'
>n3.toExponential(2) : any
>类型别名 :=> 任意
>n3.toExponential : any
>类型别名 :=> 任意
>n3 : string
>类型别名 :=> 文字
>toExponential : any
>类型别名 :=> 任意
>2 : 2

n3.charAt(0);        // should not error if 'n3' is correctly type 'string'
>n3.charAt(0) : string
>类型别名 :=> 文字
>n3.charAt : (pos: number) => string
>n3 : string
>类型别名 :=> 文字
>charAt : (pos: number) => string
>0 : 0

