=== tests/cases/compiler/lastPropertyInLiteralWins.ts ===
interface Thing {
>Thing : Thing

    thunk: (str: string) => void;
>thunk : (str: string) => void
>str : string
>类型别名 :=> 文字
}
function test(thing: Thing) {
>test : (thing: Thing) => void
>thing : Thing
>Thing : Thing

    thing.thunk("str");
>thing.thunk("str") : void
>类型别名 :=> 无值
>thing.thunk : (str: string) => void
>thing : Thing
>thunk : (str: string) => void
>"str" : "str"
}
test({ // Should error, as last one wins, and is wrong type
>test({ // Should error, as last one wins, and is wrong type    thunk: (str: string) => {},    thunk: (num: number) => {}}) : void
>类型别名 :=> 无值
>test : (thing: Thing) => void
>{ // Should error, as last one wins, and is wrong type    thunk: (str: string) => {},    thunk: (num: number) => {}} : { thunk: (num: number) => void; }

    thunk: (str: string) => {},
>thunk : (str: string) => void
>(str: string) => {} : (str: string) => void
>str : string
>类型别名 :=> 文字

    thunk: (num: number) => {}
>thunk : (str: string) => void
>(num: number) => {} : (num: number) => void
>num : number
>类型别名 :=> 数字

});

test({ // Should be OK.  Last 'thunk' is of correct type
>test({ // Should be OK.  Last 'thunk' is of correct type    thunk: (num: number) => {},    thunk: (str: string) => {}}) : void
>类型别名 :=> 无值
>test : (thing: Thing) => void
>{ // Should be OK.  Last 'thunk' is of correct type    thunk: (num: number) => {},    thunk: (str: string) => {}} : { thunk: (str: string) => void; }

    thunk: (num: number) => {},
>thunk : (num: number) => void
>(num: number) => {} : (num: number) => void
>num : number
>类型别名 :=> 数字

    thunk: (str: string) => {}
>thunk : (num: number) => void
>(str: string) => {} : (str: string) => void
>str : string
>类型别名 :=> 文字

});

