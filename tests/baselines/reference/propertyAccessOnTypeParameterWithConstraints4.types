=== tests/cases/conformance/types/typeParameters/typeParameterLists/propertyAccessOnTypeParameterWithConstraints4.ts ===
class C<T extends Date> {
>C : C<T>
>T : T
>Date : Date

    f() {
>f : () => any

        var x: T;
>x : T
>T : T

        var a = x['notHere'](); // should be string
>a : any
>类型别名 :=> 任意
>x['notHere']() : any
>类型别名 :=> 任意
>x['notHere'] : any
>类型别名 :=> 任意
>x : T
>'notHere' : "notHere"

        return a + x.notHere();
>a + x.notHere() : any
>类型别名 :=> 任意
>a : any
>类型别名 :=> 任意
>x.notHere() : any
>类型别名 :=> 任意
>x.notHere : any
>类型别名 :=> 任意
>x : T
>notHere : any
>类型别名 :=> 任意
    }
}

var r = (new C<Date>()).f();
>r : any
>类型别名 :=> 任意
>(new C<Date>()).f() : any
>类型别名 :=> 任意
>(new C<Date>()).f : () => any
>(new C<Date>()) : C<Date>
>new C<Date>() : C<Date>
>C : typeof C
>Date : Date
>f : () => any

interface I<T extends Date> {
>I : I<T>
>T : T
>Date : Date

    foo: T;
>foo : T
>T : T
}
var i: I<Date>;
>i : I<Date>
>I : I<T>
>Date : Date

var r2 = i.foo.notHere();
>r2 : any
>类型别名 :=> 任意
>i.foo.notHere() : any
>类型别名 :=> 任意
>i.foo.notHere : any
>类型别名 :=> 任意
>i.foo : Date
>i : I<Date>
>foo : Date
>notHere : any
>类型别名 :=> 任意

var r2b = i.foo['notHere']();
>r2b : any
>类型别名 :=> 任意
>i.foo['notHere']() : any
>类型别名 :=> 任意
>i.foo['notHere'] : any
>类型别名 :=> 任意
>i.foo : Date
>i : I<Date>
>foo : Date
>'notHere' : "notHere"

var a: {
>a : <T extends Date>() => T

    <T extends Date>(): T;
>T : T
>Date : Date
>T : T
}
var r3: string = a().notHere();
>r3 : string
>类型别名 :=> 文字
>a().notHere() : any
>类型别名 :=> 任意
>a().notHere : any
>类型别名 :=> 任意
>a() : Date
>a : <T extends Date>() => T
>notHere : any
>类型别名 :=> 任意

var r3b: string = a()['notHere']();
>r3b : string
>类型别名 :=> 文字
>a()['notHere']() : any
>类型别名 :=> 任意
>a()['notHere'] : any
>类型别名 :=> 任意
>a() : Date
>a : <T extends Date>() => T
>'notHere' : "notHere"

var b = {
>b : any
>类型别名 :=> 任意
>{    foo: <T extends Date>(x: T): T => {        var a = x['notHere'](); // should be string        return a + x.notHere();    },    bar: b.foo().notHere()} : { foo: <T extends Date>(x: T) => T; bar: any; }

    foo: <T extends Date>(x: T): T => {
>foo : <T extends Date>(x: T) => T
><T extends Date>(x: T): T => {        var a = x['notHere'](); // should be string        return a + x.notHere();    } : <T extends Date>(x: T) => T
>T : T
>Date : Date
>x : T
>T : T
>T : T

        var a = x['notHere'](); // should be string
>a : any
>类型别名 :=> 任意
>x['notHere']() : any
>类型别名 :=> 任意
>x['notHere'] : any
>类型别名 :=> 任意
>x : T
>'notHere' : "notHere"

        return a + x.notHere();
>a + x.notHere() : any
>类型别名 :=> 任意
>a : any
>类型别名 :=> 任意
>x.notHere() : any
>类型别名 :=> 任意
>x.notHere : any
>类型别名 :=> 任意
>x : T
>notHere : any
>类型别名 :=> 任意

    },
    bar: b.foo().notHere()
>bar : any
>类型别名 :=> 任意
>b.foo().notHere() : any
>类型别名 :=> 任意
>b.foo().notHere : any
>类型别名 :=> 任意
>b.foo() : any
>类型别名 :=> 任意
>b.foo : any
>类型别名 :=> 任意
>b : any
>类型别名 :=> 任意
>foo : any
>类型别名 :=> 任意
>notHere : any
>类型别名 :=> 任意
}

var r4 = b.foo(new Date());
>r4 : any
>类型别名 :=> 任意
>b.foo(new Date()) : any
>类型别名 :=> 任意
>b.foo : any
>类型别名 :=> 任意
>b : any
>类型别名 :=> 任意
>foo : any
>类型别名 :=> 任意
>new Date() : Date
>Date : DateConstructor

