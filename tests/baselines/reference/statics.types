=== tests/cases/compiler/statics.ts ===
module M {
>M : typeof M

    export class C {
>C : C

        x: number;
>x : number
>类型别名 :=> 数字

        constructor(public c1: number, public c2: number, c3: number) {
>c1 : number
>类型别名 :=> 数字
>c2 : number
>类型别名 :=> 数字
>c3 : number
>类型别名 :=> 数字

            this.x = C.y+this.c1+this.c2+c3;
>this.x = C.y+this.c1+this.c2+c3 : number
>类型别名 :=> 数字
>this.x : number
>类型别名 :=> 数字
>this : this
>x : number
>类型别名 :=> 数字
>C.y+this.c1+this.c2+c3 : number
>类型别名 :=> 数字
>C.y+this.c1+this.c2 : number
>类型别名 :=> 数字
>C.y+this.c1 : number
>类型别名 :=> 数字
>C.y : number
>类型别名 :=> 数字
>C : typeof C
>y : number
>类型别名 :=> 数字
>this.c1 : number
>类型别名 :=> 数字
>this : this
>c1 : number
>类型别名 :=> 数字
>this.c2 : number
>类型别名 :=> 数字
>this : this
>c2 : number
>类型别名 :=> 数字
>c3 : number
>类型别名 :=> 数字

            this.g = (v:number) => C.f(this.x+C.y+v+this.c1+this.c2+C.pub);
>this.g = (v:number) => C.f(this.x+C.y+v+this.c1+this.c2+C.pub) : (v: number) => string
>this.g : any
>类型别名 :=> 任意
>this : this
>g : any
>类型别名 :=> 任意
>(v:number) => C.f(this.x+C.y+v+this.c1+this.c2+C.pub) : (v: number) => string
>v : number
>类型别名 :=> 数字
>C.f(this.x+C.y+v+this.c1+this.c2+C.pub) : string
>类型别名 :=> 文字
>C.f : (n: number) => string
>C : typeof C
>f : (n: number) => string
>this.x+C.y+v+this.c1+this.c2+C.pub : number
>类型别名 :=> 数字
>this.x+C.y+v+this.c1+this.c2 : number
>类型别名 :=> 数字
>this.x+C.y+v+this.c1 : number
>类型别名 :=> 数字
>this.x+C.y+v : number
>类型别名 :=> 数字
>this.x+C.y : number
>类型别名 :=> 数字
>this.x : number
>类型别名 :=> 数字
>this : this
>x : number
>类型别名 :=> 数字
>C.y : number
>类型别名 :=> 数字
>C : typeof C
>y : number
>类型别名 :=> 数字
>v : number
>类型别名 :=> 数字
>this.c1 : number
>类型别名 :=> 数字
>this : this
>c1 : number
>类型别名 :=> 数字
>this.c2 : number
>类型别名 :=> 数字
>this : this
>c2 : number
>类型别名 :=> 数字
>C.pub : number
>类型别名 :=> 数字
>C : typeof C
>pub : number
>类型别名 :=> 数字
        }

        static priv=2;
>priv : number
>类型别名 :=> 数字
>2 : 2

        static pub=3;
>pub : number
>类型别名 :=> 数字
>3 : 3

        static y=C.priv;
>y : number
>类型别名 :=> 数字
>C.priv : number
>类型别名 :=> 数字
>C : typeof C
>priv : number
>类型别名 :=> 数字

        static f(n:number) {
>f : (n: number) => string
>n : number
>类型别名 :=> 数字

            return "wow: "+(n+C.y+C.pub+C.priv);
>"wow: "+(n+C.y+C.pub+C.priv) : string
>类型别名 :=> 文字
>"wow: " : "wow: "
>(n+C.y+C.pub+C.priv) : number
>类型别名 :=> 数字
>n+C.y+C.pub+C.priv : number
>类型别名 :=> 数字
>n+C.y+C.pub : number
>类型别名 :=> 数字
>n+C.y : number
>类型别名 :=> 数字
>n : number
>类型别名 :=> 数字
>C.y : number
>类型别名 :=> 数字
>C : typeof C
>y : number
>类型别名 :=> 数字
>C.pub : number
>类型别名 :=> 数字
>C : typeof C
>pub : number
>类型别名 :=> 数字
>C.priv : number
>类型别名 :=> 数字
>C : typeof C
>priv : number
>类型别名 :=> 数字

        }        
    }
    var c=C.y;
>c : number
>类型别名 :=> 数字
>C.y : number
>类型别名 :=> 数字
>C : typeof C
>y : number
>类型别名 :=> 数字

    export function f() {
>f : () => string

        var result="";
>result : string
>类型别名 :=> 文字
>"" : ""

        result+=(c);
>result+=(c) : string
>类型别名 :=> 文字
>result : string
>类型别名 :=> 文字
>(c) : number
>类型别名 :=> 数字
>c : number
>类型别名 :=> 数字

        result+=(new C(0,1,2).x);
>result+=(new C(0,1,2).x) : string
>类型别名 :=> 文字
>result : string
>类型别名 :=> 文字
>(new C(0,1,2).x) : number
>类型别名 :=> 数字
>new C(0,1,2).x : number
>类型别名 :=> 数字
>new C(0,1,2) : C
>C : typeof C
>0 : 0
>1 : 1
>2 : 2
>x : number
>类型别名 :=> 数字

        result+=(C.f(10));
>result+=(C.f(10)) : string
>类型别名 :=> 文字
>result : string
>类型别名 :=> 文字
>(C.f(10)) : string
>类型别名 :=> 文字
>C.f(10) : string
>类型别名 :=> 文字
>C.f : (n: number) => string
>C : typeof C
>f : (n: number) => string
>10 : 10

        result+=(new C(5,10,20).g(C.y));
>result+=(new C(5,10,20).g(C.y)) : string
>类型别名 :=> 文字
>result : string
>类型别名 :=> 文字
>(new C(5,10,20).g(C.y)) : any
>类型别名 :=> 任意
>new C(5,10,20).g(C.y) : any
>类型别名 :=> 任意
>new C(5,10,20).g : any
>类型别名 :=> 任意
>new C(5,10,20) : C
>C : typeof C
>5 : 5
>10 : 10
>20 : 20
>g : any
>类型别名 :=> 任意
>C.y : number
>类型别名 :=> 数字
>C : typeof C
>y : number
>类型别名 :=> 数字

        return result;
>result : string
>类型别名 :=> 文字
    }
}

M.f();
>M.f() : string
>类型别名 :=> 文字
>M.f : () => string
>M : typeof M
>f : () => string



