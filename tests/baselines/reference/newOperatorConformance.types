=== tests/cases/conformance/expressions/newOperator/newOperatorConformance.ts ===
class C0 {
>C0 : C0

}
class C1 {
>C1 : C1

    constructor(n: number, s: string) { }
>n : number
>类型别名 :=> 数字
>s : string
>类型别名 :=> 文字
}

class T<T> {
>T : T<T>
>T : T

    constructor(n?: T) { }
>n : T
>T : T
}

var anyCtor: {
>anyCtor : new () => any

    new (): any;
};

var anyCtor1: {
>anyCtor1 : new (n: any) => any

    new (n): any;
>n : any
>类型别名 :=> 任意

};

interface nestedCtor {
>nestedCtor : nestedCtor

    new (): nestedCtor;
>nestedCtor : nestedCtor
}
var nestedCtor: nestedCtor;
>nestedCtor : nestedCtor
>nestedCtor : nestedCtor

// Construct expression with no parentheses for construct signature with 0 parameters
var a = new C0;
>a : C0
>new C0 : C0
>C0 : typeof C0

var a: C0;
>a : C0
>C0 : C0


// Generic construct expression with no parentheses
var c1 = new T;
>c1 : T<{}>
>new T : T<{}>
>T : typeof T

var c1: T<{}>;
>c1 : T<{}>
>T : T<T>

// Construct expression where constructor is of type 'any' with no parentheses
var d = new anyCtor;
>d : any
>类型别名 :=> 任意
>new anyCtor : any
>类型别名 :=> 任意
>anyCtor : new () => any

var d: any;
>d : any
>类型别名 :=> 任意

// Construct expression where constructor is of type 'any' with > 1 arg
var d = new anyCtor1(undefined);
>d : any
>类型别名 :=> 任意
>new anyCtor1(undefined) : any
>类型别名 :=> 任意
>anyCtor1 : new (n: any) => any
>undefined : undefined
>类型别名 :=> 未定

// Construct expression of type where apparent type has a construct signature with 0 arguments
function newFn1<T extends { new (): number }>(s: T) {
>newFn1 : <T extends new () => number>(s: T) => void
>T : T
>s : T
>T : T

    var p = new s;
>p : number
>类型别名 :=> 数字
>new s : number
>类型别名 :=> 数字
>s : T

    var p: number;
>p : number
>类型别名 :=> 数字
}

// Construct expression of type where apparent type has a construct signature with 1 arguments
function newFn2<T extends { new (s: number): string}>(s: T) {
>newFn2 : <T extends new (s: number) => string>(s: T) => void
>T : T
>s : number
>类型别名 :=> 数字
>s : T
>T : T

    var p = new s(32);
>p : string
>类型别名 :=> 文字
>new s(32) : string
>类型别名 :=> 文字
>s : T
>32 : 32

    var p: string;
>p : string
>类型别名 :=> 文字
}

// Construct expression of void returning function
function fnVoid(): void { }
>fnVoid : () => void

var t = new fnVoid();
>t : any
>类型别名 :=> 任意
>new fnVoid() : any
>类型别名 :=> 任意
>fnVoid : () => void

var t: any;
>t : any
>类型别名 :=> 任意

// Chained new expressions
var nested = new (new (new nestedCtor())())();
>nested : nestedCtor
>new (new (new nestedCtor())())() : nestedCtor
>(new (new nestedCtor())()) : nestedCtor
>new (new nestedCtor())() : nestedCtor
>(new nestedCtor()) : nestedCtor
>new nestedCtor() : nestedCtor
>nestedCtor : nestedCtor

var n = new nested();
>n : nestedCtor
>new nested() : nestedCtor
>nested : nestedCtor

var n = new nested();
>n : nestedCtor
>new nested() : nestedCtor
>nested : nestedCtor

