=== tests/cases/conformance/types/typeRelationships/typeInference/unionAndIntersectionInference1.ts ===
// Repro from #2264

interface Y { 'i am a very certain type': Y }
>Y : Y
>Y : Y

var y: Y = <Y>undefined;
>y : Y
>Y : Y
><Y>undefined : Y
>Y : Y
>undefined : undefined
>类型别名 :=> 未定

function destructure<a, r>(
>destructure : <a, r>(something: Y | a, haveValue: (value: a) => r, haveY: (value: Y) => r) => r
>a : a
>r : r

    something: a | Y,
>something : Y | a
>a : a
>Y : Y

    haveValue: (value: a) => r,
>haveValue : (value: a) => r
>value : a
>a : a
>r : r

    haveY: (value: Y) => r
>haveY : (value: Y) => r
>value : Y
>Y : Y
>r : r

): r {
>r : r

    return something === y ? haveY(y) : haveValue(<a>something);
>something === y ? haveY(y) : haveValue(<a>something) : r
>something === y : boolean
>类型别名 :=> 真假
>something : Y | a
>y : Y
>haveY(y) : r
>haveY : (value: Y) => r
>y : Y
>haveValue(<a>something) : r
>haveValue : (value: a) => r
><a>something : a
>a : a
>something : Y | a
}

var value = Math.random() > 0.5 ? 'hey!' : <Y>undefined;
>value : string | Y
>Math.random() > 0.5 ? 'hey!' : <Y>undefined : Y | "hey!"
>Math.random() > 0.5 : boolean
>类型别名 :=> 真假
>Math.random() : number
>类型别名 :=> 数字
>Math.random : () => number
>Math : Math
>random : () => number
>0.5 : 0.5
>'hey!' : "hey!"
><Y>undefined : Y
>Y : Y
>undefined : undefined
>类型别名 :=> 未定

var result = destructure(value, text => 'string', y => 'other one'); // text: string, y: Y
>result : string
>类型别名 :=> 文字
>destructure(value, text => 'string', y => 'other one') : string
>类型别名 :=> 文字
>destructure : <a, r>(something: Y | a, haveValue: (value: a) => r, haveY: (value: Y) => r) => r
>value : string | Y
>text => 'string' : (text: string) => string
>text : string
>类型别名 :=> 文字
>'string' : "string"
>y => 'other one' : (y: Y) => string
>y : Y
>'other one' : "other one"

// Repro from #4212

function isVoid<a>(value: void | a): value is void {
>isVoid : <a>(value: void | a) => value is void
>a : a
>value : void | a
>a : a
>value : any
>类型别名 :=> 任意

    return undefined;
>undefined : undefined
>类型别名 :=> 未定
}

function isNonVoid<a>(value: void | a) : value is a {
>isNonVoid : <a>(value: void | a) => value is a
>a : a
>value : void | a
>a : a
>value : any
>类型别名 :=> 任意
>a : a

    return undefined;
>undefined : undefined
>类型别名 :=> 未定
}

function foo1<a>(value: void|a): void {
>foo1 : <a>(value: void | a) => void
>a : a
>value : void | a
>a : a

    if (isVoid(value)) {
>isVoid(value) : boolean
>类型别名 :=> 真假
>isVoid : <a>(value: void | a) => value is void
>value : void | a

        value; // value is void
>value : void
>类型别名 :=> 无值

    } else {
        value; // value is a
>value : a
    }
}

function baz1<a>(value: void|a): void {
>baz1 : <a>(value: void | a) => void
>a : a
>value : void | a
>a : a

      if (isNonVoid(value)) {
>isNonVoid(value) : boolean
>类型别名 :=> 真假
>isNonVoid : <a>(value: void | a) => value is a
>value : void | a

          value; // value is a
>value : a

      } else {
          value; // value is void
>value : void
>类型别名 :=> 无值
      }
}

// Repro from #5417

type Maybe<T> = T | void;
>Maybe : Maybe<T>
>T : T
>T : T

function get<U>(x: U | void): U {
>get : <U>(x: void | U) => U
>U : U
>x : void | U
>U : U
>U : U

   return null; // just an example
>null : null
>类型别名 :=> 空值
}

let foo: Maybe<string>;
>foo : Maybe<string>
>Maybe : Maybe<T>

get(foo).toUpperCase(); // Ok
>get(foo).toUpperCase() : string
>类型别名 :=> 文字
>get(foo).toUpperCase : () => string
>get(foo) : string
>类型别名 :=> 文字
>get : <U>(x: void | U) => U
>foo : Maybe<string>
>toUpperCase : () => string

// Repro from #5456

interface Man {
>Man : Man

    walks: boolean;
>walks : boolean
>类型别名 :=> 真假
}

interface Bear {
>Bear : Bear

    roars: boolean;
>roars : boolean
>类型别名 :=> 真假
}

interface Pig {
>Pig : Pig

    oinks: boolean;
>oinks : boolean
>类型别名 :=> 真假
}

declare function pigify<T>(y: T & Bear): T & Pig;
>pigify : <T>(y: T & Bear) => T & Pig
>T : T
>y : T & Bear
>T : T
>Bear : Bear
>T : T
>Pig : Pig

declare var mbp: Man & Bear;
>mbp : Man & Bear
>Man : Man
>Bear : Bear

pigify(mbp).oinks; // OK, mbp is treated as Pig
>pigify(mbp).oinks : boolean
>类型别名 :=> 真假
>pigify(mbp) : Man & Pig
>pigify : <T>(y: T & Bear) => T & Pig
>mbp : Man & Bear
>oinks : boolean
>类型别名 :=> 真假

pigify(mbp).walks; // Ok, mbp is treated as Man
>pigify(mbp).walks : boolean
>类型别名 :=> 真假
>pigify(mbp) : Man & Pig
>pigify : <T>(y: T & Bear) => T & Pig
>mbp : Man & Bear
>walks : boolean
>类型别名 :=> 真假

