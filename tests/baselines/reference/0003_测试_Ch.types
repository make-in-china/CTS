=== /b/node_modules/@typesch/testCh/index.d.cts ===
//@@{ 测试:foo, 属性1:bar, 属性2:baz, 合成属性:nested, 甲:a, 乙:b }
导出 类型 测试 = {
>测试 : 测试

  属性1: 数字 | 空值;
>属性1 : 数字 | 空值
>空值 : 空值
>类型别名 :=> 空值

  属性2: 文字;
>属性2 : 文字
>类型别名 :=> 文字

  合成属性: {
>合成属性 : { 甲: 数字; 乙: 文字 | 空值; }

    甲: 数字;
>甲 : 数字
>类型别名 :=> 数字

    乙: 文字 | 空值;
>乙 : 文字 | 空值
>空值 : 空值
>类型别名 :=> 空值
  }
}

//@@{ 元素1:elem1, 元素2:elem2 }
//@{ 测试2:bar }
导出 类型 测试2 = {
>测试2 : 测试2

  元素1: 数字 | 空值;
>元素1 : 数字 | 空值
>空值 : 空值
>类型别名 :=> 空值

  元素2: 测试 | 空值;
>元素2 : 测试 | 空值
>测试 : 测试
>空值 : 空值
>类型别名 :=> 空值
}

导出 函数 取属性< T, K 扩展 键集 T> (对象值:T, 键: K): T[K]
>取属性 : <T, K 扩展 键集 T>(对象值: T, 键: K) => T[K]
>T : T
>K : K
>T : T
>对象值 : T
>T : T
>键 : K
>K : K
>T : T
>K : K

导出 函数 置属性< T, K 扩展 键集 T> (对象值:T, 键: K, 值: T[K]): T[K]
>置属性 : <T, K 扩展 键集 T>(对象值: T, 键: K, 值: T[K]) => T[K]
>T : T
>K : K
>T : T
>对象值 : T
>T : T
>键 : K
>K : K
>值 : T[K]
>T : T
>K : K
>T : T
>K : K

//@@{ "事件1":"ev1", "事件2":"ev2" }
导出 接口 事件类型{
>事件类型 : 事件类型

  "事件1":测试2;
>测试2 : 测试2

  "事件2":测试2
>测试2 : 测试2
}

导出 函数 引发事件< K 扩展 键集 事件类型> (事件:K, 实体:测试):无值
>引发事件 : <K 扩展 "事件1" | "事件2">(事件: K, 实体: 测试) => 无值
>K : K
>事件类型 : 事件类型
>事件 : K
>K : K
>实体 : 测试
>测试 : 测试

//**************** 分割线 *******************//

=== /b/测试_3_ch.cts ===
导入 { 测试, 取属性, 置属性, 引发事件, 事件类型 } 来自 "testCh"
>测试 : 任意
>类型别名 :=> 任意
>取属性 : <T, K 扩展 键集 T>(对象值: T, 键: K) => T[K]
>置属性 : <T, K 扩展 键集 T>(对象值: T, 键: K, 值: T[K]) => T[K]
>引发事件 : <K 扩展 "事件1" | "事件2">(事件: K, 实体: 测试) => 无值
>事件类型 : 任意
>类型别名 :=> 任意

常量 aFoo: 测试 = { 属性1: 3, 属性2: "b", 合成属性: { 甲: 1, 乙: "y" } };
>aFoo : 测试
>测试 : 测试
>{ 属性1: 3, 属性2: "b", 合成属性: { 甲: 1, 乙: "y" } } : { 属性1: 数字; 属性2: 文字; 合成属性: { 甲: 数字; 乙: 文字; }; }
>属性1 : 数字
>类型别名 :=> 数字
>3 : 3
>属性2 : 文字
>类型别名 :=> 文字
>"b" : "b"
>合成属性 : { 甲: 数字; 乙: 文字; }
>{ 甲: 1, 乙: "y" } : { 甲: 数字; 乙: 文字; }
>甲 : 数字
>类型别名 :=> 数字
>1 : 1
>乙 : 文字
>类型别名 :=> 文字
>"y" : "y"

常量 aFoo2: 测试 = { 属性1: 4, 属性2: "c", 合成属性: { 甲: 2, 乙: "z" } };
>aFoo2 : 测试
>测试 : 测试
>{ 属性1: 4, 属性2: "c", 合成属性: { 甲: 2, 乙: "z" } } : { 属性1: 数字; 属性2: 文字; 合成属性: { 甲: 数字; 乙: 文字; }; }
>属性1 : 数字
>类型别名 :=> 数字
>4 : 4
>属性2 : 文字
>类型别名 :=> 文字
>"c" : "c"
>合成属性 : { 甲: 数字; 乙: 文字; }
>{ 甲: 2, 乙: "z" } : { 甲: 数字; 乙: 文字; }
>甲 : 数字
>类型别名 :=> 数字
>2 : 2
>乙 : 文字
>类型别名 :=> 文字
>"z" : "z"

常量 数组值: 测试[] = [aFoo, aFoo2]
>数组值 : 测试[]
>测试 : 测试
>[aFoo, aFoo2] : 测试[]
>aFoo : 测试
>aFoo2 : 测试

函数 组合(A:文字, B:文字){
>组合 : (A: 文字, B: 文字) => 文字
>A : 文字
>类型别名 :=> 文字
>B : 文字
>类型别名 :=> 文字

  返回(A + B)
>(A + B) : 文字
>类型别名 :=> 文字
>A + B : 文字
>类型别名 :=> 文字
>A : 文字
>类型别名 :=> 文字
>B : 文字
>类型别名 :=> 文字
}
// 1
aFoo["属性1"]
>aFoo["属性1"] : 数字 | 空值
>aFoo : 测试
>"属性1" : "属性1"
>类型别名 :=> bar

常量 B: 键集 测试 = "属性1"
>B : "属性1" | "属性2" | "合成属性"
>测试 : 测试
>"属性1" : "属性1"
>类型别名 :=> bar

// 2
aFoo[B]
>aFoo[B] : 数字 | 空值
>aFoo : 测试
>B : "属性1"
>类型别名 :=> bar

// 3
aFoo[组合("属性", "1") 转为 键集 测试] 
>aFoo[组合("属性", "1") 转为 键集 测试] : 文字 | 数字 | { 甲: 数字; 乙: 文字 | 空值; } | 空值
>aFoo : 测试
>组合("属性", "1") 转为 键集 测试 : "属性1" | "属性2" | "合成属性"
>组合("属性", "1") : 文字
>类型别名 :=> 文字
>组合 : (A: 文字, B: 文字) => 文字
>"属性" : "属性"
>"1" : "1"
>测试 : 测试

// 5
组合("属性1" 转为 键集 测试 , "")
>组合("属性1" 转为 键集 测试 , "") : 文字
>类型别名 :=> 文字
>组合 : (A: 文字, B: 文字) => 文字
>"属性1" 转为 键集 测试 : "属性1" | "属性2" | "合成属性"
>"属性1" : "属性1"
>类型别名 :=> bar
>测试 : 测试
>"" : ""

// 6
组合(组合("属性", "1") 转为 键集 测试, "")
>组合(组合("属性", "1") 转为 键集 测试, "") : 文字
>类型别名 :=> 文字
>组合 : (A: 文字, B: 文字) => 文字
>组合("属性", "1") 转为 键集 测试 : "属性1" | "属性2" | "合成属性"
>组合("属性", "1") : 文字
>类型别名 :=> 文字
>组合 : (A: 文字, B: 文字) => 文字
>"属性" : "属性"
>"1" : "1"
>测试 : 测试
>"" : ""

// 7
取属性(aFoo, "属性1")
>取属性(aFoo, "属性1") : 数字 | 空值
>取属性 : <T, K 扩展 键集 T>(对象值: T, 键: K) => T[K]
>aFoo : 测试
>"属性1" : "属性1"
>类型别名 :=> bar

// 8
置属性(aFoo, "属性2", "属性2")
>置属性(aFoo, "属性2", "属性2") : 文字
>类型别名 :=> 文字
>置属性 : <T, K 扩展 键集 T>(对象值: T, 键: K, 值: T[K]) => T[K]
>aFoo : 测试
>"属性2" : "属性2"
>类型别名 :=> baz
>"属性2" : "属性2"
>类型别名 :=> baz

// 9
置属性(aFoo, 组合("属性", "1") 转为 键集 测试, 1)
>置属性(aFoo, 组合("属性", "1") 转为 键集 测试, 1) : 文字 | 数字 | { 甲: 数字; 乙: 文字 | 空值; } | 空值
>置属性 : <T, K 扩展 键集 T>(对象值: T, 键: K, 值: T[K]) => T[K]
>aFoo : 测试
>组合("属性", "1") 转为 键集 测试 : "属性1" | "属性2" | "合成属性"
>组合("属性", "1") : 文字
>类型别名 :=> 文字
>组合 : (A: 文字, B: 文字) => 文字
>"属性" : "属性"
>"1" : "1"
>测试 : 测试
>1 : 1

// 10 
引发事件("事件1", aFoo)
>引发事件("事件1", aFoo) : 无值
>类型别名 :=> 无值
>引发事件 : <K 扩展 "事件1" | "事件2">(事件: K, 实体: 测试) => 无值
>"事件1" : "事件1"
>类型别名 :=> ev1
>aFoo : 测试

// 11 
引发事件(组合("事件", "2") 转为 键集 事件类型, aFoo)
>引发事件(组合("事件", "2") 转为 键集 事件类型, aFoo) : 无值
>类型别名 :=> 无值
>引发事件 : <K 扩展 "事件1" | "事件2">(事件: K, 实体: 测试) => 无值
>组合("事件", "2") 转为 键集 事件类型 : "事件1" | "事件2"
>组合("事件", "2") : 文字
>类型别名 :=> 文字
>组合 : (A: 文字, B: 文字) => 文字
>"事件" : "事件"
>"2" : "2"
>事件类型 : 事件类型
>aFoo : 测试

循环(常量 aF 属于 数组值){
>aF : 测试
>数组值 : 测试[]

  如果(aF.属性1 === 1){
>aF.属性1 === 1 : 真假
>类型别名 :=> 真假
>aF.属性1 : 数字 | 空值
>aF : 测试
>属性1 : 数字 | 空值
>1 : 1

    aF["属性1"]
>aF["属性1"] : 数字 | 空值
>aF : 测试
>"属性1" : "属性1"
>类型别名 :=> bar

  } 否则 如果(aF.属性2 === "c"){
>aF.属性2 === "c" : 真假
>类型别名 :=> 真假
>aF.属性2 : 文字
>类型别名 :=> 文字
>aF : 测试
>属性2 : 文字
>类型别名 :=> 文字
>"c" : "c"

    aF["属性2"]
>aF["属性2"] : 文字
>类型别名 :=> 文字
>aF : 测试
>"属性2" : "属性2"
>类型别名 :=> baz

    常量 {属性2 }=aF
>属性2 : "c"
>aF : 测试

    如果(属性2){}
>属性2 : "c"
  }
}

循环(常量 aF 位于 数组值){
>aF : 文字
>类型别名 :=> 文字
>数组值 : 测试[]

  如果(数组值[aF].属性1 === 1){
>数组值[aF].属性1 === 1 : 真假
>类型别名 :=> 真假
>数组值[aF].属性1 : 数字 | 空值
>数组值[aF] : 测试
>数组值 : 测试[]
>aF : 文字
>类型别名 :=> 文字
>属性1 : 数字 | 空值
>1 : 1

    数组值[aF]["属性1"]
>数组值[aF]["属性1"] : 数字 | 空值
>数组值[aF] : 测试
>数组值 : 测试[]
>aF : 文字
>类型别名 :=> 文字
>"属性1" : "属性1"
>类型别名 :=> bar

  } 否则 如果(数组值[aF].属性2 === "c"){
>数组值[aF].属性2 === "c" : 真假
>类型别名 :=> 真假
>数组值[aF].属性2 : 文字
>类型别名 :=> 文字
>数组值[aF] : 测试
>数组值 : 测试[]
>aF : 文字
>类型别名 :=> 文字
>属性2 : 文字
>类型别名 :=> 文字
>"c" : "c"

    数组值[aF]["属性2"]
>数组值[aF]["属性2"] : 文字
>类型别名 :=> 文字
>数组值[aF] : 测试
>数组值 : 测试[]
>aF : 文字
>类型别名 :=> 文字
>"属性2" : "属性2"
>类型别名 :=> baz

    常量 {属性2 }=数组值[aF]
>属性2 : 文字
>类型别名 :=> 文字
>数组值[aF] : 测试
>数组值 : 测试[]
>aF : 文字
>类型别名 :=> 文字

    如果(属性2){}
>属性2 : 文字
>类型别名 :=> 文字
  }
}
